{"ast":null,"code":"import { parser, trackVariables } from 'lezer-feel';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { snippetCompletion as snippetCompletion$1, completeFromList, ifNotIn } from '@codemirror/autocomplete';\n\n/**\n * A collection of FEEL-related [snippets](#autocomplete.snippet).\n */\nconst snippets = [snippetCompletion$1('function(${params}) ${body}', {\n  label: 'function',\n  detail: 'definition',\n  type: 'keyword'\n}), snippetCompletion$1('for ${var} in ${collection} return ${value}', {\n  label: 'for',\n  detail: 'expression',\n  type: 'keyword'\n}), snippetCompletion$1('every ${var} in ${collection} satisfies ${condition}', {\n  label: 'every',\n  detail: 'quantified expression',\n  type: 'keyword'\n}), snippetCompletion$1('some ${var} in ${collection} satisfies ${condition}', {\n  label: 'some',\n  detail: 'quantified expression',\n  type: 'keyword'\n}), snippetCompletion$1('if ${condition} then ${value} else ${other value}', {\n  label: 'if',\n  detail: 'block',\n  type: 'keyword'\n}), snippetCompletion$1('{ ${key}: ${value} }', {\n  label: 'context',\n  detail: 'block',\n  type: 'keyword'\n})];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction contextualKeyword(options) {\n  const {\n    context: nodes,\n    after,\n    before,\n    keyword\n  } = options;\n  return ifInside({\n    nodes,\n    before,\n    after,\n    keyword\n  }, completeFromList([{\n    label: keyword,\n    type: 'keyword',\n    boost: 10\n  }]));\n}\nconst keywordCompletions = [contextualKeyword({\n  context: 'InExpression',\n  keyword: 'in'\n}), contextualKeyword({\n  context: 'IfExpression',\n  keyword: 'then',\n  after: 'if',\n  before: 'else'\n}), contextualKeyword({\n  context: 'IfExpression',\n  keyword: 'else',\n  after: 'then'\n}), contextualKeyword({\n  context: 'QuantifiedExpression',\n  keyword: 'satisfies'\n}), contextualKeyword({\n  context: 'ForExpression',\n  after: 'InExpressions',\n  keyword: 'return'\n})];\nconst dontComplete = ['StringLiteral', 'Identifier', 'LineComment', 'BlockComment'];\nfunction snippetCompletion(snippets) {\n  return ifNotIn(dontComplete, completeFromList(snippets.map(s => _extends({}, s, {\n    type: 'text'\n  }))));\n}\nfunction matchLeft(node, position, nodes) {\n  return matchChildren(node, position, nodes, -1);\n}\nfunction matchRight(node, position, nodes) {\n  return matchChildren(node, position, nodes, 1);\n}\nfunction matchChildren(node, position, nodes, direction) {\n  let child = node[direction > 0 ? 'childAfter' : 'childBefore'](position);\n  while (child) {\n    if (nodes.includes(child.name)) {\n      return child;\n    }\n    if (child.type.isError && child.firstChild) {\n      if (nodes.includes(child.firstChild.name)) {\n        return child.firstChild;\n      }\n    }\n    child = child[direction > 0 ? 'nextSibling' : 'prevSibling'];\n  }\n  return null;\n}\nfunction matchUp(node, nodeNames) {\n  if (!Array.isArray(nodeNames)) {\n    nodeNames = [nodeNames];\n  }\n  for (; node; node = node.parent) {\n    if (nodeNames.includes(node.name)) {\n      return node;\n    }\n    if (node.type.isTop) {\n      break;\n    }\n  }\n  return null;\n}\nfunction ifInside(options, source) {\n  const {\n    nodes,\n    before,\n    after,\n    keyword\n  } = options;\n  return context => {\n    const {\n      state,\n      pos\n    } = context;\n    const node = matchUp(syntaxTree(state).resolveInner(pos, -1), nodes);\n    if (!node) {\n      return null;\n    }\n    if (matchLeft(node, pos, [keyword, before])) {\n      return null;\n    }\n    if (matchRight(node, pos, [keyword, after])) {\n      return null;\n    }\n    if (after && !matchLeft(node, pos, [after])) {\n      return null;\n    }\n    return source(context);\n  };\n}\n\n/**\n * A FEEL language provider based on the\n * [Lezer FEEL parser](https://github.com/nikku/lezer-feel),\n * extended with highlighting and indentation information.\n */\nconst feelLanguage = LRLanguage.define({\n  parser: parser.configure({\n    props: [indentNodeProp.add({\n      'Context': delimitedIndent({\n        closing: '}'\n      }),\n      'List FilterExpression': delimitedIndent({\n        closing: ']'\n      }),\n      'ParenthesizedExpression FunctionInvocation': continuedIndent({\n        except: /^\\s*\\)/\n      }),\n      'ForExpression QuantifiedExpression IfExpression': continuedIndent({\n        except: /^\\s*(then|else|return|satisfies)\\b/\n      }),\n      'FunctionDefinition': continuedIndent({\n        except: /^\\s*(\\(|\\))/\n      })\n    }), foldNodeProp.add({\n      Context: foldInside,\n      List: foldInside,\n      ParenthesizedExpression: foldInside,\n      FunctionDefinition(node) {\n        const last = node.getChild(')');\n        if (!last) return null;\n        return {\n          from: last.to,\n          to: node.to\n        };\n      }\n    })]\n  }),\n  languageData: {\n    indentOnInput: /^\\s*(\\)|\\}|\\]|then|else|return|satisfies)$/,\n    commentTokens: {\n      line: '//',\n      block: {\n        open: '/*',\n        close: '*/'\n      }\n    }\n  }\n});\n/**\n * A language provider for FEEL Unary Tests\n */\nconst unaryTestsLanguage = feelLanguage.configure({\n  top: 'UnaryTests'\n});\n/**\n * Language provider for FEEL Expression\n */\nconst expressionLanguage = feelLanguage.configure({\n  top: 'Expression'\n});\n/**\n * Feel language support for CodeMirror.\n *\n * Includes [snippet](#lang-feel.snippets)\n */\nfunction feel() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const lang = config.dialect === 'unaryTests' ? unaryTestsLanguage : expressionLanguage;\n  const contextualLang = lang.configure({\n    contextTracker: trackVariables(config.context)\n  });\n  const completions = config.completions || [snippetCompletion(snippets), keywordCompletions].flat();\n  return new LanguageSupport(contextualLang, [...completions.map(autocomplete => feelLanguage.data.of({\n    autocomplete\n  }))]);\n}\nexport { contextualKeyword, dontComplete, expressionLanguage, feel, feelLanguage, ifInside, keywordCompletions, matchChildren, matchLeft, matchRight, snippetCompletion, snippets, unaryTestsLanguage };","map":{"version":3,"names":["snippets","snippetCompletion$1","label","detail","type","contextualKeyword","options","context","nodes","after","before","keyword","ifInside","completeFromList","boost","keywordCompletions","dontComplete","snippetCompletion","ifNotIn","map","s","_extends","matchLeft","node","position","matchChildren","matchRight","direction","child","includes","name","isError","firstChild","matchUp","nodeNames","Array","isArray","parent","isTop","source","state","pos","syntaxTree","resolveInner","feelLanguage","LRLanguage","define","parser","configure","props","indentNodeProp","add","delimitedIndent","closing","continuedIndent","except","foldNodeProp","Context","foldInside","List","ParenthesizedExpression","FunctionDefinition","last","getChild","from","to","languageData","indentOnInput","commentTokens","line","block","open","close","unaryTestsLanguage","top","expressionLanguage","feel","config","arguments","length","undefined","lang","dialect","contextualLang","contextTracker","trackVariables","completions","flat","LanguageSupport","autocomplete","data","of"],"sources":["/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lang-feel/src/snippets.ts","/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lang-feel/src/completion.ts","/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lang-feel/src/feel.ts"],"sourcesContent":["import { Completion, snippetCompletion } from '@codemirror/autocomplete';\n\n/**\n * A collection of FEEL-related [snippets](#autocomplete.snippet).\n */\nexport const snippets: readonly Completion[] = [\n  snippetCompletion('function(${params}) ${body}', {\n    label: 'function',\n    detail: 'definition',\n    type: 'keyword'\n  }),\n  snippetCompletion('for ${var} in ${collection} return ${value}', {\n    label: 'for',\n    detail: 'expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('every ${var} in ${collection} satisfies ${condition}', {\n    label: 'every',\n    detail: 'quantified expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('some ${var} in ${collection} satisfies ${condition}', {\n    label: 'some',\n    detail: 'quantified expression',\n    type: 'keyword'\n  }),\n  snippetCompletion('if ${condition} then ${value} else ${other value}', {\n    label: 'if',\n    detail: 'block',\n    type: 'keyword'\n  }),\n  snippetCompletion('{ ${key}: ${value} }', {\n    label: 'context',\n    detail: 'block',\n    type: 'keyword'\n  })\n];\n","import { syntaxTree } from '@codemirror/language';\nimport { SyntaxNode } from '@lezer/common';\n\nimport {\n  CompletionSource,\n  Completion,\n  completeFromList,\n  ifNotIn\n} from '@codemirror/autocomplete';\n\n\nexport function contextualKeyword(options: {\n  before?: string,\n  after?: string,\n  context: string,\n  keyword: string\n}) : CompletionSource {\n\n  const {\n    context: nodes,\n    after,\n    before,\n    keyword\n  } = options;\n\n  return ifInside({ nodes, before, after, keyword }, completeFromList([\n    { label: keyword, type: 'keyword', boost: 10 }\n  ]));\n}\n\nexport const keywordCompletions = [\n  contextualKeyword({\n    context: 'InExpression',\n    keyword: 'in'\n  }),\n  contextualKeyword({\n    context: 'IfExpression',\n    keyword: 'then',\n    after: 'if',\n    before: 'else'\n  }),\n  contextualKeyword({\n    context: 'IfExpression',\n    keyword: 'else',\n    after: 'then'\n  }),\n  contextualKeyword({\n    context: 'QuantifiedExpression',\n    keyword: 'satisfies'\n  }),\n  contextualKeyword({\n    context: 'ForExpression',\n    after: 'InExpressions',\n    keyword: 'return'\n  })\n];\n\nexport const dontComplete = [\n  'StringLiteral', 'Identifier',\n  'LineComment', 'BlockComment'\n];\n\nexport function snippetCompletion(snippets: readonly Completion[]) : CompletionSource {\n  return ifNotIn(\n    dontComplete, completeFromList(snippets.map(s => ({ ...s, type: 'text' })))\n  );\n}\n\nexport function matchLeft(node: SyntaxNode, position: number, nodes: (string|undefined)[]) : SyntaxNode | null {\n  return matchChildren(node, position, nodes, -1);\n}\n\nexport function matchRight(node: SyntaxNode, position: number, nodes: (string|undefined)[]) : SyntaxNode | null {\n  return matchChildren(node, position, nodes, 1);\n}\n\nexport function matchChildren(node: SyntaxNode, position: number, nodes: (string|undefined)[], direction: 1 | -1) : SyntaxNode | null {\n\n  let child = node[direction > 0 ? 'childAfter' : 'childBefore'](position);\n\n  while (child) {\n    if (nodes.includes(child.name)) {\n      return child;\n    }\n\n    if (child.type.isError && child.firstChild) {\n      if (nodes.includes(child.firstChild.name)) {\n        return child.firstChild;\n      }\n    }\n\n    child = child[direction > 0 ? 'nextSibling' : 'prevSibling'];\n  }\n\n  return null;\n}\n\nfunction matchUp(node: SyntaxNode, nodeNames: string | undefined | (string | undefined)[]) {\n\n  if (!Array.isArray(nodeNames)) {\n    nodeNames = [ nodeNames ];\n  }\n\n  for (; node; node = node.parent!) {\n    if (nodeNames.includes(node.name)) {\n      return node;\n    }\n\n    if (node.type.isTop) {\n      break;\n    }\n  }\n\n  return null;\n}\n\nexport function ifInside(options: {\n  nodes: string | string[],\n  keyword: string,\n  before?: string,\n  after?: string\n}, source: CompletionSource): CompletionSource {\n\n  const {\n    nodes,\n    before,\n    after,\n    keyword\n  } = options;\n\n  return (context) => {\n\n    const { state, pos } = context;\n\n    const node = matchUp(syntaxTree(state).resolveInner(pos, -1), nodes);\n\n    if (!node) {\n      return null;\n    }\n\n    if (matchLeft(node, pos, [ keyword, before ])) {\n      return null;\n    }\n\n    if (matchRight(node, pos, [ keyword, after ])) {\n      return null;\n    }\n\n    if (after && !matchLeft(node, pos, [ after ])) {\n      return null;\n    }\n\n    return source(context);\n  };\n}","import {\n  parser,\n  trackVariables\n} from 'lezer-feel';\n\nimport {\n  LRLanguage,\n  LanguageSupport,\n  delimitedIndent,\n  continuedIndent,\n  indentNodeProp,\n  foldNodeProp,\n  foldInside\n} from '@codemirror/language';\n\nimport {\n  snippets\n} from './snippets';\n\nimport {\n  keywordCompletions,\n  snippetCompletion\n} from './completion';\n\nimport {\n  CompletionSource\n} from '@codemirror/autocomplete';\n\n\n/**\n * A FEEL language provider based on the\n * [Lezer FEEL parser](https://github.com/nikku/lezer-feel),\n * extended with highlighting and indentation information.\n */\nexport const feelLanguage = LRLanguage.define({\n  parser: parser.configure({\n    props: [\n      indentNodeProp.add({\n        'Context': delimitedIndent({\n          closing: '}'\n        }),\n        'List FilterExpression': delimitedIndent({\n          closing: ']'\n        }),\n        'ParenthesizedExpression FunctionInvocation': continuedIndent({\n          except: /^\\s*\\)/\n        }),\n        'ForExpression QuantifiedExpression IfExpression': continuedIndent({\n          except: /^\\s*(then|else|return|satisfies)\\b/\n        }),\n        'FunctionDefinition': continuedIndent({\n          except: /^\\s*(\\(|\\))/\n        })\n      }),\n      foldNodeProp.add({\n        Context: foldInside,\n        List: foldInside,\n        ParenthesizedExpression: foldInside,\n        FunctionDefinition(node) {\n          const last = node.getChild(')');\n\n          if (!last) return null;\n\n          return {\n            from: last.to,\n            to: node.to\n          };\n        }\n      })\n    ]\n  }),\n  languageData: {\n    indentOnInput: /^\\s*(\\)|\\}|\\]|then|else|return|satisfies)$/,\n    commentTokens: {\n      line: '//',\n      block: {\n        open: '/*',\n        close: '*/'\n      }\n    }\n  }\n});\n\n/**\n * A language provider for FEEL Unary Tests\n */\nexport const unaryTestsLanguage = feelLanguage.configure({ top: 'UnaryTests' });\n\n/**\n * Language provider for FEEL Expression\n */\nexport const expressionLanguage = feelLanguage.configure({ top: 'Expression' });\n\n\n\n/**\n * Feel language support for CodeMirror.\n *\n * Includes [snippet](#lang-feel.snippets)\n */\nexport function feel(config: {\n  dialect?: 'expression' | 'unaryTests',\n  completions?: CompletionSource[],\n  context?: Record<string, any>\n} = {}) {\n  const lang = config.dialect === 'unaryTests' ? unaryTestsLanguage : expressionLanguage;\n\n  const contextualLang = lang.configure({\n    contextTracker: trackVariables(config.context)\n  });\n\n  const completions = config.completions || [\n    snippetCompletion(snippets),\n    keywordCompletions,\n  ].flat();\n\n  return new LanguageSupport(contextualLang, [\n    ...(\n      completions.map(autocomplete => feelLanguage.data.of({\n        autocomplete\n      }))\n    )\n  ]);\n\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}