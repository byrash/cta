{"ast":null,"code":"import { ExternalTokenizer, ContextTracker, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst propertyIdentifier = 120,\n  identifier = 121,\n  nameIdentifier = 122,\n  insertSemi = 123,\n  expression0 = 127,\n  ForExpression = 4,\n  forExpressionStart = 130,\n  ForInExpression = 7,\n  Name = 8,\n  Identifier = 9,\n  AdditionalIdentifier = 10,\n  forExpressionBodyStart = 138,\n  IfExpression = 19,\n  ifExpressionStart = 139,\n  QuantifiedExpression = 23,\n  quantifiedExpressionStart = 140,\n  QuantifiedInExpression = 27,\n  PositiveUnaryTest = 37,\n  ArithmeticExpression = 41,\n  arithmeticPlusStart = 144,\n  arithmeticTimesStart = 145,\n  arithmeticExpStart = 146,\n  arithmeticUnaryStart = 147,\n  VariableName = 47,\n  PathExpression = 67,\n  pathExpressionStart = 152,\n  FilterExpression = 69,\n  filterExpressionStart = 153,\n  FunctionInvocation = 71,\n  functionInvocationStart = 154,\n  ParameterName = 75,\n  nil = 159,\n  NumericLiteral = 78,\n  StringLiteral = 79,\n  BooleanLiteral = 80,\n  listStart = 165,\n  List = 88,\n  FunctionDefinition = 89,\n  functionDefinitionStart = 167,\n  Context = 96,\n  contextStart = 169,\n  ContextEntry = 97,\n  PropertyName = 99,\n  PropertyIdentifier = 100;\n\n/* global console,process */\n\n// @ts-expect-error env access\nconst LOG_PARSE = typeof process != 'undefined' && process.env && /\\bfparse(:dbg)?\\b/.test(process.env.LOG);\n\n// @ts-expect-error env access\nconst LOG_PARSE_DEBUG = typeof process != 'undefined' && process.env && /\\bfparse:dbg\\b/.test(process.env.LOG);\n\n// @ts-expect-error env access\nconst LOG_VARS = typeof process != 'undefined' && process.env && /\\bcontext\\b/.test(process.env.LOG);\nconst spaceChars = [9, 11, 12, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];\nconst newlineChars = chars('\\n\\r');\nconst asterix = '*'.charCodeAt(0);\nconst additionalNameChars = chars(\"'./-+*^\");\n\n/**\n * @typedef { VariableContext | any } ContextValue\n */\n\n/**\n * @param { string } str\n * @return { number[] }\n */\nfunction chars(str) {\n  return Array.from(str).map(s => s.charCodeAt(0));\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isStartChar(ch) {\n  return ch === 63 // ?\n  || ch >= 65 && ch <= 90 // A-Z\n  || ch === 95 // _\n  || ch >= 97 && ch <= 122 // a-z\n  || ch >= 0xC0 && ch <= 0xD6 || ch >= 0xD8 && ch <= 0xF6 || ch >= 0xF8 && ch <= 0x2FF || ch >= 0x370 && ch <= 0x37D || ch >= 0x37F && ch <= 0x1FFF || ch >= 0x200C && ch <= 0x200D || ch >= 0x2070 && ch <= 0x218F || ch >= 0x2C00 && ch <= 0x2FEF || ch >= 0x3001 && ch <= 0xD7FF || ch >= 0xF900 && ch <= 0xFDCF || ch >= 0xFDF0 && ch <= 0xFFFD || ch >= 0xD800 && ch <= 0xDBFF // upper surrogate\n  || ch >= 0xDC00 && ch <= 0xDFFF // lower surrogate\n  ;\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isAdditional(ch) {\n  return additionalNameChars.includes(ch);\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isPartChar(ch) {\n  return ch >= 48 && ch <= 57 // 0-9\n  || ch === 0xB7 || ch >= 0x0300 && ch <= 0x036F || ch >= 0x203F && ch <= 0x2040;\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isSpace(ch) {\n  return spaceChars.includes(ch);\n}\n\n// eslint-disable-next-line\nfunction indent(str, spaces) {\n  return spaces.concat(str.split(/\\n/g).join('\\n' + spaces));\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param  { number } [offset]\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseAdditionalSymbol(input, offset = 0) {\n  const next = input.peek(offset);\n  if (next === asterix && input.peek(offset + 1) === asterix) {\n    return {\n      offset: 2,\n      token: '**'\n    };\n  }\n  if (isAdditional(next)) {\n    return {\n      offset: 1,\n      token: String.fromCharCode(next)\n    };\n  }\n  return null;\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param { number } [offset]\n * @param { boolean } [namePart]\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseIdentifier(input, offset = 0, namePart = false) {\n  for (let inside = false, chars = [], i = 0;; i++) {\n    const next = input.peek(offset + i);\n    if (isStartChar(next) || (inside || namePart) && isPartChar(next)) {\n      if (!inside) {\n        inside = true;\n      }\n      chars.push(next);\n    } else {\n      if (chars.length) {\n        return {\n          token: String.fromCharCode(...chars),\n          offset: i\n        };\n      }\n      return null;\n    }\n  }\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param  { number } offset\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseSpaces(input, offset) {\n  for (let inside = false, i = 0;; i++) {\n    let next = input.peek(offset + i);\n    if (isSpace(next)) {\n      if (!inside) {\n        inside = true;\n      }\n    } else {\n      if (inside) {\n        return {\n          token: ' ',\n          offset: i\n        };\n      }\n      return null;\n    }\n  }\n}\n\n/**\n * Parse a name from the input and return the first match, if any.\n *\n * @param { import('@lezer/lr').InputStream } input\n * @param { Variables } variables\n *\n * @return { { token: string, offset: number, term: number } | null }\n */\nfunction parseName(input, variables) {\n  const contextKeys = variables.contextKeys();\n  const start = variables.tokens;\n  for (let i = 0, tokens = [], nextMatch = null;;) {\n    const namePart = start.length + tokens.length > 0;\n    const maybeSpace = tokens.length > 0;\n    const match = parseIdentifier(input, i, namePart) || namePart && parseAdditionalSymbol(input, i) || maybeSpace && parseSpaces(input, i);\n\n    // match is required\n    if (!match) {\n      return nextMatch;\n    }\n    const {\n      token,\n      offset\n    } = match;\n    i += offset;\n    if (token === ' ') {\n      continue;\n    }\n    tokens = [...tokens, token];\n    const name = [...start, ...tokens].join(' ');\n    if (contextKeys.some(el => el === name)) {\n      const token = tokens[0];\n      nextMatch = {\n        token,\n        offset: token.length,\n        term: nameIdentifier\n      };\n    }\n    if (contextKeys.some(el => el.startsWith(name))) {\n      continue;\n    }\n    if (dateTimeIdentifiers.some(el => el === name)) {\n      const token = tokens[0];\n\n      // parse date time identifiers as normal\n      // identifiers to allow specialization to kick in\n      //\n      // cf. https://github.com/nikku/lezer-feel/issues/8\n      nextMatch = {\n        token,\n        offset: token.length,\n        term: identifier\n      };\n    }\n    if (dateTimeIdentifiers.some(el => el.startsWith(name))) {\n      continue;\n    }\n    return nextMatch;\n  }\n}\nconst identifiersMap = {\n  [identifier]: 'identifier',\n  [nameIdentifier]: 'nameIdentifier'\n};\nconst identifiers = new ExternalTokenizer((input, stack) => {\n  LOG_PARSE_DEBUG && console.log('%s: T <identifier | nameIdentifier>', input.pos);\n  const nameMatch = parseName(input, stack.context);\n  const start = stack.context.tokens;\n  const match = nameMatch || parseIdentifier(input, 0, start.length > 0);\n  if (match) {\n    input.advance(match.offset);\n    input.acceptToken(nameMatch ? nameMatch.term : identifier);\n    LOG_PARSE && console.log('%s: MATCH <%s> <%s>', input.pos, nameMatch ? identifiersMap[nameMatch.term] : 'identifier', match.token);\n  }\n}, {\n  contextual: true\n});\nconst propertyIdentifiers = new ExternalTokenizer((input, stack) => {\n  LOG_PARSE_DEBUG && console.log('%s: T <propertyIdentifier>', input.pos);\n  const start = stack.context.tokens;\n  const match = parseIdentifier(input, 0, start.length > 0);\n  if (match) {\n    input.advance(match.offset);\n    input.acceptToken(propertyIdentifier);\n    LOG_PARSE && console.log('%s: MATCH <propertyIdentifier> <%s>', input.pos, match.token);\n  }\n});\nconst insertSemicolon = new ExternalTokenizer((input, stack) => {\n  LOG_PARSE_DEBUG && console.log('%s: T <insertSemi>', input.pos);\n  let offset;\n  let insert = false;\n  for (offset = 0;; offset++) {\n    const char = input.peek(offset);\n    if (spaceChars.includes(char)) {\n      continue;\n    }\n    if (newlineChars.includes(char)) {\n      insert = true;\n    }\n    break;\n  }\n  if (insert) {\n    const identifier = parseIdentifier(input, offset + 1);\n    const spaces = parseSpaces(input, offset + 1);\n    if (spaces || identifier && /^(then|else|return|satisfies)$/.test(identifier.token)) {\n      return;\n    }\n    LOG_PARSE && console.log('%s: MATCH <insertSemi>', input.pos);\n    input.acceptToken(insertSemi);\n  }\n});\nconst prefixedContextStarts = {\n  [functionInvocationStart]: 'FunctionInvocation',\n  [filterExpressionStart]: 'FilterExpression',\n  [pathExpressionStart]: 'PathExpression'\n};\nconst contextStarts = {\n  [contextStart]: 'Context',\n  [functionDefinitionStart]: 'FunctionDefinition',\n  [forExpressionStart]: 'ForExpression',\n  [listStart]: 'List',\n  [ifExpressionStart]: 'IfExpression',\n  [quantifiedExpressionStart]: 'QuantifiedExpression'\n};\nconst contextEnds = {\n  [Context]: 'Context',\n  [FunctionDefinition]: 'FunctionDefinition',\n  [ForExpression]: 'ForExpression',\n  [List]: 'List',\n  [IfExpression]: 'IfExpression',\n  [QuantifiedExpression]: 'QuantifiedExpression',\n  [PathExpression]: 'PathExpression',\n  [FunctionInvocation]: 'FunctionInvocation',\n  [FilterExpression]: 'FilterExpression',\n  [ArithmeticExpression]: 'ArithmeticExpression'\n};\nclass ValueProducer {\n  /**\n   * @param { Function } fn\n   */\n  constructor(fn) {\n    this.fn = fn;\n  }\n  get(variables) {\n    return this.fn(variables);\n  }\n\n  /**\n   * @param { Function } fn\n   *\n   * @return { ValueProducer }\n   */\n  static of(fn) {\n    return new ValueProducer(fn);\n  }\n}\nconst dateTimeLiterals = {\n  'date and time': 1,\n  'date': 1,\n  'time': 1,\n  'duration': 1\n};\nconst dateTimeIdentifiers = Object.keys(dateTimeLiterals);\n\n/**\n * A basic key-value store to hold context values.\n */\nclass VariableContext {\n  /**\n   * Creates a new context from a JavaScript object.\n   *\n   * @param {any} value\n   */\n  constructor(value = {}) {\n    /**\n     * @protected\n     */\n    this.value = value;\n  }\n\n  /**\n   * Return all defined keys of the context.\n   *\n   * @returns {Array<string>} the keys of the context\n   */\n  getKeys() {\n    return Object.keys(this.value);\n  }\n\n  /**\n   * Returns the value of the given key.\n   *\n   * If the value represents a context itself, it should be wrapped in a\n   * context class.\n   *\n   * @param {String} key\n   * @returns {VariableContext|ValueProducer|null}\n   */\n  get(key) {\n    const result = this.value[key];\n    const constructor = /** @type { typeof VariableContext } */this.constructor;\n    if (constructor.isAtomic(result)) {\n      return result;\n    }\n    return constructor.of(result);\n  }\n\n  /**\n   * Creates a new context with the given key added.\n   *\n   * @param {String} key\n   * @param {any} value\n   *\n   * @returns {VariableContext} new context with the given key added\n   */\n  set(key, value) {\n    const constructor = /** @type { typeof VariableContext } */this.constructor;\n    return constructor.of({\n      ...this.value,\n      [key]: value\n    });\n  }\n\n  /**\n   * Wether the given value is atomic. Non-atomic values need to be wrapped in a\n   * context Class.\n   *\n   * @param {any} value\n   * @returns {Boolean}\n   */\n  static isAtomic(value) {\n    return !value || value instanceof this || value instanceof ValueProducer || typeof value !== 'object';\n  }\n\n  /**\n   * Takes any number of Contexts and merges them into a single Context.\n   *\n   * @param  {...Context} contexts\n   * @returns {VariableContext}\n   */\n  static of(...contexts) {\n    const unwrap = context => {\n      if (!context || typeof context !== 'object') {\n        return {};\n      }\n      if (context instanceof this) {\n        return context.value;\n      }\n      return {\n        ...context\n      };\n    };\n    const merged = contexts.reduce((merged, context) => {\n      return {\n        ...merged,\n        ...unwrap(context)\n      };\n    }, {});\n    return new this(merged);\n  }\n}\nclass Variables {\n  constructor({\n    name = 'Expressions',\n    tokens = [],\n    children = [],\n    parent = null,\n    context = null,\n    value = null,\n    raw = null\n  } = {}) {\n    this.name = name;\n    this.tokens = tokens;\n    this.children = children;\n    this.parent = parent;\n    this.context = context;\n    this.value = value;\n    this.raw = raw;\n  }\n  enterScope(name) {\n    const childScope = this.of({\n      name,\n      parent: this\n    });\n    LOG_VARS && console.log('[%s] enter', childScope.path, childScope.context);\n    return childScope;\n  }\n  exitScope(str) {\n    if (!this.parent) {\n      LOG_VARS && console.log('[%s] NO exit %o\\n%s', this.path, this.context, indent(str, '  '));\n      return this;\n    }\n    LOG_VARS && console.log('[%s] exit %o\\n%s', this.path, this.context, indent(str, '  '));\n    return this.parent.pushChild(this);\n  }\n  token(part) {\n    LOG_VARS && console.log('[%s] token <%s> + <%s>', this.path, this.tokens.join(' '), part);\n    return this.assign({\n      tokens: [...this.tokens, part]\n    });\n  }\n  literal(value) {\n    LOG_VARS && console.log('[%s] literal %o', this.path, value);\n    return this.pushChild(this.of({\n      name: 'Literal',\n      value\n    }));\n  }\n\n  /**\n   * Return computed scope value\n   *\n   * @return {any}\n   */\n  computedValue() {\n    for (let scope = this;; scope = last(scope.children)) {\n      if (!scope) {\n        return null;\n      }\n      if (scope.value) {\n        return scope.value;\n      }\n    }\n  }\n  contextKeys() {\n    return this.context.getKeys().map(normalizeContextKey);\n  }\n  get path() {\n    return this.parent?.path?.concat(' > ', this.name) || this.name;\n  }\n\n  /**\n   * Return value of variable.\n   *\n   * @param { string } variable\n   * @return { any } value\n   */\n  get(variable) {\n    const names = [variable, variable && normalizeContextKey(variable)];\n    const contextKey = this.context.getKeys().find(key => names.includes(normalizeContextKey(key)));\n    if (typeof contextKey === 'undefined') {\n      return undefined;\n    }\n    const val = this.context.get(contextKey);\n    if (val instanceof ValueProducer) {\n      return val.get(this);\n    } else {\n      return val;\n    }\n  }\n  resolveName() {\n    const variable = this.tokens.join(' ');\n    const tokens = [];\n    const parentScope = this.assign({\n      tokens\n    });\n    const variableScope = this.of({\n      name: 'VariableName',\n      parent: parentScope,\n      value: this.get(variable),\n      raw: variable\n    });\n    LOG_VARS && console.log('[%s] resolve name <%s=%s>', variableScope.path, variable, this.get(variable));\n    return parentScope.pushChild(variableScope);\n  }\n  pushChild(child) {\n    if (!child) {\n      return this;\n    }\n    const parent = this.assign({\n      children: [...this.children, child]\n    });\n    child.parent = parent;\n    return parent;\n  }\n  pushChildren(children) {\n    /**\n     * @type {Variables}\n     */\n    let parent = this;\n    for (const child of children) {\n      parent = parent.pushChild(child);\n    }\n    return parent;\n  }\n  declareName() {\n    if (this.tokens.length === 0) {\n      throw Error('no tokens to declare name');\n    }\n    const variableName = this.tokens.join(' ');\n    LOG_VARS && console.log('[%s] declareName <%s>', this.path, variableName);\n    return this.assign({\n      tokens: []\n    }).pushChild(this.of({\n      name: 'Name',\n      value: variableName\n    }));\n  }\n  define(name, value) {\n    if (typeof name !== 'string') {\n      LOG_VARS && console.log('[%s] no define <%s=%s>', this.path, name, value);\n      return this;\n    }\n    LOG_VARS && console.log('[%s] define <%s=%s>', this.path, name, value);\n    const context = this.context.set(name, value);\n    return this.assign({\n      context\n    });\n  }\n\n  /**\n   * @param { Record<string, any> } [options]\n   *\n   * @return { Variables }\n   */\n  assign(options = {}) {\n    return Variables.of({\n      ...this,\n      ...options\n    });\n  }\n\n  /**\n   * @param { Record<string, any> } [options]\n   *\n   * @return { Variables }\n   */\n  of(options = {}) {\n    const defaultOptions = {\n      context: this.context,\n      parent: this.parent\n    };\n    return Variables.of({\n      ...defaultOptions,\n      ...options\n    });\n  }\n  static of(options) {\n    const {\n      name,\n      tokens = [],\n      children = [],\n      parent = null,\n      context,\n      value,\n      raw\n    } = options;\n    if (!context) {\n      throw new Error('must provide <context>');\n    }\n    return new Variables({\n      name,\n      tokens: [...tokens],\n      children: [...children],\n      context,\n      parent,\n      value,\n      raw\n    });\n  }\n}\n\n/**\n * @param { string } name\n *\n * @return { string } normalizedName\n */\nfunction normalizeContextKey(name) {\n  return name.replace(/\\s*([./\\-'+]|\\*\\*?)\\s*/g, ' $1 ').replace(/\\s{2,}/g, ' ').trim();\n}\n\n/**\n * Wrap children of variables under the given named child.\n *\n * @param { Variables } variables\n * @param { string } scopeName\n * @param { string } code\n * @return { Variables }\n */\nfunction wrap(variables, scopeName, code) {\n  const parts = variables.children.filter(c => c.name !== scopeName);\n  const children = variables.children.filter(c => c.name === scopeName);\n  const namePart = parts[0];\n  const valuePart = parts[Math.max(1, parts.length - 1)];\n  const name = namePart?.computedValue();\n  const value = valuePart?.computedValue() || null;\n  return variables.assign({\n    children\n  }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name, value);\n}\n\n/**\n * @param { ContextValue } [context]\n * @param { typeof VariableContext } [Context]\n *\n * @return { ContextTracker<Variables> }\n */\nfunction trackVariables(context = {}, Context = VariableContext) {\n  const start = Variables.of({\n    context: Context.of(context)\n  });\n  return new ContextTracker({\n    start,\n    reduce(variables, term, stack, input) {\n      if (term === IfExpression) {\n        const [thenPart, elsePart] = variables.children.slice(-2);\n        variables = variables.assign({\n          value: Context.of(thenPart?.computedValue(), elsePart?.computedValue())\n        });\n      }\n      if (term === List) {\n        variables = variables.assign({\n          value: Context.of(...variables.children.map(c => c?.computedValue()))\n        });\n      }\n      if (term === FilterExpression) {\n        const [sourcePart, _] = variables.children.slice(-2);\n        variables = variables.assign({\n          value: sourcePart?.computedValue()\n        });\n      }\n      if (term === FunctionInvocation) {\n        const [name, ...args] = variables.children;\n\n        // preserve type information through `get value(context, key)` utility\n        if (name?.raw === 'get value') {\n          variables = getContextValue(variables, args);\n        }\n      }\n      const start = contextStarts[term];\n      if (start) {\n        return variables.enterScope(start);\n      }\n      const prefixedStart = prefixedContextStarts[term];\n\n      // pull <expression> into new <prefixedStart> context\n      if (prefixedStart) {\n        const {\n          children: currentChildren,\n          context: currentContext\n        } = variables;\n        const children = currentChildren.slice(0, -1);\n        const lastChild = last(currentChildren);\n        let newContext = null;\n        if (term === pathExpressionStart) {\n          newContext = Context.of(lastChild?.computedValue());\n        }\n        if (term === filterExpressionStart) {\n          newContext = Context.of(currentContext, lastChild?.computedValue()).set('item', lastChild?.computedValue());\n        }\n        return variables.assign({\n          children\n        }).enterScope(prefixedStart).pushChild(lastChild).assign({\n          context: newContext || currentContext\n        });\n      }\n\n      // @ts-expect-error internal method\n      const code = input.read(input.pos, stack.pos);\n      const end = contextEnds[term];\n      if (end) {\n        return variables.exitScope(code);\n      }\n      if (term === ContextEntry) {\n        const parts = variables.children.filter(c => c.name !== 'ContextEntry');\n        const name = parts[0];\n        const value = last(parts);\n        return wrap(variables, 'ContextEntry', code).assign({\n          value: Context.of(variables.value).set(name?.computedValue(), value?.computedValue())\n        });\n      }\n      if (term === ForInExpression || term === QuantifiedInExpression) {\n        return wrap(variables, 'InExpression', code);\n      }\n\n      // define <partial> within ForExpression body\n      if (term === forExpressionBodyStart) {\n        return variables.define('partial', ValueProducer.of(variables => {\n          return last(variables.children)?.computedValue();\n        }));\n      }\n      if (term === ParameterName) {\n        const name = last(variables.children).computedValue();\n\n        // TODO: attach type information\n        return variables.define(name, 1);\n      }\n\n      // pull <expression> into ArithmeticExpression child\n      if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {\n        const children = variables.children.slice(0, -1);\n        const lastChild = last(variables.children);\n        return variables.assign({\n          children\n        }).enterScope('ArithmeticExpression').pushChild(lastChild);\n      }\n      if (term === arithmeticUnaryStart) {\n        return variables.enterScope('ArithmeticExpression');\n      }\n      if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {\n        return variables.token(code);\n      }\n      if (term === StringLiteral) {\n        return variables.literal(code.replace(/^\"|\"$/g, ''));\n      }\n      if (term === BooleanLiteral) {\n        return variables.literal(code === 'true' ? true : false);\n      }\n      if (term === NumericLiteral) {\n        return variables.literal(parseFloat(code));\n      }\n      if (term === nil) {\n        return variables.literal(null);\n      }\n      if (term === VariableName) {\n        return variables.resolveName();\n      }\n      if (term === Name || term === PropertyName) {\n        return variables.declareName();\n      }\n      if (term === expression0 || term === PositiveUnaryTest) {\n        if (variables.tokens.length > 0) {\n          throw new Error('uncleared name');\n        }\n      }\n      if (term === expression0) {\n        let parent = variables;\n        while (parent.parent) {\n          parent = parent.exitScope(code);\n        }\n        return parent;\n      }\n      return variables;\n    }\n  });\n}\nconst variableTracker = trackVariables({});\n\n// helpers //////////////\n\nfunction getContextValue(variables, args) {\n  if (!args.length) {\n    return variables.assign({\n      value: null\n    });\n  }\n  if (args[0].name === 'Name') {\n    args = extractNamedArgs(args, ['m', 'key']);\n  }\n  if (args.length !== 2) {\n    return variables.assign({\n      value: null\n    });\n  }\n  const [context, key] = args;\n  const keyValue = key?.computedValue();\n  const contextValue = context?.computedValue();\n  if (!contextValue || typeof contextValue !== 'object' || typeof keyValue !== 'string') {\n    return variables.assign({\n      value: null\n    });\n  }\n  return variables.assign({\n    value: [normalizeContextKey(keyValue), keyValue].reduce((value, keyValue) => {\n      return contextValue.get(keyValue) || value;\n    }, null)\n  });\n}\nfunction extractNamedArgs(args, argNames) {\n  const context = {};\n  for (let i = 0; i < args.length; i += 2) {\n    const [name, value] = args.slice(i, i + 2);\n    context[name.value] = value;\n  }\n  return argNames.map(name => context[name]);\n}\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nconst feelHighlighting = styleTags({\n  StringLiteral: tags.string,\n  NumericLiteral: tags.number,\n  BooleanLiteral: tags.bool,\n  'AtLiteral!': tags.special(tags.string),\n  CompareOp: tags.compareOperator,\n  ArithOp: tags.arithmeticOperator,\n  'for if then else some every satisfies between return': tags.controlKeyword,\n  'in instance of and or': tags.operatorKeyword,\n  function: tags.definitionKeyword,\n  as: tags.keyword,\n  'Type/...': tags.typeName,\n  Wildcard: tags.special(tags.variableName),\n  null: tags.null,\n  LineComment: tags.lineComment,\n  BlockComment: tags.blockComment,\n  'VariableName! \"?\"': tags.variableName,\n  'DateTimeConstructor! SpecialFunctionName!': tags.function(tags.special(tags.variableName)),\n  'List Interval': tags.list,\n  Context: tags.definition(tags.literal),\n  'Name!': tags.definition(tags.variableName),\n  'Key/Name! ContextEntryType/Name!': tags.definition(tags.propertyName),\n  'PathExpression/VariableName!': tags.function(tags.propertyName),\n  'FormalParameter/ParameterName!': tags.function(tags.definition(tags.variableName)),\n  '( )': tags.paren,\n  '[ ]': tags.squareBracket,\n  '{ }': tags.brace,\n  '.': tags.derefOperator,\n  ', ;': tags.separator,\n  '..': tags.punctuation\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n  __proto__: null,\n  for: 10,\n  in: 32,\n  return: 36,\n  if: 40,\n  then: 42,\n  else: 44,\n  some: 48,\n  every: 50,\n  satisfies: 56,\n  or: 60,\n  and: 64,\n  between: 72,\n  instance: 86,\n  of: 89,\n  days: 99,\n  time: 101,\n  duration: 103,\n  years: 105,\n  months: 107,\n  date: 109,\n  list: 115,\n  context: 121,\n  function: 128,\n  null: 154,\n  true: 326,\n  false: 326,\n  \"?\": 168,\n  external: 184,\n  not: 209\n};\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"CpO`QYOOO`QYOOO$gQYOOOOQU'#Ce'#CeO$qQYO'#C`O%zQYO'#FPOOQQ'#Fe'#FeO&UQYO'#FeO`QYO'#DVOOQU'#Em'#EmO'rQ^O'#D]OOQO'#Fl'#FlO)oQWO'#DuOOQQ'#D|'#D|OOQQ'#D}'#D}OOQQ'#EO'#EOO)tOWO'#ERO)oQWO'#EPOOQQ'#EP'#EPOOQQ'#Fr'#FrOOQQ'#Fp'#FpOOQQ'#Fw'#FwOOQQ'#ET'#ETO`QYO'#EVOOQQ'#FR'#FRO)yQ^O'#FRO+pQYO'#EWO+wQWO'#EXOOQP'#F{'#F{O+|QXO'#E`OOQQ'#Fx'#FxOOQQ'#FQ'#FQQOQWOOOOQQ'#FS'#FSOOQQ'#F]'#F]O`QYO'#CoOOQQ'#F^'#F^O$qQYO'#CsO,XQYO'#DvOOQQ'#Fq'#FqO,^QYO'#EQOOQO'#EQ'#EQO`QYO'#EUO`QYO'#ETOOQO'#Fy'#FyQ,fQWOOO,kQYO'#DRO-bQWO'#FaOOQO'#DT'#DTO-mQYO'#FeO-tQWOOO.kQYO'#CdO.xQYO'#FUOOQQ'#Cc'#CcO.}QYO'#FTOOQQ'#Cb'#CbO/VQYO,58zO`QYO,59iOOQQ'#Fb'#FbOOQQ'#Fc'#FcOOQQ'#Fd'#FdO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fj'#FjO$qQYO,5:]OOQQ'#Fk'#FkO`QYO,5:_O`QYO,59eO`QYO,59gO`QYO,59iO0uQYO,59iO0|QYO,59rOOQQ,5:h,5:hO1RQYO,59qOOQU-E8k-E8kO2uQYO'#FmOOQQ,5:a,5:aOOQQ,5:m,5:mOOQQ,5:k,5:kO2|QYO,5:qOOQQ,5;m,5;mO3WQYO,5:pO3eQWO,5:rO3jQYO,5:sOOQP'#Ed'#EdO4aQXO'#EcOOQO'#Eb'#EbO4hQWO'#EaO4mQWO'#F|O4uQWO,5:zO4zQYO,59ZO.xQYO'#F`OOQQ'#Cw'#CwO5RQYO'#F_OOQQ'#Cv'#CvO5ZQYO,59_O5`QYO,5:bO5eQYO,5:lO3PQYO,5:pO5jQYO,5:oO`QYO'#EvQ,fQWOOO`QYO'#ElO6aQWO,5;{O`QYOOOOQR'#Cf'#CfOOQQ'#Ei'#EiO7ZQYO,59OO`QYO,5;pOOQQ'#FX'#FXO$qQYO'#EjO7kQYO,5;oO`QYO1G.fOOQQ'#F['#F[O8bQYO1G/TO;XQYO1G/]O;cQYO1G/]O;mQYO1G/]OOQQ1G/w1G/wO=aQYO1G/yO=hQYO1G/PO>qQYO1G/RO?zQYO1G/TO`QYO1G/TOOQQ1G/T1G/TO@bQYO1G/^O@|Q^O'#CdOB`QYO'#FoOOQO'#Dy'#DyOBjQWO'#DxOBoQWO'#FnOOQO'#Dw'#DwOOQO'#Dz'#DzOBwQWO,5<XOOQQ1G0]1G0]O`QYO1G0[O`QYO'#ErOB|QWO,5<ZOOQQ1G0^1G0^OCXQWO'#EZOCdQWO'#FzOOQO'#EY'#EYOClQWO1G0_OOQP'#Et'#EtOCqQXO,5:}O`QYO,5:{OCxQXO'#EuODQQWO,5<hOOQQ1G0f1G0fO`QYO1G.uO`QYO,5;zO$qQYO'#EkODYQYO,5;yO`QYO1G.yODbQYO1G/|OOQO1G0W1G0WOOQO,5;b,5;bOOQO-E8t-E8tOOQO,5;W,5;WOOQO-E8j-E8jODgQWOOOOQQ-E8g-E8gODlQYO'#CmOOQQ1G1[1G1[OOQQ,5;U,5;UOOQQ-E8h-E8hODyQYO7+$QOOQQ7+%e7+%eO`QYO7+$oOEpQYO,5:qOE}QWO7+$oOFSQYO'#D[OOQQ'#DZ'#DZOGvQYO'#D^OG{QYO'#D^OHQQYO'#D^OHVQ`O'#DfOH[Q`O'#DiOHaQ`O'#DmOOQQ7+$x7+$xO`QYO,5:dO$qQYO'#EqOHfQWO,5<YOOQQ1G1s1G1sOIlQYO7+%vOIyQYO,5;^OOQO-E8p-E8pO@bQYO,5:uO$qQYO'#EsOJWQWO,5<fOJ`QYO7+%yOOQP-E8r-E8rOJgQYO1G0gOOQO,5;a,5;aOOQO-E8s-E8sOJqQYO7+$aOJxQYO1G1fOOQQ,5;V,5;VOOQQ-E8i-E8iOKSQYO7+$eOOQO7+%h7+%hO`QYO,59XOKyQYO<<HZOOQQ<<HZ<<HZO$qQYO'#EnOMSQYO,59vONvQYO,59xON{QYO,59xO! QQYO,59xO! VQYO,5:QO$qQYO,5:TO! qQbO,5:XO! xQYO1G0OOOQO,5;],5;]OOQO-E8o-E8oO!!SQYO<<IbOOQQ<<Ib<<IbOOQO1G0a1G0aOOQO,5;_,5;_OOQO-E8q-E8qO!%OQYO'#E]OOQQ<<Ie<<IeO`QYO<<IeO`QYO<<G{O!%uQYO1G.sOOQQ,5;Y,5;YOOQQ-E8l-E8lO!&PQYO1G/dOOQQ1G/d1G/dO!&UQbO'#D]O!&gQ`O'#D[O!&rQ`O1G/lO!&wQWO'#DlO!&|Q`O'#FfOOQO'#Dk'#DkO!'UQ`O1G/oOOQO'#Dp'#DpO!'ZQ`O'#FhOOQO'#Do'#DoO!'cQ`O1G/sOOQQAN?PAN?PO!'hQYOAN=gOOQQ7+%O7+%OO!(_Q`O,59vOOQQ7+%W7+%WO! VQYO,5:WO$qQYO'#EoO!(jQ`O,5<QOOQQ7+%Z7+%ZO! VQYO'#EpO!(rQ`O,5<SO!(zQ`O7+%_OOQO1G/r1G/rOOQO,5;Z,5;ZOOQO-E8m-E8mOOQO,5;[,5;[OOQO-E8n-E8nO@bQYO<<HyOOQQAN>eAN>eO$qQYO'#EnO! VQYO<<HyO!)PQ`O7+%_O!)UQ`O1G/sO! qQbO,5:XO!)ZQ`O'#Dm\",\n  stateData: \"!)h~O#qOS#rOSPOSQOS~OTqOZVO[UOdrOhtOitOs{OvgO!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~OTqO[UOdrOhtOitOs{OvgO!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~OZ!RO#[!SO~P!|O#mRO#nRO~OZ![O[![O]!]O^!]O_!^O`!iOn!fOp!gOr!ZOs!ZOt!hO{!jO!h!dO#y!bOv$`X~O#k#sX$q#sX~P$yO$g!kOT$XXZ$XX[$XXd$XXh$XXi$XXs$XXv$XX!S$XX!T$XX!U$XX!W$XX!b$XX!f$XX!h$XX!o$XX!v$XX#R$XX#m$XX#n$XX$h$XX$i$XX$j$XX~O#mRO#nROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!h!PX#k!PX#o!PX#y!PX$q!PX#}!PXx!PX#|!PX!f!PXe!PXb!PX#Q!PXf!PXl!PX~Ov!nO~O$h^O~O#o!sOZ#uX[#uX]#uX^#uX_#uX`#uXn#uXp#uXr#uXs#uXt#uXv#uX{#uX!h#uX#k#uX#y#uX$q#uX#}#uXx#uX#|#uX!f#uXe#uXb#uX#Q#uXf#uXl#uX~O!f$cP~P`Ov!vO~O#l!wO$h^O#Q$pP~Op#TO~Op#UOv!tX~O$q#XO~O#kuX#}uX$quXxuX#|uX!fuXeuXbuX#QuXfuXluX~P$yO#}#ZO#k$TXx$TX~O#k#ZX~P&UOv#]O~OZ#^O[#^O]#^O^#^O_#^O#mRO#nRO#y#^O#z#^O$ZWX~O`WXxWX#}WX~P-yO`#bO~O#}#cOb#wX~Ob#fO~OTqOZVO[UOdrOhtOitOs{O!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~Ov#pO~P/[O|#rO~O{!jO!h!dO#y!bOZya[ya]ya^ya_ya`yanyapyaryasyatyav$`X#kya$qya#}yaxya#|ya!fyaeyabya#Qyafyalya~Ox$cP~P`Ox#{O#|#|O~P$yO#|#|O#}#}O!f$cX~P$yO!f$PO~O#mRO#nROx$nP~OZ#^O[#^O]#^O^#^O_#^O#l!wO#y#^O#z#^O~O$Z#VX~P3uO$Z$WO~O#}$XO#Q$pX~O#Q$ZO~Oe$[O~P$yO#}$^Ol$RX~Ol$`O~O!V$aO~O!S$bO~O#k!wa$q!wa#}!wax!wa#|!wa!f!wae!wab!wa#Q!waf!wal!wa~P$yO#}#ZO#k$Tax$Ta~OZ#^O[#^O]#^O^#^O_#^O#mRO#nRO#y#^O#z#^O~O`Wa$ZWaxWa#}Wa~P6lO#}#cOb#wa~OZ![O[![O]!]O^!]O_!^O{!jO!h!dO#y!bOv$`X~O`qinqipqirqisqitqi#kqi$qqi#}qixqi#|qi!fqieqibqi#Qqifqilqi~P7sO_!^O{!jO!h!dO#y!bOZyi[yi`yinyipyiryisyityiv$`X#kyi$qyi#}yixyi#|yi!fyieyibyi#Qyifyilyi~O]!]O^!]O~P9kO]yi^yi~P9kO{!jO!h!dO#y!bOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$`X#kyi$qyi#}yixyi#|yi!fyieyibyi#Qyifyilyi~O!f$nO~P$yO`!iOp!gOr!ZOs!ZOt!hOnmi#kmi$qmi#}mixmi#|mi!fmiemibmi#Qmifmilmi~P7sO`!iOr!ZOs!ZOt!hOnoipoi#koi$qoi#}oixoi#|oi!foieoiboi#Qoifoiloi~P7sO`!iOn!fOp$oOr!ZOs!ZOt!hO~P7sO!R$tO!U$uO!W$vO!Z$wO!^$xO!b$yO#mRO#nRO~OZ#aX[#aX]#aX^#aX_#aX`#aXn#aXp#aXr#aXs#aXt#aXv#aXx#aX{#aX!h#aX#m#aX#n#aX#o#aX#y#aX#}#aX~P-yO#}#}Ox$cX~P$yO$Z${O~O#}$|Ox$bX~Ox%OO~O#}#}O!f$cax$ca~O$Z%SOx!}X#}!}X~O#}%TOx$nX~Ox%VO~O$Z#Va~P3uO#l!wO$h^O~O#}$XO#Q$pa~O#}$^Ol$Ra~O!T%aO~OxpO~O#|%bObaX#}aX~P$yO#kSq$qSq#}SqxSq#|Sq!fSqeSqbSq#QSqfSqlSq~P$yOx#{O#|#|O#}uX~P$yOx%dO~O#y%eOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!h!OX#k!OX$q!OX#}!OXx!OX#|!OX!f!OXe!OXb!OX#Q!OXf!OXl!OX~Op%gO~Op%hO~Op%iO~O![%jO~O![%kO~O![%lO~O#}$|Ox$ba~OZ![O[![O]!]O^!]O_!^O`!iOn!fOp!gOr!ZOs!ZOt!hO{!jO#y!bOv$`X~Ox%qO!f%qO!h%pO~PHnO!f#fa#}#fax#fa~P$yO#}%TOx$na~O#O%wO~P`O#Q#Ti#}#Ti~P$yOf%xO~P$yOl$Si#}$Si~P$yO#kgq$qgq#}gqxgq#|gq!fgqegqbgq#Qgqfgqlgq~P$yO`qynqypqyrqysqytqy#kqy$qqy#}qyxqy#|qy!fqyeqybqy#Qqyfqylqy~P7sO#y%eOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!h!Oa#k!Oa$q!Oa#}!Oax!Oa#|!Oa!f!Oae!Oab!Oa#Q!Oaf!Oal!Oa~O!S%|O~O!V%|O~O!S%}O~O!R$tO!U$uO!W$vO!Z$wO!^$xO!b&sO#mRO#nRO~O!X$[P~P! VOx!li#}!li~P$yOT$_XZ$_X[$_X]!xy^!xy_!xy`!xyd$_Xh$_Xi$_Xn!xyp!xyr!xys$_Xt!xyv$_X{!xy!S$_X!T$_X!U$_X!W$_X!b$_X!f$_X!h$_X!o$_X!v$_X#R$_X#k!xy#m$_X#n$_X#y!xy$g$_X$h$_X$i$_X$j$_X$q!xy#}!xyx!xy#|!xye!xyb!xy#Q!xyf!xyl!xy~O#k#PX$q#PX#}#PXx#PX#|#PX!f#PXe#PXb#PX#Q#PXf#PXl#PX~P$yObai#}ai~P$yO!T&]O~O#mRO#nRO!X!PX#y!PX#}!PX~O#y&nO!X!OX#}!OX~O!X&_O~O$Z&`O~O#}&aO!X$YX~O!X&cO~O#}&dO!X$[X~O!X&fO~O#kc!R$qc!R#}c!Rxc!R#|c!R!fc!Rec!Rbc!R#Qc!Rfc!Rlc!R~P$yO#y&nO!X!Oa#}!Oa~O#}&aO!X$Ya~O#}&dO!X$[a~O$]&lO~O$]&oO~O!X&pO~O![&rO~OQP_^$g]#y~\",\n  goto: \"Du$qPPPP$rP%k%n%t&W'qPPPPPP'zP$rPPP$rPP'}(QP$rP$rP$rPPP(WP(cP$r$rPP(l)R)^)RPPPPPPP)RPP)RP*k*n)RP*t*z$rP$rP$r+R+z+},T+zP,]-U,],].U.}P$r/v$r0o0o1h1kP1qPP0o1w1}.Q2RPP2ZP2^2e2k2q2w4S4^4d4j4p4w4}5T5ZPPPPPPPP5a5j7q8j9c9fPP9jPP9p9s:l;e;h;l;q<`=O=o>hP>kP>o?b@T@|ASAV$rA]A]PPPPBU7qB}CvCyDr!mhOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!YSQ!WSR$k#cS!US#cS#Ou$^W#u!n!v$|%TT&R%k&a#WXOPQWYgjsz{!Z!_!`!a!c!e!f!g!h!i#X#Z#]#a#e#p#r#|#}$W$[$]$`$o${%S%V%b%e%j%l%w%x&O&`&d&l&n&o&rb!TSu!v#c$^$|%T%k&aU#_!T#`#sR#s!nU#_!T#`#sT$U!x$VR$j#aR#SuQ#QuR%^$^U!PQ#]#pQ#q!iR$e#ZQpQQ$g#]R$q#pQ$z#rQ%r%SQ&Q%jU&V%l&d&rQ&g&`T&m&l&oc$s#r%S%j%l&`&d&l&o&r!liOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ#k!cU$r#r%S&lS%z%e&n]&P%j%l&`&d&o&rR&U%kQ&S%kR&h&aQ&Y%lR&q&rS&W%l&rR&j&d!mZOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR#z!nQ#w!nR%n$|S#v!n$|T$Q!v%T!mcOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!lcOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ!p`T!ym$X!maOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mbOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mfOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mnOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR$T!vQ$R!vR%s%TQ%v%VR&Z%wQ!{mR%Y$XT!zm$XS!xm$XT$U!x$VRpQS#`!T#sR$h#`Q#d!WR$l#dQ$_#QR%_$_Q#[!PR$f#[!vYOPQWgjsz{!Z!_!`!a!c!e!f!g!h!i!n#X#Z#]#a#e#p#r#|#}$W$[$]$`$o${%S%V%b%e%w%x&lS!mY&O_&O%j%l&`&d&n&o&rQ%f$rS%{%f&^R&^&PQ&b&SR&i&bQ&e&WR&k&eQ$}#wR%o$}S$O!t#tR%R$OQ%U$RR%t%UQ$V!xR%W$VQ$Y!{R%Z$YQ#Y}R$d#YQpOQ}PR$c#XUTOP#XW!OQ!i#Z#]Q!lWQ!rgQ!tjQ!}sQ#VzQ#W{Q#g!ZQ#h!_Q#i!`Q#j!aQ#l!eQ#m!fQ#n!gQ#o!hQ#t!nQ$i#aQ$m#eQ$p#pQ%P#|Q%Q#}Q%X$WQ%[$[Q%]$]Q%`$`Q%c$oQ%m${S%u%V%wQ%y%bR&[%x!moOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mSOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!XST!VS#cQ#a!UR$]#OR#e!Y!msOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!muOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR#RuT#Pu$^V!QQ#]#p!X!_T!O!r!t!}#V#W#g#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!Z!`T!O!r!t!}#V#W#g#h#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!]!aT!O!r!t!}#V#W#g#h#i#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!mWOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR&T%kT&X%l&r!a!cT!O!l!r!t!}#V#W#g#h#i#j#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!a!eT!O!l!r!t!}#V#W#g#h#i#j#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!m[OPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ!o[R!qaR#x!nQ!ujR#y!n!mdOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mjOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mkOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR$S!v!mmOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!|m\",\n  nodeNames: \"âš  LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not\",\n  maxTerm: 171,\n  context: variableTracker,\n  nodeProps: [[\"closedBy\", 38, \")\", 70, \"]\", 95, \"}\"], [\"openedBy\", 40, \"(\", 68, \"[\", 94, \"{\"], [\"group\", -5, 77, 78, 79, 80, 81, \"Literal\"]],\n  propSources: [feelHighlighting],\n  skippedNodes: [0, 1, 2],\n  repeatNodeCount: 14,\n  tokenData: \"+l~RuXY#fYZ$ZZ[#f]^$Zpq#fqr$`rs$kwx&cxy&hyz&mz{&r{|'P|}'U}!O'Z!O!P'h!P!Q(Q!Q![){![!]*^!]!^*c!^!_*h!_!`$f!`!a*w!b!c+R!}#O+W#P#Q+]#Q#R&z#o#p+b#q#r+g$f$g#f#BY#BZ#f$IS$I_#f$I|$I}$Z$I}$JO$Z$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~#kY#q~XY#fZ[#fpq#f$f$g#f#BY#BZ#f$IS$I_#f$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~$`O#r~~$cP!_!`$f~$kOr~~$pW$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&]<%lO$k~%_O$h~~%bRO;'S$k;'S;=`%k;=`O$k~%pX$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&];=`<%l$k<%lO$k~&`P;=`<%l$k~&hO#z~~&mOv~~&rOx~~&wP^~z{&z~'PO_~~'UO[~~'ZO#}~R'`PZP!`!a'cQ'hO$]Q~'mQ#y~!O!P's!Q!['x~'xO#|~~'}P$g~!Q!['x~(VQ]~z{(]!P!Q)d~(`TOz(]z{(o{;'S(];'S;=`)^<%lO(]~(rVOz(]z{(o{!P(]!P!Q)X!Q;'S(];'S;=`)^<%lO(]~)^OQ~~)aP;=`<%l(]~)iSP~OY)dZ;'S)d;'S;=`)u<%lO)d~)xP;=`<%l)d~*QQ$g~!O!P*W!Q![){~*ZP!Q!['x~*cO$Z~~*hO$q~R*oP![QsP!_!`*rP*wOsPR+OP!XQsP!_!`*r~+WO$j~~+]O!h~~+bO!f~~+gO#R~~+lO#Q~\",\n  tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],\n  topRules: {\n    \"Expression\": [0, 3],\n    \"Expressions\": [1, 101],\n    \"UnaryTests\": [2, 102]\n  },\n  dynamicPrecedences: {\n    \"31\": -1,\n    \"71\": -1,\n    \"73\": -1\n  },\n  specialized: [{\n    term: 121,\n    get: value => spec_identifier[value] || -1\n  }],\n  tokenPrec: 2500\n});\nexport { VariableContext, normalizeContextKey, parser, trackVariables };","map":{"version":3,"names":["propertyIdentifier","identifier","nameIdentifier","insertSemi","expression0","ForExpression","forExpressionStart","ForInExpression","Name","Identifier","AdditionalIdentifier","forExpressionBodyStart","IfExpression","ifExpressionStart","QuantifiedExpression","quantifiedExpressionStart","QuantifiedInExpression","PositiveUnaryTest","ArithmeticExpression","arithmeticPlusStart","arithmeticTimesStart","arithmeticExpStart","arithmeticUnaryStart","VariableName","PathExpression","pathExpressionStart","FilterExpression","filterExpressionStart","FunctionInvocation","functionInvocationStart","ParameterName","nil","NumericLiteral","StringLiteral","BooleanLiteral","listStart","List","FunctionDefinition","functionDefinitionStart","Context","contextStart","ContextEntry","PropertyName","PropertyIdentifier","LOG_PARSE","process","env","test","LOG","LOG_PARSE_DEBUG","LOG_VARS","spaceChars","newlineChars","chars","asterix","charCodeAt","additionalNameChars","str","Array","from","map","s","isStartChar","ch","isAdditional","includes","isPartChar","isSpace","indent","spaces","concat","split","join","parseAdditionalSymbol","input","offset","next","peek","token","String","fromCharCode","parseIdentifier","namePart","inside","i","push","length","parseSpaces","parseName","variables","contextKeys","start","tokens","nextMatch","maybeSpace","match","name","some","el","term","startsWith","dateTimeIdentifiers","identifiersMap","identifiers","ExternalTokenizer","stack","console","log","pos","nameMatch","context","advance","acceptToken","contextual","propertyIdentifiers","insertSemicolon","insert","char","prefixedContextStarts","contextStarts","contextEnds","ValueProducer","constructor","fn","get","of","dateTimeLiterals","Object","keys","VariableContext","value","getKeys","key","result","isAtomic","set","contexts","unwrap","merged","reduce","Variables","children","parent","raw","enterScope","childScope","path","exitScope","pushChild","part","assign","literal","computedValue","scope","last","normalizeContextKey","variable","names","contextKey","find","undefined","val","resolveName","parentScope","variableScope","child","pushChildren","declareName","Error","variableName","define","options","defaultOptions","replace","trim","wrap","scopeName","code","parts","filter","c","valuePart","Math","max","trackVariables","ContextTracker","thenPart","elsePart","slice","sourcePart","_","args","getContextValue","prefixedStart","currentChildren","currentContext","lastChild","newContext","read","end","parseFloat","variableTracker","extractNamedArgs","keyValue","contextValue","argNames","arr","feelHighlighting","styleTags","tags","string","number","bool","special","CompareOp","compareOperator","ArithOp","arithmeticOperator","controlKeyword","operatorKeyword","function","definitionKeyword","as","keyword","typeName","Wildcard","null","LineComment","lineComment","BlockComment","blockComment","list","definition","propertyName","paren","squareBracket","brace","derefOperator","separator","punctuation","spec_identifier","__proto__","for","in","return","if","then","else","every","satisfies","or","and","between","instance","days","time","duration","years","months","date","true","false","external","not","parser","LRParser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","propSources","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","dynamicPrecedences","specialized","tokenPrec"],"sources":["/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lezer-feel/src/parser.terms.js","/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lezer-feel/src/tokens.js","/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lezer-feel/src/highlight.js","/Users/Shivaji/Workspace/Play/cta/ui/node_modules/lezer-feel/src/parser.js"],"sourcesContent":["// This file was generated by lezer-generator. You probably shouldn't edit it.\nexport const\n  propertyIdentifier = 120,\n  identifier = 121,\n  nameIdentifier = 122,\n  insertSemi = 123,\n  LineComment = 1,\n  BlockComment = 2,\n  Expression = 3,\n  expression0 = 127,\n  ForExpression = 4,\n  forExpressionStart = 130,\n  ForInExpressions = 6,\n  ForInExpression = 7,\n  Name = 8,\n  Identifier = 9,\n  AdditionalIdentifier = 10,\n  minus = 11,\n  plus = 12,\n  divide = 13,\n  multi = 14,\n  exp = 15,\n  inExpressionSep = 135,\n  IterationContext = 17,\n  forExpressionBodyStart = 138,\n  IfExpression = 19,\n  ifExpressionStart = 139,\n  QuantifiedExpression = 23,\n  quantifiedExpressionStart = 140,\n  QuantifiedInExpressions = 26,\n  QuantifiedInExpression = 27,\n  Disjunction = 29,\n  Conjunction = 31,\n  Comparison = 33,\n  PositiveUnaryTest = 37,\n  PositiveUnaryTests = 39,\n  ArithmeticExpression = 41,\n  arithmeticPlusStart = 144,\n  arithmeticTimesStart = 145,\n  arithmeticExpStart = 146,\n  arithmeticUnaryStart = 147,\n  InstanceOfExpression = 42,\n  Type = 45,\n  QualifiedName = 46,\n  VariableName = 47,\n  SpecialType = 48,\n  ContextEntryTypes = 61,\n  ContextEntryType = 62,\n  ArgumentTypes = 65,\n  ArgumentType = 66,\n  PathExpression = 67,\n  pathExpressionStart = 152,\n  FilterExpression = 69,\n  filterExpressionStart = 153,\n  FunctionInvocation = 71,\n  functionInvocationStart = 154,\n  SpecialFunctionName = 72,\n  functionInvocationParameters = 155,\n  NamedParameters = 73,\n  NamedParameter = 74,\n  ParameterName = 75,\n  PositionalParameters = 76,\n  literal = 158,\n  nil = 159,\n  NumericLiteral = 78,\n  StringLiteral = 79,\n  BooleanLiteral = 80,\n  DateTimeLiteral = 81,\n  DateTimeConstructor = 82,\n  AtLiteral = 83,\n  SimplePositiveUnaryTest = 85,\n  Interval = 86,\n  listStart = 165,\n  ParenthesizedExpression = 87,\n  List = 88,\n  FunctionDefinition = 89,\n  functionDefinitionStart = 167,\n  FormalParameters = 90,\n  FormalParameter = 91,\n  Context = 96,\n  contextStart = 169,\n  ContextEntry = 97,\n  Key = 98,\n  PropertyName = 99,\n  PropertyIdentifier = 100,\n  Expressions = 101,\n  UnaryTests = 102\n","/* global console,process */\n\nimport {\n  insertSemi,\n  Identifier,\n  functionDefinitionStart,\n  FunctionDefinition,\n  contextStart,\n  Context,\n  forExpressionStart,\n  forExpressionBodyStart,\n  ForExpression,\n  quantifiedExpressionStart,\n  QuantifiedExpression,\n  ContextEntry,\n  Name,\n  ForInExpression,\n  identifier,\n  VariableName,\n  expression0,\n  QuantifiedInExpression,\n  PositiveUnaryTest,\n  nameIdentifier,\n  propertyIdentifier,\n  PropertyIdentifier,\n  PropertyName,\n  StringLiteral,\n  BooleanLiteral,\n  NumericLiteral,\n  List,\n  listStart,\n  pathExpressionStart,\n  PathExpression,\n  ParameterName,\n  IfExpression,\n  ifExpressionStart,\n  filterExpressionStart,\n  FilterExpression,\n  ArithmeticExpression,\n  arithmeticPlusStart,\n  arithmeticTimesStart,\n  arithmeticExpStart,\n  arithmeticUnaryStart,\n  nil,\n  AdditionalIdentifier,\n  FunctionInvocation,\n  functionInvocationStart\n} from './parser.terms.js';\n\nimport {\n  ContextTracker,\n  ExternalTokenizer\n} from '@lezer/lr';\n\n// @ts-expect-error env access\nconst LOG_PARSE = typeof process != 'undefined' && process.env && /\\bfparse(:dbg)?\\b/.test(process.env.LOG);\n\n// @ts-expect-error env access\nconst LOG_PARSE_DEBUG = typeof process != 'undefined' && process.env && /\\bfparse:dbg\\b/.test(process.env.LOG);\n\n// @ts-expect-error env access\nconst LOG_VARS = typeof process != 'undefined' && process.env && /\\bcontext\\b/.test(process.env.LOG);\n\nconst spaceChars = [\n  9, 11, 12, 32, 133, 160,\n  5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198,\n  8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288\n];\n\nconst newlineChars = chars('\\n\\r');\n\nconst asterix = '*'.charCodeAt(0);\n\nconst additionalNameChars = chars(\"'./-+*^\");\n\n/**\n * @typedef { VariableContext | any } ContextValue\n */\n\n/**\n * @param { string } str\n * @return { number[] }\n */\nfunction chars(str) {\n  return Array.from(str).map(s => s.charCodeAt(0));\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isStartChar(ch) {\n  return (\n    ch === 63 // ?\n  ) || (\n    ch >= 65 && ch <= 90 // A-Z\n  ) || (\n    ch === 95 // _\n  ) || (\n    ch >= 97 && ch <= 122 // a-z\n  ) || (\n    ch >= 0xC0 && ch <= 0xD6\n  ) || (\n    ch >= 0xD8 && ch <= 0xF6\n  ) || (\n    ch >= 0xF8 && ch <= 0x2FF\n  ) || (\n    ch >= 0x370 && ch <= 0x37D\n  ) || (\n    ch >= 0x37F && ch <= 0x1FFF\n  ) || (\n    ch >= 0x200C && ch <= 0x200D\n  ) || (\n    ch >= 0x2070 && ch <= 0x218F\n  ) || (\n    ch >= 0x2C00 && ch <= 0x2FEF\n  ) || (\n    ch >= 0x3001 && ch <= 0xD7FF\n  ) || (\n    ch >= 0xF900 && ch <= 0xFDCF\n  ) || (\n    ch >= 0xFDF0 && ch <= 0xFFFD\n  ) || (\n    ch >= 0xD800 && ch <= 0xDBFF // upper surrogate\n  ) || (\n    ch >= 0xDC00 && ch <= 0xDFFF // lower surrogate\n  );\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isAdditional(ch) {\n  return additionalNameChars.includes(ch);\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isPartChar(ch) {\n  return (\n    ch >= 48 && ch <= 57 // 0-9\n  ) || (\n    ch === 0xB7\n  ) || (\n    ch >= 0x0300 && ch <= 0x036F\n  ) || (\n    ch >= 0x203F && ch <= 0x2040\n  );\n}\n\n/**\n * @param { number } ch\n * @return { boolean }\n */\nfunction isSpace(ch) {\n  return spaceChars.includes(ch);\n}\n\n// eslint-disable-next-line\nfunction indent(str, spaces) {\n  return spaces.concat(\n    str.split(/\\n/g).join('\\n' + spaces)\n  );\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param  { number } [offset]\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseAdditionalSymbol(input, offset = 0) {\n\n  const next = input.peek(offset);\n\n  if (next === asterix && input.peek(offset + 1) === asterix) {\n\n    return {\n      offset: 2,\n      token: '**'\n    };\n  }\n\n  if (isAdditional(next)) {\n    return {\n      offset: 1,\n      token: String.fromCharCode(next)\n    };\n  }\n\n  return null;\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param { number } [offset]\n * @param { boolean } [namePart]\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseIdentifier(input, offset = 0, namePart = false) {\n  for (let inside = false, chars = [], i = 0;; i++) {\n    const next = input.peek(offset + i);\n\n    if (isStartChar(next) || ((inside || namePart) && isPartChar(next))) {\n      if (!inside) {\n        inside = true;\n      }\n\n      chars.push(next);\n    } else {\n\n      if (chars.length) {\n        return {\n          token: String.fromCharCode(...chars),\n          offset: i\n        };\n      }\n\n      return null;\n    }\n  }\n}\n\n/**\n * @param { import('@lezer/lr').InputStream } input\n * @param  { number } offset\n *\n * @return { { token: string, offset: number } | null }\n */\nfunction parseSpaces(input, offset) {\n\n  for (let inside = false, i = 0;; i++) {\n    let next = input.peek(offset + i);\n\n    if (isSpace(next)) {\n      if (!inside) {\n        inside = true;\n      }\n    } else {\n      if (inside) {\n        return {\n          token: ' ',\n          offset: i\n        };\n      }\n\n      return null;\n    }\n  }\n}\n\n/**\n * Parse a name from the input and return the first match, if any.\n *\n * @param { import('@lezer/lr').InputStream } input\n * @param { Variables } variables\n *\n * @return { { token: string, offset: number, term: number } | null }\n */\nfunction parseName(input, variables) {\n  const contextKeys = variables.contextKeys();\n\n  const start = variables.tokens;\n\n  for (let i = 0, tokens = [], nextMatch = null;;) {\n\n    const namePart = (start.length + tokens.length) > 0;\n    const maybeSpace = tokens.length > 0;\n\n    const match = (\n      parseIdentifier(input, i, namePart) ||\n      namePart && parseAdditionalSymbol(input, i) ||\n      maybeSpace && parseSpaces(input, i)\n    );\n\n    // match is required\n    if (!match) {\n      return nextMatch;\n    }\n\n    const {\n      token,\n      offset\n    } = match;\n\n    i += offset;\n\n    if (token === ' ') {\n      continue;\n    }\n\n    tokens = [ ...tokens, token ];\n\n    const name = [ ...start, ...tokens ].join(' ');\n\n    if (contextKeys.some(el => el === name)) {\n      const token = tokens[0];\n\n      nextMatch = {\n        token,\n        offset: token.length,\n        term: nameIdentifier\n      };\n    }\n\n    if (contextKeys.some(el => el.startsWith(name))) {\n      continue;\n    }\n\n    if (dateTimeIdentifiers.some(el => el === name)) {\n      const token = tokens[0];\n\n      // parse date time identifiers as normal\n      // identifiers to allow specialization to kick in\n      //\n      // cf. https://github.com/nikku/lezer-feel/issues/8\n      nextMatch = {\n        token,\n        offset: token.length,\n        term: identifier\n      };\n    }\n\n    if (dateTimeIdentifiers.some(el => el.startsWith(name))) {\n      continue;\n    }\n\n    return nextMatch;\n  }\n\n}\n\nconst identifiersMap = {\n  [ identifier ]: 'identifier',\n  [ nameIdentifier ]: 'nameIdentifier'\n};\n\nexport const identifiers = new ExternalTokenizer((input, stack) => {\n\n  LOG_PARSE_DEBUG && console.log('%s: T <identifier | nameIdentifier>', input.pos);\n\n  const nameMatch = parseName(input, stack.context);\n\n  const start = stack.context.tokens;\n\n  const match = nameMatch || parseIdentifier(input, 0, start.length > 0);\n\n  if (match) {\n    input.advance(match.offset);\n    input.acceptToken(nameMatch ? nameMatch.term : identifier);\n\n    LOG_PARSE && console.log('%s: MATCH <%s> <%s>', input.pos, nameMatch ? identifiersMap[nameMatch.term] : 'identifier', match.token);\n  }\n}, { contextual: true });\n\n\nexport const propertyIdentifiers = new ExternalTokenizer((input, stack) => {\n\n  LOG_PARSE_DEBUG && console.log('%s: T <propertyIdentifier>', input.pos);\n\n  const start = stack.context.tokens;\n\n  const match = parseIdentifier(input, 0, start.length > 0);\n\n  if (match) {\n    input.advance(match.offset);\n    input.acceptToken(propertyIdentifier);\n\n    LOG_PARSE && console.log('%s: MATCH <propertyIdentifier> <%s>', input.pos, match.token);\n  }\n});\n\n\nexport const insertSemicolon = new ExternalTokenizer((input, stack) => {\n\n  LOG_PARSE_DEBUG && console.log('%s: T <insertSemi>', input.pos);\n\n  let offset;\n  let insert = false;\n\n  for (offset = 0;; offset++) {\n    const char = input.peek(offset);\n\n    if (spaceChars.includes(char)) {\n      continue;\n    }\n\n    if (newlineChars.includes(char)) {\n      insert = true;\n    }\n\n    break;\n  }\n\n  if (insert) {\n\n    const identifier = parseIdentifier(input, offset + 1);\n    const spaces = parseSpaces(input, offset + 1);\n\n    if (spaces || identifier && /^(then|else|return|satisfies)$/.test(identifier.token)) {\n      return;\n    }\n\n    LOG_PARSE && console.log('%s: MATCH <insertSemi>', input.pos);\n    input.acceptToken(insertSemi);\n  }\n});\n\nconst prefixedContextStarts = {\n  [ functionInvocationStart ]: 'FunctionInvocation',\n  [ filterExpressionStart ]: 'FilterExpression',\n  [ pathExpressionStart ]: 'PathExpression'\n};\n\nconst contextStarts = {\n  [ contextStart ]: 'Context',\n  [ functionDefinitionStart ]: 'FunctionDefinition',\n  [ forExpressionStart ]: 'ForExpression',\n  [ listStart ]: 'List',\n  [ ifExpressionStart ]: 'IfExpression',\n  [ quantifiedExpressionStart ]: 'QuantifiedExpression'\n};\n\nconst contextEnds = {\n  [ Context ]: 'Context',\n  [ FunctionDefinition ]: 'FunctionDefinition',\n  [ ForExpression ]: 'ForExpression',\n  [ List ]: 'List',\n  [ IfExpression ]: 'IfExpression',\n  [ QuantifiedExpression ]: 'QuantifiedExpression',\n  [ PathExpression ]: 'PathExpression',\n  [ FunctionInvocation ]: 'FunctionInvocation',\n  [ FilterExpression ]: 'FilterExpression',\n  [ ArithmeticExpression ]: 'ArithmeticExpression'\n};\n\nclass ValueProducer {\n\n  /**\n   * @param { Function } fn\n   */\n  constructor(fn) {\n    this.fn = fn;\n  }\n\n  get(variables) {\n    return this.fn(variables);\n  }\n\n  /**\n   * @param { Function } fn\n   *\n   * @return { ValueProducer }\n   */\n  static of(fn) {\n    return new ValueProducer(fn);\n  }\n\n}\n\nconst dateTimeLiterals = {\n  'date and time': 1,\n  'date': 1,\n  'time': 1,\n  'duration': 1\n};\n\nconst dateTimeIdentifiers = Object.keys(dateTimeLiterals);\n\n\n/**\n * A basic key-value store to hold context values.\n */\nexport class VariableContext {\n\n  /**\n   * Creates a new context from a JavaScript object.\n   *\n   * @param {any} value\n   */\n  constructor(value = {}) {\n\n    /**\n     * @protected\n     */\n    this.value = value;\n  }\n\n  /**\n   * Return all defined keys of the context.\n   *\n   * @returns {Array<string>} the keys of the context\n   */\n  getKeys() {\n    return Object.keys(this.value);\n  }\n\n  /**\n   * Returns the value of the given key.\n   *\n   * If the value represents a context itself, it should be wrapped in a\n   * context class.\n   *\n   * @param {String} key\n   * @returns {VariableContext|ValueProducer|null}\n   */\n  get(key) {\n    const result = this.value[key];\n\n    const constructor = /** @type { typeof VariableContext } */ (this.constructor);\n\n    if (constructor.isAtomic(result)) {\n      return result;\n    }\n\n    return constructor.of(result);\n  }\n\n  /**\n   * Creates a new context with the given key added.\n   *\n   * @param {String} key\n   * @param {any} value\n   *\n   * @returns {VariableContext} new context with the given key added\n   */\n  set(key, value) {\n\n    const constructor = /** @type { typeof VariableContext } */ (this.constructor);\n\n    return constructor.of({\n      ...this.value,\n      [key]: value\n    });\n  }\n\n  /**\n   * Wether the given value is atomic. Non-atomic values need to be wrapped in a\n   * context Class.\n   *\n   * @param {any} value\n   * @returns {Boolean}\n   */\n  static isAtomic(value) {\n    return !value ||\n          value instanceof this ||\n          value instanceof ValueProducer ||\n          typeof value !== 'object';\n  }\n\n  /**\n   * Takes any number of Contexts and merges them into a single Context.\n   *\n   * @param  {...Context} contexts\n   * @returns {VariableContext}\n   */\n  static of(...contexts) {\n    const unwrap = (context) => {\n      if (!context || typeof context !== 'object') {\n        return {};\n      }\n\n      if (context instanceof this) {\n        return context.value;\n      }\n\n      return { ...context };\n    };\n\n    const merged = contexts.reduce((merged, context) => {\n      return {\n        ...merged,\n        ...unwrap(context)\n      };\n    }, {});\n\n    return new this(merged);\n  }\n\n}\n\nclass Variables {\n\n  constructor({\n    name = 'Expressions',\n    tokens = [],\n    children = [],\n    parent = null,\n    context = null,\n    value = null,\n    raw = null\n  } = {}) {\n    this.name = name;\n    this.tokens = tokens;\n    this.children = children;\n    this.parent = parent;\n    this.context = context;\n    this.value = value;\n    this.raw = raw;\n  }\n\n  enterScope(name) {\n\n    const childScope = this.of({\n      name,\n      parent: this\n    });\n\n    LOG_VARS && console.log('[%s] enter', childScope.path, childScope.context);\n\n    return childScope;\n  }\n\n  exitScope(str) {\n\n    if (!this.parent) {\n      LOG_VARS && console.log('[%s] NO exit %o\\n%s', this.path, this.context, indent(str, '  '));\n\n      return this;\n    }\n\n    LOG_VARS && console.log('[%s] exit %o\\n%s', this.path, this.context, indent(str, '  '));\n\n    return this.parent.pushChild(this);\n  }\n\n  token(part) {\n\n    LOG_VARS && console.log('[%s] token <%s> + <%s>', this.path, this.tokens.join(' '), part);\n\n    return this.assign({\n      tokens: [ ...this.tokens, part ]\n    });\n  }\n\n  literal(value) {\n\n    LOG_VARS && console.log('[%s] literal %o', this.path, value);\n\n    return this.pushChild(this.of({\n      name: 'Literal',\n      value\n    }));\n  }\n\n  /**\n   * Return computed scope value\n   *\n   * @return {any}\n   */\n  computedValue() {\n    for (let scope = this;;scope = last(scope.children)) {\n\n      if (!scope) {\n        return null;\n      }\n\n      if (scope.value) {\n        return scope.value;\n      }\n    }\n  }\n\n  contextKeys() {\n    return this.context.getKeys().map(normalizeContextKey);\n  }\n\n  get path() {\n    return this.parent?.path?.concat(' > ', this.name) || this.name;\n  }\n\n  /**\n   * Return value of variable.\n   *\n   * @param { string } variable\n   * @return { any } value\n   */\n  get(variable) {\n\n    const names = [ variable, variable && normalizeContextKey(variable) ];\n\n    const contextKey = this.context.getKeys().find(\n      key => names.includes(normalizeContextKey(key))\n    );\n\n    if (typeof contextKey === 'undefined') {\n      return undefined;\n    }\n\n    const val = this.context.get(contextKey);\n\n    if (val instanceof ValueProducer) {\n      return val.get(this);\n    } else {\n      return val;\n    }\n  }\n\n  resolveName() {\n\n    const variable = this.tokens.join(' ');\n    const tokens = [];\n\n    const parentScope = this.assign({\n      tokens\n    });\n\n    const variableScope = this.of({\n      name: 'VariableName',\n      parent: parentScope,\n      value: this.get(variable),\n      raw: variable\n    });\n\n    LOG_VARS && console.log('[%s] resolve name <%s=%s>', variableScope.path, variable, this.get(variable));\n\n    return parentScope.pushChild(variableScope);\n  }\n\n  pushChild(child) {\n\n    if (!child) {\n      return this;\n    }\n\n    const parent = this.assign({\n      children: [ ...this.children, child ]\n    });\n\n    child.parent = parent;\n\n    return parent;\n  }\n\n  pushChildren(children) {\n\n    /**\n     * @type {Variables}\n     */\n    let parent = this;\n\n    for (const child of children) {\n      parent = parent.pushChild(child);\n    }\n\n    return parent;\n  }\n\n  declareName() {\n\n    if (this.tokens.length === 0) {\n      throw Error('no tokens to declare name');\n    }\n\n    const variableName = this.tokens.join(' ');\n\n    LOG_VARS && console.log('[%s] declareName <%s>', this.path, variableName);\n\n    return this.assign({\n      tokens: []\n    }).pushChild(\n      this.of({\n        name: 'Name',\n        value: variableName\n      })\n    );\n  }\n\n  define(name, value) {\n\n    if (typeof name !== 'string') {\n      LOG_VARS && console.log('[%s] no define <%s=%s>', this.path, name, value);\n\n      return this;\n    }\n\n    LOG_VARS && console.log('[%s] define <%s=%s>', this.path, name, value);\n\n    const context = this.context.set(name, value);\n\n    return this.assign({\n      context\n    });\n  }\n\n  /**\n   * @param { Record<string, any> } [options]\n   *\n   * @return { Variables }\n   */\n  assign(options = {}) {\n\n    return Variables.of({\n      ...this,\n      ...options\n    });\n  }\n\n  /**\n   * @param { Record<string, any> } [options]\n   *\n   * @return { Variables }\n   */\n  of(options = {}) {\n\n    const defaultOptions = {\n      context: this.context,\n      parent: this.parent\n    };\n\n    return Variables.of({\n      ...defaultOptions,\n      ...options\n    });\n  }\n\n  static of(options) {\n\n    const {\n      name,\n      tokens = [],\n      children = [],\n      parent = null,\n      context,\n      value,\n      raw\n    } = options;\n\n    if (!context) {\n      throw new Error('must provide <context>');\n    }\n\n    return new Variables({\n      name,\n      tokens: [ ...tokens ],\n      children: [ ...children ],\n      context,\n      parent,\n      value,\n      raw\n    });\n  }\n\n}\n\n/**\n * @param { string } name\n *\n * @return { string } normalizedName\n */\nexport function normalizeContextKey(name) {\n  return name.replace(/\\s*([./\\-'+]|\\*\\*?)\\s*/g, ' $1 ').replace(/\\s{2,}/g, ' ').trim();\n}\n\n/**\n * Wrap children of variables under the given named child.\n *\n * @param { Variables } variables\n * @param { string } scopeName\n * @param { string } code\n * @return { Variables }\n */\nfunction wrap(variables, scopeName, code) {\n\n  const parts = variables.children.filter(c => c.name !== scopeName);\n  const children = variables.children.filter(c => c.name === scopeName);\n\n  const namePart = parts[0];\n  const valuePart = parts[Math.max(1, parts.length - 1)];\n\n  const name = namePart?.computedValue();\n  const value = valuePart?.computedValue() || null;\n\n  return variables\n    .assign({\n      children\n    })\n    .enterScope(scopeName)\n    .pushChildren(parts)\n    .exitScope(code)\n    .define(name, value);\n}\n\n/**\n * @param { ContextValue } [context]\n * @param { typeof VariableContext } [Context]\n *\n * @return { ContextTracker<Variables> }\n */\nexport function trackVariables(context = {}, Context = VariableContext) {\n\n  const start = Variables.of({\n    context: Context.of(context)\n  });\n\n  return new ContextTracker({\n    start,\n    reduce(variables, term, stack, input) {\n\n      if (term === IfExpression) {\n        const [ thenPart, elsePart ] = variables.children.slice(-2);\n\n        variables = variables.assign({\n          value: Context.of(\n            thenPart?.computedValue(),\n            elsePart?.computedValue()\n          )\n        });\n      }\n\n      if (term === List) {\n        variables = variables.assign({\n          value: Context.of(\n            ...variables.children.map(\n              c => c?.computedValue()\n            )\n          )\n        });\n      }\n\n      if (term === FilterExpression) {\n        const [ sourcePart, _ ] = variables.children.slice(-2);\n\n        variables = variables.assign({\n          value: sourcePart?.computedValue()\n        });\n      }\n\n      if (term === FunctionInvocation) {\n\n        const [\n          name,\n          ...args\n        ] = variables.children;\n\n        // preserve type information through `get value(context, key)` utility\n        if (name?.raw === 'get value') {\n          variables = getContextValue(variables, args);\n        }\n      }\n\n      const start = contextStarts[term];\n\n      if (start) {\n        return variables.enterScope(start);\n      }\n\n      const prefixedStart = prefixedContextStarts[term];\n\n      // pull <expression> into new <prefixedStart> context\n      if (prefixedStart) {\n\n        const {\n          children: currentChildren,\n          context: currentContext,\n        } = variables;\n\n        const children = currentChildren.slice(0, -1);\n        const lastChild = last(currentChildren);\n\n        let newContext = null;\n\n        if (term === pathExpressionStart) {\n          newContext = Context.of(lastChild?.computedValue());\n        }\n\n        if (term === filterExpressionStart) {\n          newContext = Context.of(\n            currentContext,\n            lastChild?.computedValue()\n          ).set('item', lastChild?.computedValue());\n        }\n\n        return variables\n          .assign({ children })\n          .enterScope(prefixedStart)\n          .pushChild(lastChild)\n          .assign({ context: newContext || currentContext });\n      }\n\n      // @ts-expect-error internal method\n      const code = input.read(input.pos, stack.pos);\n\n      const end = contextEnds[term];\n\n      if (end) {\n        return variables.exitScope(code);\n      }\n\n      if (term === ContextEntry) {\n        const parts = variables.children.filter(c => c.name !== 'ContextEntry');\n\n        const name = parts[0];\n        const value = last(parts);\n\n        return wrap(variables, 'ContextEntry', code).assign(\n          {\n            value: Context\n              .of(variables.value)\n              .set(name?.computedValue(), value?.computedValue())\n          }\n        );\n      }\n\n      if (\n        term === ForInExpression ||\n        term === QuantifiedInExpression\n      ) {\n        return wrap(variables, 'InExpression', code);\n      }\n\n      // define <partial> within ForExpression body\n      if (term === forExpressionBodyStart) {\n\n        return variables.define(\n          'partial',\n          ValueProducer.of(variables => {\n            return last(variables.children)?.computedValue();\n          })\n        );\n      }\n\n      if (\n        term === ParameterName\n      ) {\n        const name = last(variables.children).computedValue();\n\n        // TODO: attach type information\n        return variables.define(name, 1);\n      }\n\n      // pull <expression> into ArithmeticExpression child\n      if (\n        term === arithmeticPlusStart ||\n        term === arithmeticTimesStart ||\n        term === arithmeticExpStart\n      ) {\n        const children = variables.children.slice(0, -1);\n        const lastChild = last(variables.children);\n\n        return variables.assign({\n          children\n        }).enterScope('ArithmeticExpression').pushChild(lastChild);\n      }\n\n      if (term === arithmeticUnaryStart) {\n        return variables.enterScope('ArithmeticExpression');\n      }\n\n      if (\n        term === Identifier ||\n        term === AdditionalIdentifier ||\n        term === PropertyIdentifier\n      ) {\n        return variables.token(code);\n      }\n\n      if (\n        term === StringLiteral\n      ) {\n        return variables.literal(code.replace(/^\"|\"$/g, ''));\n      }\n\n      if (term === BooleanLiteral) {\n        return variables.literal(code === 'true' ? true : false);\n      }\n\n      if (term === NumericLiteral) {\n        return variables.literal(parseFloat(code));\n      }\n\n      if (term === nil) {\n        return variables.literal(null);\n      }\n\n      if (\n        term === VariableName\n      ) {\n        return variables.resolveName();\n      }\n\n      if (\n        term === Name ||\n        term === PropertyName\n      ) {\n        return variables.declareName();\n      }\n\n      if (\n        term === expression0 ||\n        term === PositiveUnaryTest\n      ) {\n        if (variables.tokens.length > 0) {\n          throw new Error('uncleared name');\n        }\n      }\n\n      if (term === expression0) {\n\n        let parent = variables;\n\n        while (parent.parent) {\n          parent = parent.exitScope(code);\n        }\n\n        return parent;\n      }\n\n      return variables;\n    }\n  });\n}\n\nexport const variableTracker = trackVariables({});\n\n\n// helpers //////////////\n\nfunction getContextValue(variables, args) {\n\n  if (!args.length) {\n    return variables.assign({\n      value: null\n    });\n  }\n\n  if (args[0].name === 'Name') {\n    args = extractNamedArgs(args, [ 'm', 'key' ]);\n  }\n\n  if (args.length !== 2) {\n    return variables.assign({\n      value: null\n    });\n  }\n\n  const [\n    context,\n    key\n  ] = args;\n\n  const keyValue = key?.computedValue();\n  const contextValue = context?.computedValue();\n\n  if (\n    (!contextValue || typeof contextValue !== 'object') || typeof keyValue !== 'string'\n  ) {\n    return variables.assign({\n      value: null\n    });\n  }\n\n  return variables.assign({\n    value: [ normalizeContextKey(keyValue), keyValue ].reduce((value, keyValue) => {\n      return contextValue.get(keyValue) || value;\n    }, null)\n  });\n}\n\nfunction extractNamedArgs(args, argNames) {\n\n  const context = {};\n\n  for (let i = 0; i < args.length; i += 2) {\n    const [ name, value ] = args.slice(i, i + 2);\n\n    context[name.value] = value;\n  }\n\n  return argNames.map(name => context[name]);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}","import { styleTags, tags as t } from '@lezer/highlight';\n\nexport const feelHighlighting = styleTags({\n  StringLiteral: t.string,\n  NumericLiteral: t.number,\n  BooleanLiteral: t.bool,\n  'AtLiteral!': t.special(t.string),\n  CompareOp: t.compareOperator,\n  ArithOp: t.arithmeticOperator,\n  'for if then else some every satisfies between return': t.controlKeyword,\n  'in instance of and or': t.operatorKeyword,\n  function: t.definitionKeyword,\n  as: t.keyword,\n  'Type/...': t.typeName,\n  Wildcard: t.special(t.variableName),\n  null: t.null,\n  LineComment: t.lineComment,\n  BlockComment: t.blockComment,\n  'VariableName! \"?\"': t.variableName,\n  'DateTimeConstructor! SpecialFunctionName!': t.function(t.special(t.variableName)),\n  'List Interval': t.list,\n  Context: t.definition(t.literal),\n  'Name!': t.definition(t.variableName),\n  'Key/Name! ContextEntryType/Name!': t.definition(t.propertyName),\n  'PathExpression/VariableName!': t.function(t.propertyName),\n  'FormalParameter/ParameterName!': t.function(t.definition(t.variableName)),\n  '( )': t.paren,\n  '[ ]': t.squareBracket,\n  '{ }': t.brace,\n  '.': t.derefOperator,\n  ', ;': t.separator,\n  '..': t.punctuation\n});","// This file was generated by lezer-generator. You probably shouldn't edit it.\nimport {LRParser} from \"@lezer/lr\"\nimport {propertyIdentifiers, identifiers, insertSemicolon, variableTracker} from \"./tokens.js\"\nimport {feelHighlighting} from \"./highlight.js\"\nconst spec_identifier = {__proto__:null,for:10, in:32, return:36, if:40, then:42, else:44, some:48, every:50, satisfies:56, or:60, and:64, between:72, instance:86, of:89, days:99, time:101, duration:103, years:105, months:107, date:109, list:115, context:121, function:128, null:154, true:326, false:326, \"?\":168, external:184, not:209}\nexport const parser = LRParser.deserialize({\n  version: 14,\n  states: \"CpO`QYOOO`QYOOO$gQYOOOOQU'#Ce'#CeO$qQYO'#C`O%zQYO'#FPOOQQ'#Fe'#FeO&UQYO'#FeO`QYO'#DVOOQU'#Em'#EmO'rQ^O'#D]OOQO'#Fl'#FlO)oQWO'#DuOOQQ'#D|'#D|OOQQ'#D}'#D}OOQQ'#EO'#EOO)tOWO'#ERO)oQWO'#EPOOQQ'#EP'#EPOOQQ'#Fr'#FrOOQQ'#Fp'#FpOOQQ'#Fw'#FwOOQQ'#ET'#ETO`QYO'#EVOOQQ'#FR'#FRO)yQ^O'#FRO+pQYO'#EWO+wQWO'#EXOOQP'#F{'#F{O+|QXO'#E`OOQQ'#Fx'#FxOOQQ'#FQ'#FQQOQWOOOOQQ'#FS'#FSOOQQ'#F]'#F]O`QYO'#CoOOQQ'#F^'#F^O$qQYO'#CsO,XQYO'#DvOOQQ'#Fq'#FqO,^QYO'#EQOOQO'#EQ'#EQO`QYO'#EUO`QYO'#ETOOQO'#Fy'#FyQ,fQWOOO,kQYO'#DRO-bQWO'#FaOOQO'#DT'#DTO-mQYO'#FeO-tQWOOO.kQYO'#CdO.xQYO'#FUOOQQ'#Cc'#CcO.}QYO'#FTOOQQ'#Cb'#CbO/VQYO,58zO`QYO,59iOOQQ'#Fb'#FbOOQQ'#Fc'#FcOOQQ'#Fd'#FdO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fj'#FjO$qQYO,5:]OOQQ'#Fk'#FkO`QYO,5:_O`QYO,59eO`QYO,59gO`QYO,59iO0uQYO,59iO0|QYO,59rOOQQ,5:h,5:hO1RQYO,59qOOQU-E8k-E8kO2uQYO'#FmOOQQ,5:a,5:aOOQQ,5:m,5:mOOQQ,5:k,5:kO2|QYO,5:qOOQQ,5;m,5;mO3WQYO,5:pO3eQWO,5:rO3jQYO,5:sOOQP'#Ed'#EdO4aQXO'#EcOOQO'#Eb'#EbO4hQWO'#EaO4mQWO'#F|O4uQWO,5:zO4zQYO,59ZO.xQYO'#F`OOQQ'#Cw'#CwO5RQYO'#F_OOQQ'#Cv'#CvO5ZQYO,59_O5`QYO,5:bO5eQYO,5:lO3PQYO,5:pO5jQYO,5:oO`QYO'#EvQ,fQWOOO`QYO'#ElO6aQWO,5;{O`QYOOOOQR'#Cf'#CfOOQQ'#Ei'#EiO7ZQYO,59OO`QYO,5;pOOQQ'#FX'#FXO$qQYO'#EjO7kQYO,5;oO`QYO1G.fOOQQ'#F['#F[O8bQYO1G/TO;XQYO1G/]O;cQYO1G/]O;mQYO1G/]OOQQ1G/w1G/wO=aQYO1G/yO=hQYO1G/PO>qQYO1G/RO?zQYO1G/TO`QYO1G/TOOQQ1G/T1G/TO@bQYO1G/^O@|Q^O'#CdOB`QYO'#FoOOQO'#Dy'#DyOBjQWO'#DxOBoQWO'#FnOOQO'#Dw'#DwOOQO'#Dz'#DzOBwQWO,5<XOOQQ1G0]1G0]O`QYO1G0[O`QYO'#ErOB|QWO,5<ZOOQQ1G0^1G0^OCXQWO'#EZOCdQWO'#FzOOQO'#EY'#EYOClQWO1G0_OOQP'#Et'#EtOCqQXO,5:}O`QYO,5:{OCxQXO'#EuODQQWO,5<hOOQQ1G0f1G0fO`QYO1G.uO`QYO,5;zO$qQYO'#EkODYQYO,5;yO`QYO1G.yODbQYO1G/|OOQO1G0W1G0WOOQO,5;b,5;bOOQO-E8t-E8tOOQO,5;W,5;WOOQO-E8j-E8jODgQWOOOOQQ-E8g-E8gODlQYO'#CmOOQQ1G1[1G1[OOQQ,5;U,5;UOOQQ-E8h-E8hODyQYO7+$QOOQQ7+%e7+%eO`QYO7+$oOEpQYO,5:qOE}QWO7+$oOFSQYO'#D[OOQQ'#DZ'#DZOGvQYO'#D^OG{QYO'#D^OHQQYO'#D^OHVQ`O'#DfOH[Q`O'#DiOHaQ`O'#DmOOQQ7+$x7+$xO`QYO,5:dO$qQYO'#EqOHfQWO,5<YOOQQ1G1s1G1sOIlQYO7+%vOIyQYO,5;^OOQO-E8p-E8pO@bQYO,5:uO$qQYO'#EsOJWQWO,5<fOJ`QYO7+%yOOQP-E8r-E8rOJgQYO1G0gOOQO,5;a,5;aOOQO-E8s-E8sOJqQYO7+$aOJxQYO1G1fOOQQ,5;V,5;VOOQQ-E8i-E8iOKSQYO7+$eOOQO7+%h7+%hO`QYO,59XOKyQYO<<HZOOQQ<<HZ<<HZO$qQYO'#EnOMSQYO,59vONvQYO,59xON{QYO,59xO! QQYO,59xO! VQYO,5:QO$qQYO,5:TO! qQbO,5:XO! xQYO1G0OOOQO,5;],5;]OOQO-E8o-E8oO!!SQYO<<IbOOQQ<<Ib<<IbOOQO1G0a1G0aOOQO,5;_,5;_OOQO-E8q-E8qO!%OQYO'#E]OOQQ<<Ie<<IeO`QYO<<IeO`QYO<<G{O!%uQYO1G.sOOQQ,5;Y,5;YOOQQ-E8l-E8lO!&PQYO1G/dOOQQ1G/d1G/dO!&UQbO'#D]O!&gQ`O'#D[O!&rQ`O1G/lO!&wQWO'#DlO!&|Q`O'#FfOOQO'#Dk'#DkO!'UQ`O1G/oOOQO'#Dp'#DpO!'ZQ`O'#FhOOQO'#Do'#DoO!'cQ`O1G/sOOQQAN?PAN?PO!'hQYOAN=gOOQQ7+%O7+%OO!(_Q`O,59vOOQQ7+%W7+%WO! VQYO,5:WO$qQYO'#EoO!(jQ`O,5<QOOQQ7+%Z7+%ZO! VQYO'#EpO!(rQ`O,5<SO!(zQ`O7+%_OOQO1G/r1G/rOOQO,5;Z,5;ZOOQO-E8m-E8mOOQO,5;[,5;[OOQO-E8n-E8nO@bQYO<<HyOOQQAN>eAN>eO$qQYO'#EnO! VQYO<<HyO!)PQ`O7+%_O!)UQ`O1G/sO! qQbO,5:XO!)ZQ`O'#Dm\",\n  stateData: \"!)h~O#qOS#rOSPOSQOS~OTqOZVO[UOdrOhtOitOs{OvgO!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~OTqO[UOdrOhtOitOs{OvgO!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~OZ!RO#[!SO~P!|O#mRO#nRO~OZ![O[![O]!]O^!]O_!^O`!iOn!fOp!gOr!ZOs!ZOt!hO{!jO!h!dO#y!bOv$`X~O#k#sX$q#sX~P$yO$g!kOT$XXZ$XX[$XXd$XXh$XXi$XXs$XXv$XX!S$XX!T$XX!U$XX!W$XX!b$XX!f$XX!h$XX!o$XX!v$XX#R$XX#m$XX#n$XX$h$XX$i$XX$j$XX~O#mRO#nROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!h!PX#k!PX#o!PX#y!PX$q!PX#}!PXx!PX#|!PX!f!PXe!PXb!PX#Q!PXf!PXl!PX~Ov!nO~O$h^O~O#o!sOZ#uX[#uX]#uX^#uX_#uX`#uXn#uXp#uXr#uXs#uXt#uXv#uX{#uX!h#uX#k#uX#y#uX$q#uX#}#uXx#uX#|#uX!f#uXe#uXb#uX#Q#uXf#uXl#uX~O!f$cP~P`Ov!vO~O#l!wO$h^O#Q$pP~Op#TO~Op#UOv!tX~O$q#XO~O#kuX#}uX$quXxuX#|uX!fuXeuXbuX#QuXfuXluX~P$yO#}#ZO#k$TXx$TX~O#k#ZX~P&UOv#]O~OZ#^O[#^O]#^O^#^O_#^O#mRO#nRO#y#^O#z#^O$ZWX~O`WXxWX#}WX~P-yO`#bO~O#}#cOb#wX~Ob#fO~OTqOZVO[UOdrOhtOitOs{O!SyO!TyO!UvO!WxO!b|O!fzO!heO!owO!vhO#RlO#mRO#nRO$g]O$h^O$i_O$j`O~Ov#pO~P/[O|#rO~O{!jO!h!dO#y!bOZya[ya]ya^ya_ya`yanyapyaryasyatyav$`X#kya$qya#}yaxya#|ya!fyaeyabya#Qyafyalya~Ox$cP~P`Ox#{O#|#|O~P$yO#|#|O#}#}O!f$cX~P$yO!f$PO~O#mRO#nROx$nP~OZ#^O[#^O]#^O^#^O_#^O#l!wO#y#^O#z#^O~O$Z#VX~P3uO$Z$WO~O#}$XO#Q$pX~O#Q$ZO~Oe$[O~P$yO#}$^Ol$RX~Ol$`O~O!V$aO~O!S$bO~O#k!wa$q!wa#}!wax!wa#|!wa!f!wae!wab!wa#Q!waf!wal!wa~P$yO#}#ZO#k$Tax$Ta~OZ#^O[#^O]#^O^#^O_#^O#mRO#nRO#y#^O#z#^O~O`Wa$ZWaxWa#}Wa~P6lO#}#cOb#wa~OZ![O[![O]!]O^!]O_!^O{!jO!h!dO#y!bOv$`X~O`qinqipqirqisqitqi#kqi$qqi#}qixqi#|qi!fqieqibqi#Qqifqilqi~P7sO_!^O{!jO!h!dO#y!bOZyi[yi`yinyipyiryisyityiv$`X#kyi$qyi#}yixyi#|yi!fyieyibyi#Qyifyilyi~O]!]O^!]O~P9kO]yi^yi~P9kO{!jO!h!dO#y!bOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$`X#kyi$qyi#}yixyi#|yi!fyieyibyi#Qyifyilyi~O!f$nO~P$yO`!iOp!gOr!ZOs!ZOt!hOnmi#kmi$qmi#}mixmi#|mi!fmiemibmi#Qmifmilmi~P7sO`!iOr!ZOs!ZOt!hOnoipoi#koi$qoi#}oixoi#|oi!foieoiboi#Qoifoiloi~P7sO`!iOn!fOp$oOr!ZOs!ZOt!hO~P7sO!R$tO!U$uO!W$vO!Z$wO!^$xO!b$yO#mRO#nRO~OZ#aX[#aX]#aX^#aX_#aX`#aXn#aXp#aXr#aXs#aXt#aXv#aXx#aX{#aX!h#aX#m#aX#n#aX#o#aX#y#aX#}#aX~P-yO#}#}Ox$cX~P$yO$Z${O~O#}$|Ox$bX~Ox%OO~O#}#}O!f$cax$ca~O$Z%SOx!}X#}!}X~O#}%TOx$nX~Ox%VO~O$Z#Va~P3uO#l!wO$h^O~O#}$XO#Q$pa~O#}$^Ol$Ra~O!T%aO~OxpO~O#|%bObaX#}aX~P$yO#kSq$qSq#}SqxSq#|Sq!fSqeSqbSq#QSqfSqlSq~P$yOx#{O#|#|O#}uX~P$yOx%dO~O#y%eOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!h!OX#k!OX$q!OX#}!OXx!OX#|!OX!f!OXe!OXb!OX#Q!OXf!OXl!OX~Op%gO~Op%hO~Op%iO~O![%jO~O![%kO~O![%lO~O#}$|Ox$ba~OZ![O[![O]!]O^!]O_!^O`!iOn!fOp!gOr!ZOs!ZOt!hO{!jO#y!bOv$`X~Ox%qO!f%qO!h%pO~PHnO!f#fa#}#fax#fa~P$yO#}%TOx$na~O#O%wO~P`O#Q#Ti#}#Ti~P$yOf%xO~P$yOl$Si#}$Si~P$yO#kgq$qgq#}gqxgq#|gq!fgqegqbgq#Qgqfgqlgq~P$yO`qynqypqyrqysqytqy#kqy$qqy#}qyxqy#|qy!fqyeqybqy#Qqyfqylqy~P7sO#y%eOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!h!Oa#k!Oa$q!Oa#}!Oax!Oa#|!Oa!f!Oae!Oab!Oa#Q!Oaf!Oal!Oa~O!S%|O~O!V%|O~O!S%}O~O!R$tO!U$uO!W$vO!Z$wO!^$xO!b&sO#mRO#nRO~O!X$[P~P! VOx!li#}!li~P$yOT$_XZ$_X[$_X]!xy^!xy_!xy`!xyd$_Xh$_Xi$_Xn!xyp!xyr!xys$_Xt!xyv$_X{!xy!S$_X!T$_X!U$_X!W$_X!b$_X!f$_X!h$_X!o$_X!v$_X#R$_X#k!xy#m$_X#n$_X#y!xy$g$_X$h$_X$i$_X$j$_X$q!xy#}!xyx!xy#|!xye!xyb!xy#Q!xyf!xyl!xy~O#k#PX$q#PX#}#PXx#PX#|#PX!f#PXe#PXb#PX#Q#PXf#PXl#PX~P$yObai#}ai~P$yO!T&]O~O#mRO#nRO!X!PX#y!PX#}!PX~O#y&nO!X!OX#}!OX~O!X&_O~O$Z&`O~O#}&aO!X$YX~O!X&cO~O#}&dO!X$[X~O!X&fO~O#kc!R$qc!R#}c!Rxc!R#|c!R!fc!Rec!Rbc!R#Qc!Rfc!Rlc!R~P$yO#y&nO!X!Oa#}!Oa~O#}&aO!X$Ya~O#}&dO!X$[a~O$]&lO~O$]&oO~O!X&pO~O![&rO~OQP_^$g]#y~\",\n  goto: \"Du$qPPPP$rP%k%n%t&W'qPPPPPP'zP$rPPP$rPP'}(QP$rP$rP$rPPP(WP(cP$r$rPP(l)R)^)RPPPPPPP)RPP)RP*k*n)RP*t*z$rP$rP$r+R+z+},T+zP,]-U,],].U.}P$r/v$r0o0o1h1kP1qPP0o1w1}.Q2RPP2ZP2^2e2k2q2w4S4^4d4j4p4w4}5T5ZPPPPPPPP5a5j7q8j9c9fPP9jPP9p9s:l;e;h;l;q<`=O=o>hP>kP>o?b@T@|ASAV$rA]A]PPPPBU7qB}CvCyDr!mhOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!YSQ!WSR$k#cS!US#cS#Ou$^W#u!n!v$|%TT&R%k&a#WXOPQWYgjsz{!Z!_!`!a!c!e!f!g!h!i#X#Z#]#a#e#p#r#|#}$W$[$]$`$o${%S%V%b%e%j%l%w%x&O&`&d&l&n&o&rb!TSu!v#c$^$|%T%k&aU#_!T#`#sR#s!nU#_!T#`#sT$U!x$VR$j#aR#SuQ#QuR%^$^U!PQ#]#pQ#q!iR$e#ZQpQQ$g#]R$q#pQ$z#rQ%r%SQ&Q%jU&V%l&d&rQ&g&`T&m&l&oc$s#r%S%j%l&`&d&l&o&r!liOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ#k!cU$r#r%S&lS%z%e&n]&P%j%l&`&d&o&rR&U%kQ&S%kR&h&aQ&Y%lR&q&rS&W%l&rR&j&d!mZOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR#z!nQ#w!nR%n$|S#v!n$|T$Q!v%T!mcOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!lcOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ!p`T!ym$X!maOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mbOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mfOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mnOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR$T!vQ$R!vR%s%TQ%v%VR&Z%wQ!{mR%Y$XT!zm$XS!xm$XT$U!x$VRpQS#`!T#sR$h#`Q#d!WR$l#dQ$_#QR%_$_Q#[!PR$f#[!vYOPQWgjsz{!Z!_!`!a!c!e!f!g!h!i!n#X#Z#]#a#e#p#r#|#}$W$[$]$`$o${%S%V%b%e%w%x&lS!mY&O_&O%j%l&`&d&n&o&rQ%f$rS%{%f&^R&^&PQ&b&SR&i&bQ&e&WR&k&eQ$}#wR%o$}S$O!t#tR%R$OQ%U$RR%t%UQ$V!xR%W$VQ$Y!{R%Z$YQ#Y}R$d#YQpOQ}PR$c#XUTOP#XW!OQ!i#Z#]Q!lWQ!rgQ!tjQ!}sQ#VzQ#W{Q#g!ZQ#h!_Q#i!`Q#j!aQ#l!eQ#m!fQ#n!gQ#o!hQ#t!nQ$i#aQ$m#eQ$p#pQ%P#|Q%Q#}Q%X$WQ%[$[Q%]$]Q%`$`Q%c$oQ%m${S%u%V%wQ%y%bR&[%x!moOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mSOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!XST!VS#cQ#a!UR$]#OR#e!Y!msOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!muOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR#RuT#Pu$^V!QQ#]#p!X!_T!O!r!t!}#V#W#g#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!Z!`T!O!r!t!}#V#W#g#h#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!]!aT!O!r!t!}#V#W#g#h#i#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!mWOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR&T%kT&X%l&r!a!cT!O!l!r!t!}#V#W#g#h#i#j#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!a!eT!O!l!r!t!}#V#W#g#h#i#j#l#m#n#o#t$i$m$p%P%Q%X%[%]%`%c%m%u%y&[!m[OPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xQ!o[R!qaR#x!nQ!ujR#y!n!mdOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mjOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%x!mkOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR$S!v!mmOPQWgjsz{!Z!_!`!a!e!f!g!h!i!n#X#Z#]#a#e#p#|#}$W$[$]$`$o${%V%b%w%xR!|m\",\n  nodeNames: \"âš  LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not\",\n  maxTerm: 171,\n  context: variableTracker,\n  nodeProps: [\n    [\"closedBy\", 38,\")\",70,\"]\",95,\"}\"],\n    [\"openedBy\", 40,\"(\",68,\"[\",94,\"{\"],\n    [\"group\", -5,77,78,79,80,81,\"Literal\"]\n  ],\n  propSources: [feelHighlighting],\n  skippedNodes: [0,1,2],\n  repeatNodeCount: 14,\n  tokenData: \"+l~RuXY#fYZ$ZZ[#f]^$Zpq#fqr$`rs$kwx&cxy&hyz&mz{&r{|'P|}'U}!O'Z!O!P'h!P!Q(Q!Q![){![!]*^!]!^*c!^!_*h!_!`$f!`!a*w!b!c+R!}#O+W#P#Q+]#Q#R&z#o#p+b#q#r+g$f$g#f#BY#BZ#f$IS$I_#f$I|$I}$Z$I}$JO$Z$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~#kY#q~XY#fZ[#fpq#f$f$g#f#BY#BZ#f$IS$I_#f$JT$JU#f$KV$KW#f&FU&FV#f?HT?HU#f~$`O#r~~$cP!_!`$f~$kOr~~$pW$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&]<%lO$k~%_O$h~~%bRO;'S$k;'S;=`%k;=`O$k~%pX$h~OY$kZr$krs%Ys#O$k#O#P%_#P;'S$k;'S;=`&];=`<%l$k<%lO$k~&`P;=`<%l$k~&hO#z~~&mOv~~&rOx~~&wP^~z{&z~'PO_~~'UO[~~'ZO#}~R'`PZP!`!a'cQ'hO$]Q~'mQ#y~!O!P's!Q!['x~'xO#|~~'}P$g~!Q!['x~(VQ]~z{(]!P!Q)d~(`TOz(]z{(o{;'S(];'S;=`)^<%lO(]~(rVOz(]z{(o{!P(]!P!Q)X!Q;'S(];'S;=`)^<%lO(]~)^OQ~~)aP;=`<%l(]~)iSP~OY)dZ;'S)d;'S;=`)u<%lO)d~)xP;=`<%l)d~*QQ$g~!O!P*W!Q![){~*ZP!Q!['x~*cO$Z~~*hO$q~R*oP![QsP!_!`*rP*wOsPR+OP!XQsP!_!`*r~+WO$j~~+]O!h~~+bO!f~~+gO#R~~+lO#Q~\",\n  tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],\n  topRules: {\"Expression\":[0,3],\"Expressions\":[1,101],\"UnaryTests\":[2,102]},\n  dynamicPrecedences: {\"31\":-1,\"71\":-1,\"73\":-1},\n  specialized: [{term: 121, get: (value) => spec_identifier[value] || -1}],\n  tokenPrec: 2500\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}