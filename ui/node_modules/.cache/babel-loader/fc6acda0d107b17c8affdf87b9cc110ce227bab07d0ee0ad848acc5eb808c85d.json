{"ast":null,"code":"import { DateTime, FixedOffsetZone, Duration, SystemZone, Info } from 'luxon';\nimport { normalizeContextKey, parser, trackVariables } from 'lezer-feel';\nfunction isContext(e) {\n  return Object.getPrototypeOf(e) === Object.prototype;\n}\nfunction isDateTime(obj) {\n  return DateTime.isDateTime(obj);\n}\nfunction isDuration(obj) {\n  return Duration.isDuration(obj);\n}\nfunction isArray(e) {\n  return Array.isArray(e);\n}\nfunction isBoolean(e) {\n  return typeof e === 'boolean';\n}\nfunction getType(e) {\n  if (e === null || e === undefined) {\n    return 'nil';\n  }\n  if (isBoolean(e)) {\n    return 'boolean';\n  }\n  if (isNumber(e)) {\n    return 'number';\n  }\n  if (isString(e)) {\n    return 'string';\n  }\n  if (isContext(e)) {\n    return 'context';\n  }\n  if (isArray(e)) {\n    return 'list';\n  }\n  if (isDuration(e)) {\n    return 'duration';\n  }\n  if (isDateTime(e)) {\n    if (e.year === 1900 && e.month === 1 && e.day === 1) {\n      return 'time';\n    }\n    if (e.hour === 0 && e.minute === 0 && e.second === 0 && e.millisecond === 0 && e.zone === FixedOffsetZone.utcInstance) {\n      return 'date';\n    }\n    return 'date time';\n  }\n  if (e instanceof Range) {\n    return 'range';\n  }\n  if (e instanceof FunctionWrapper) {\n    return 'function';\n  }\n  return 'literal';\n}\nfunction isType(el, type) {\n  return getType(el) === type;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction typeCast(obj, type) {\n  if (isDateTime(obj)) {\n    if (type === 'time') {\n      return obj.set({\n        year: 1900,\n        month: 1,\n        day: 1\n      });\n    }\n    if (type === 'date') {\n      return obj.setZone('utc', {\n        keepLocalTime: true\n      }).startOf('day');\n    }\n    if (type === 'date time') {\n      return obj;\n    }\n  }\n  return null;\n}\nclass Range {\n  constructor(props) {\n    Object.assign(this, props);\n  }\n}\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\nfunction equals(a, b) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (a === null && b !== null || a !== null && b === null) {\n    return false;\n  }\n  if (isArray(a) && a.length < 2) {\n    a = a[0];\n  }\n  if (isArray(b) && b.length < 2) {\n    b = b[0];\n  }\n  const aType = getType(a);\n  const bType = getType(b);\n  const temporalTypes = ['date time', 'time', 'date'];\n  if (temporalTypes.includes(aType)) {\n    if (!temporalTypes.includes(bType)) {\n      return null;\n    }\n    if (aType === 'time' && bType !== 'time') {\n      return null;\n    }\n    if (bType === 'time' && aType !== 'time') {\n      return null;\n    }\n    if (strict || a.zone === SystemZone.instance || b.zone === SystemZone.instance) {\n      return a.equals(b);\n    } else {\n      return a.toUTC().valueOf() === b.toUTC().valueOf();\n    }\n  }\n  if (aType !== bType) {\n    return null;\n  }\n  if (aType === 'nil') {\n    return true;\n  }\n  if (aType === 'list') {\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every((element, idx) => equals(element, b[idx]));\n  }\n  if (aType === 'duration') {\n    // years and months duration -> months\n    if (Math.abs(a.as('days')) > 180) {\n      return Math.trunc(a.minus(b).as('months')) === 0;\n    }\n    // days and time duration -> seconds\n    else {\n      return Math.trunc(a.minus(b).as('seconds')) === 0;\n    }\n  }\n  if (aType === 'context') {\n    const aEntries = Object.entries(a);\n    const bEntries = Object.entries(b);\n    if (aEntries.length !== bEntries.length) {\n      return false;\n    }\n    return aEntries.every(_ref => {\n      let [key, value] = _ref;\n      return key in b && equals(value, b[key]);\n    });\n  }\n  if (aType === 'range') {\n    return [[a.start, b.start], [a.end, b.end], [a['start included'], b['start included']], [a['end included'], b['end included']]].every(_ref2 => {\n      let [a, b] = _ref2;\n      return a === b;\n    });\n  }\n  if (a == b) {\n    return true;\n  }\n  return aType === bType ? false : null;\n}\nclass FunctionWrapper {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(fn, parameterNames) {\n    this.fn = fn;\n    this.parameterNames = parameterNames;\n  }\n  invoke(contextOrArgs) {\n    let params;\n    if (isArray(contextOrArgs)) {\n      params = contextOrArgs;\n      // reject\n      if (params.length > this.parameterNames.length) {\n        const lastParam = this.parameterNames[this.parameterNames.length - 1];\n        // strictly check for parameter count provided\n        // for non var-args functions\n        if (!lastParam || !lastParam.startsWith('...')) {\n          return null;\n        }\n      }\n    } else {\n      // strictly check for required parameter names,\n      // and fail on wrong parameter name\n      if (Object.keys(contextOrArgs).some(key => !this.parameterNames.includes(key) && !this.parameterNames.includes(\"...\".concat(key)))) {\n        return null;\n      }\n      params = this.parameterNames.reduce((params, name) => {\n        if (name.startsWith('...')) {\n          name = name.slice(3);\n          const value = contextOrArgs[name];\n          if (!value) {\n            return params;\n          } else {\n            // ensure that single arg provided for var args named\n            // parameter is wrapped in a list\n            return [...params, ...(isArray(value) ? value : [value])];\n          }\n        }\n        return [...params, contextOrArgs[name]];\n      }, []);\n    }\n    return this.fn.call(null, ...params);\n  }\n}\nfunction parseParameterNames(fn) {\n  if (Array.isArray(fn.$args)) {\n    return fn.$args;\n  }\n  const code = fn.toString();\n  const match = /^(?:[^(]*\\s*)?\\(([^)]+)?\\)/.exec(code);\n  if (!match) {\n    throw new Error('failed to parse params: ' + code);\n  }\n  const [_, params] = match;\n  if (!params) {\n    return [];\n  }\n  return params.split(',').map(p => p.trim());\n}\nfunction notImplemented(thing) {\n  return new Error(\"not implemented: \".concat(thing));\n}\n/**\n * Returns a name from context or undefined if it does not exist.\n *\n * @param {string} name\n * @param {Record<string, any>} context\n *\n * @return {any|undefined}\n */\nfunction getFromContext(name, context) {\n  if (['nil', 'boolean', 'number', 'string'].includes(getType(context))) {\n    return undefined;\n  }\n  if (name in context) {\n    return context[name];\n  }\n  const normalizedName = normalizeContextKey(name);\n  if (normalizedName in context) {\n    return context[normalizedName];\n  }\n  const entry = Object.entries(context).find(_ref3 => {\n    let [key] = _ref3;\n    return normalizedName === normalizeContextKey(key);\n  });\n  if (entry) {\n    return entry[1];\n  }\n  return undefined;\n}\nfunction duration(opts) {\n  if (typeof opts === 'number') {\n    return Duration.fromMillis(opts);\n  }\n  return Duration.fromISO(opts);\n}\nfunction date() {\n  let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let zone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (time) {\n    if (str) {\n      throw new Error('<str> and <time> provided');\n    }\n    return date(\"1900-01-01T\".concat(time), null);\n  }\n  if (typeof str === 'string') {\n    if (str.startsWith('-')) {\n      throw notImplemented('negative date');\n    }\n    if (!str.includes('T')) {\n      // raw dates are in UTC time zone\n      return date(str + 'T00:00:00', null, zone || FixedOffsetZone.utcInstance);\n    }\n    if (str.includes('@')) {\n      if (zone) {\n        throw new Error('<zone> already provided');\n      }\n      const [datePart, zonePart] = str.split('@');\n      return date(datePart, null, Info.normalizeZone(zonePart));\n    }\n    return DateTime.fromISO(str.toUpperCase(), {\n      setZone: true,\n      zone\n    });\n  }\n  return DateTime.now();\n}\n\n// 10.3.4 Built-in functions\nconst builtins = {\n  // 10.3.4.1 Conversion functions\n  'number': fn(function (from, groupingSeparator, decimalSeparator) {\n    // must always provide three arguments\n    if (arguments.length !== 3) {\n      return null;\n    }\n    if (groupingSeparator) {\n      from = from.split(groupingSeparator).join('');\n    }\n    if (decimalSeparator && decimalSeparator !== '.') {\n      from = from.split('.').join('#').split(decimalSeparator).join('.');\n    }\n    const number = +from;\n    if (isNaN(number)) {\n      return null;\n    }\n    return number;\n  }, ['string', 'string?', 'string?'], ['from', 'grouping separator', 'decimal separator']),\n  'string': fn(function (from) {\n    if (from === null) {\n      return null;\n    }\n    return toString(from);\n  }, ['any']),\n  // date(from) => date string\n  // date(from) => date and time\n  // date(year, month, day)\n  'date': fn(function (year, month, day, from) {\n    if (!from && !isNumber(year)) {\n      from = year;\n      year = null;\n    }\n    let d;\n    if (isString(from)) {\n      d = date(from);\n    }\n    if (isDateTime(from)) {\n      d = from;\n    }\n    if (year) {\n      d = date().setZone('utc').set({\n        year,\n        month,\n        day\n      });\n    }\n    return d && ifValid(d.setZone('utc').startOf('day')) || null;\n  }, ['any?', 'number?', 'number?', 'any?']),\n  // date and time(from) => date time string\n  // date and time(date, time)\n  'date and time': fn(function (d, time, from) {\n    let dt;\n    if (isDateTime(d) && isDateTime(time)) {\n      const dLocal = d.toLocal();\n      dt = time.set({\n        year: dLocal.year,\n        month: dLocal.month,\n        day: dLocal.day\n      });\n    }\n    if (isString(d)) {\n      from = d;\n      d = null;\n    }\n    if (isString(from)) {\n      dt = date(from, null, from.includes('@') ? null : SystemZone.instance);\n    }\n    return dt && ifValid(dt) || null;\n  }, ['any?', 'time?', 'string?'], ['date', 'time', 'from']),\n  // time(from) => time string\n  // time(from) => time, date and time\n  // time(hour, minute, second, offset?) => ...\n  'time': fn(function (hour, minute, second, offset, from) {\n    let t;\n    if (offset) {\n      throw notImplemented('time(..., offset)');\n    }\n    if (isString(hour) || isDateTime(hour)) {\n      from = hour;\n      hour = null;\n    }\n    if (isString(from)) {\n      t = date(null, from);\n    }\n    if (isDateTime(from)) {\n      t = from.set({\n        year: 1900,\n        month: 1,\n        day: 1\n      });\n    }\n    if (isNumber(hour)) {\n      // TODO: support offset = days and time duration\n      t = date().set({\n        hour,\n        minute,\n        second\n      }).set({\n        year: 1900,\n        month: 1,\n        day: 1,\n        millisecond: 0\n      });\n    }\n    return t && ifValid(t) || null;\n  }, ['any?', 'number?', 'number?', 'any?', 'any?']),\n  'duration': fn(function (from) {\n    return ifValid(duration(from));\n  }, ['string']),\n  'years and months duration': fn(function (from, to) {\n    return ifValid(to.diff(from, ['years', 'months']));\n  }, ['date', 'date']),\n  '@': fn(function (string) {\n    let t;\n    if (/^-?P/.test(string)) {\n      t = duration(string);\n    } else if (/^[\\d]{1,2}:[\\d]{1,2}:[\\d]{1,2}/.test(string)) {\n      t = date(null, string);\n    } else {\n      t = date(string);\n    }\n    return t && ifValid(t) || null;\n  }, ['string']),\n  'now': fn(function () {\n    return date();\n  }, []),\n  'today': fn(function () {\n    return date().startOf('day');\n  }, []),\n  // 10.3.4.2 Boolean function\n  'not': fn(function (bool) {\n    return isType(bool, 'boolean') ? !bool : null;\n  }, ['any']),\n  // 10.3.4.3 String functions\n  'substring': fn(function (string, start, length) {\n    const _start = start < 0 ? string.length + start : start - 1;\n    const arr = Array.from(string);\n    return (typeof length !== 'undefined' ? arr.slice(_start, _start + length) : arr.slice(_start)).join('');\n  }, ['string', 'number', 'number?'], ['string', 'start position', 'length']),\n  'string length': fn(function (string) {\n    return countSymbols(string);\n  }, ['string']),\n  'upper case': fn(function (string) {\n    return string.toUpperCase();\n  }, ['string']),\n  'lower case': fn(function (string) {\n    return string.toLowerCase();\n  }, ['string']),\n  'substring before': fn(function (string, match) {\n    const index = string.indexOf(match);\n    if (index === -1) {\n      return '';\n    }\n    return string.substring(0, index);\n  }, ['string', 'string']),\n  'substring after': fn(function (string, match) {\n    const index = string.indexOf(match);\n    if (index === -1) {\n      return '';\n    }\n    return string.substring(index + match.length);\n  }, ['string', 'string']),\n  'replace': fn(function (input, pattern, replacement, flags) {\n    return input.replace(new RegExp(pattern, 'ug' + (flags || '').replace(/[x]/g, '')), replacement.replace(/\\$0/g, '$$&'));\n  }, ['string', 'string', 'string', 'string?']),\n  'contains': fn(function (string, match) {\n    return string.includes(match);\n  }, ['string', 'string']),\n  // eslint-disable-next-line\n  'matches': fn(function (input, pattern, flags) {\n    throw notImplemented('matches');\n  }, ['string', 'string', 'string?']),\n  'starts with': fn(function (string, match) {\n    return string.startsWith(match);\n  }, ['string', 'string']),\n  'ends with': fn(function (string, match) {\n    return string.endsWith(match);\n  }, ['string', 'string']),\n  'split': fn(function (string, delimiter) {\n    return string.split(new RegExp(delimiter, 'u'));\n  }, ['string', 'string']),\n  'string join': fn(function (list, delimiter) {\n    if (list.some(e => !isString(e) && e !== null)) {\n      return null;\n    }\n    return list.filter(l => l !== null).join(delimiter || '');\n  }, ['list', 'string?']),\n  // 10.3.4.4 List functions\n  'list contains': fn(function (list, element) {\n    return list.some(el => matches(el, element));\n  }, ['list', 'any?']),\n  // list replace(list, position, newItem)\n  // list replace(list, match, newItem)\n  'list replace': fn(function (list, position, newItem, match) {\n    const matcher = position || match;\n    if (!['number', 'function'].includes(getType(matcher))) {\n      return null;\n    }\n    return listReplace(list, position || match, newItem);\n  }, ['list', 'any?', 'any', 'function?']),\n  'count': fn(function (list) {\n    return list.length;\n  }, ['list']),\n  'min': listFn(function () {\n    for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {\n      list[_key] = arguments[_key];\n    }\n    return list.reduce((min, el) => min === null ? el : Math.min(min, el), null);\n  }, 'number'),\n  'max': listFn(function () {\n    for (var _len2 = arguments.length, list = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      list[_key2] = arguments[_key2];\n    }\n    return list.reduce((max, el) => max === null ? el : Math.max(max, el), null);\n  }, 'number'),\n  'sum': listFn(function () {\n    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      list[_key3] = arguments[_key3];\n    }\n    return sum(list);\n  }, 'number'),\n  'mean': listFn(function () {\n    for (var _len4 = arguments.length, list = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      list[_key4] = arguments[_key4];\n    }\n    const s = sum(list);\n    return s === null ? s : s / list.length;\n  }, 'number'),\n  'all': listFn(function () {\n    let nonBool = false;\n    for (var _len5 = arguments.length, list = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      list[_key5] = arguments[_key5];\n    }\n    for (const o of list) {\n      if (o === false) {\n        return false;\n      }\n      if (typeof o !== 'boolean') {\n        nonBool = true;\n      }\n    }\n    return nonBool ? null : true;\n  }, 'any?'),\n  'any': listFn(function () {\n    let nonBool = false;\n    for (var _len6 = arguments.length, list = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      list[_key6] = arguments[_key6];\n    }\n    for (const o of list) {\n      if (o === true) {\n        return true;\n      }\n      if (typeof o !== 'boolean') {\n        nonBool = true;\n      }\n    }\n    return nonBool ? null : false;\n  }, 'any?'),\n  'sublist': fn(function (list, start, length) {\n    const _start = start < 0 ? list.length + start : start - 1;\n    return typeof length !== 'undefined' ? list.slice(_start, _start + length) : list.slice(_start);\n  }, ['list', 'number', 'number?']),\n  'append': fn(function (list) {\n    for (var _len7 = arguments.length, items = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      items[_key7 - 1] = arguments[_key7];\n    }\n    return list.concat(items);\n  }, ['list', 'any?']),\n  'concatenate': fn(function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    return args.reduce((result, arg) => {\n      return result.concat(arg);\n    }, []);\n  }, ['any']),\n  'insert before': fn(function (list, position, newItem) {\n    return list.slice(0, position - 1).concat([newItem], list.slice(position - 1));\n  }, ['list', 'number', 'any?']),\n  'remove': fn(function (list, position) {\n    return list.slice(0, position - 1).concat(list.slice(position));\n  }, ['list', 'number']),\n  'reverse': fn(function (list) {\n    return list.slice().reverse();\n  }, ['list']),\n  'index of': fn(function (list, match) {\n    return list.reduce(function (result, element, index) {\n      if (matches(element, match)) {\n        result.push(index + 1);\n      }\n      return result;\n    }, []);\n  }, ['list', 'any']),\n  'union': listFn(function () {\n    for (var _len9 = arguments.length, lists = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      lists[_key9] = arguments[_key9];\n    }\n    return lists.reduce((result, list) => {\n      return list.reduce((result, e) => {\n        if (!result.some(r => equals(e, r))) {\n          result.push(e);\n        }\n        return result;\n      }, result);\n    }, []);\n  }, 'list'),\n  'distinct values': fn(function (list) {\n    return list.reduce((result, e) => {\n      if (!result.some(r => equals(e, r))) {\n        result.push(e);\n      }\n      return result;\n    }, []);\n  }, ['list']),\n  'flatten': fn(function (list) {\n    return flatten(list);\n  }, ['list']),\n  'product': listFn(function () {\n    for (var _len10 = arguments.length, list = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      list[_key10] = arguments[_key10];\n    }\n    if (list.length === 0) {\n      return null;\n    }\n    return list.reduce((result, n) => {\n      return result * n;\n    }, 1);\n  }, 'number'),\n  'median': listFn(function () {\n    for (var _len11 = arguments.length, list = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      list[_key11] = arguments[_key11];\n    }\n    if (list.length === 0) {\n      return null;\n    }\n    return median(list);\n  }, 'number'),\n  'stddev': listFn(function () {\n    for (var _len12 = arguments.length, list = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      list[_key12] = arguments[_key12];\n    }\n    if (list.length < 2) {\n      return null;\n    }\n    return stddev(list);\n  }, 'number'),\n  'mode': listFn(function () {\n    for (var _len13 = arguments.length, list = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      list[_key13] = arguments[_key13];\n    }\n    return mode(list);\n  }, 'number'),\n  // 10.3.4.5 Numeric functions\n  'decimal': fn(function (n, scale) {\n    if (!scale) {\n      return round(n);\n    }\n    const offset = Math.pow(10, scale);\n    return round(n * offset) / offset;\n  }, ['number', 'number']),\n  'floor': fn(function (n) {\n    let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (scale === null) {\n      return null;\n    }\n    const adjust = Math.pow(10, scale);\n    return Math.floor(n * adjust) / adjust;\n  }, ['number', 'number?']),\n  'ceiling': fn(function (n) {\n    let scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (scale === null) {\n      return null;\n    }\n    const adjust = Math.pow(10, scale);\n    return Math.ceil(n * adjust) / adjust;\n  }, ['number', 'number?']),\n  'abs': fn(function (n) {\n    if (typeof n !== 'number') {\n      return null;\n    }\n    return Math.abs(n);\n  }, ['number']),\n  // eslint-disable-next-line\n  'round up': fn(function (n, scale) {\n    throw notImplemented('round up');\n  }, ['number', 'number']),\n  // eslint-disable-next-line\n  'round down': fn(function (n, scale) {\n    throw notImplemented('round down');\n  }, ['number', 'number']),\n  // eslint-disable-next-line\n  'round half up': fn(function (n, scale) {\n    throw notImplemented('round half up');\n  }, ['number', 'number']),\n  // eslint-disable-next-line\n  'round half down': fn(function (n, scale) {\n    throw notImplemented('round half down');\n  }, ['number', 'number']),\n  'modulo': fn(function (dividend, divisor) {\n    if (!divisor) {\n      return null;\n    }\n    const adjust = 1000000000;\n    // cf. https://dustinpfister.github.io/2017/09/02/js-whats-wrong-with-modulo/\n    //\n    // need to round here as using this custom modulo\n    // variant is prone to rounding errors\n    return Math.round((dividend % divisor + divisor) % divisor * adjust) / adjust;\n  }, ['number', 'number']),\n  'sqrt': fn(function (number) {\n    if (number < 0) {\n      return null;\n    }\n    return Math.sqrt(number);\n  }, ['number']),\n  'log': fn(function (number) {\n    if (number <= 0) {\n      return null;\n    }\n    return Math.log(number);\n  }, ['number']),\n  'exp': fn(function (number) {\n    return Math.exp(number);\n  }, ['number']),\n  'odd': fn(function (number) {\n    return Math.abs(number) % 2 === 1;\n  }, ['number']),\n  'even': fn(function (number) {\n    return Math.abs(number) % 2 === 0;\n  }, ['number']),\n  // 10.3.4.6 Date and time functions\n  'is': fn(function (value1, value2) {\n    if (typeof value1 === 'undefined' || typeof value2 === 'undefined') {\n      return false;\n    }\n    return equals(value1, value2, true);\n  }, ['any?', 'any?']),\n  // 10.3.4.7 Range Functions\n  'before': fn(function (a, b) {\n    return before(a, b);\n  }, ['any', 'any']),\n  'after': fn(function (a, b) {\n    return before(b, a);\n  }, ['any', 'any']),\n  'meets': fn(function (a, b) {\n    return meetsRange(a, b);\n  }, ['range', 'range']),\n  'met by': fn(function (a, b) {\n    return meetsRange(b, a);\n  }, ['range', 'range']),\n  'overlaps': fn(function (range1, range2) {\n    return !before(range1, range2) && !before(range2, range1);\n  }, ['range', 'range']),\n  'overlaps before': fn(function () {\n    throw notImplemented('overlaps before');\n  }, ['any?']),\n  'overlaps after': fn(function () {\n    throw notImplemented('overlaps after');\n  }, ['any?']),\n  'finishes': fn(function () {\n    throw notImplemented('finishes');\n  }, ['any?']),\n  'finished by': fn(function () {\n    throw notImplemented('finished by');\n  }, ['any?']),\n  'includes': fn(function () {\n    throw notImplemented('includes');\n  }, ['any?']),\n  'during': fn(function () {\n    throw notImplemented('during');\n  }, ['any?']),\n  'starts': fn(function () {\n    throw notImplemented('starts');\n  }, ['any?']),\n  'started by': fn(function () {\n    throw notImplemented('started by');\n  }, ['any?']),\n  'coincides': fn(function () {\n    throw notImplemented('coincides');\n  }, ['any?']),\n  // 10.3.4.8 Temporal built-in functions\n  'day of year': fn(function (date) {\n    return date.ordinal;\n  }, ['date time']),\n  'day of week': fn(function (date) {\n    return date.weekdayLong;\n  }, ['date time']),\n  'month of year': fn(function (date) {\n    return date.monthLong;\n  }, ['date time']),\n  'week of year': fn(function (date) {\n    return date.weekNumber;\n  }, ['date time']),\n  // 10.3.4.9 Sort\n  'sort': fn(function (list, precedes) {\n    return Array.from(list).sort((a, b) => precedes.invoke([a, b]) ? -1 : 1);\n  }, ['list', 'function']),\n  // 10.3.4.10 Context function\n  'get value': fn(function (m, key) {\n    return getFromContext(key, m) || null;\n  }, ['context', 'string']),\n  'get entries': fn(function (m) {\n    if (arguments.length !== 1) {\n      return null;\n    }\n    if (Array.isArray(m)) {\n      return null;\n    }\n    return Object.entries(m).map(_ref4 => {\n      let [key, value] = _ref4;\n      return {\n        key,\n        value\n      };\n    });\n  }, ['context']),\n  'context': listFn(function () {\n    for (var _len14 = arguments.length, entries = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n      entries[_key14] = arguments[_key14];\n    }\n    const context = entries.reduce((context, entry) => {\n      if (context === FALSE || !['key', 'value'].every(e => e in entry)) {\n        return FALSE;\n      }\n      const key = entry.key;\n      if (key === null) {\n        return FALSE;\n      }\n      if (key in context) {\n        return FALSE;\n      }\n      return Object.assign(Object.assign({}, context), {\n        [entry.key]: entry.value\n      });\n    }, {});\n    if (context === FALSE) {\n      return null;\n    }\n    return context;\n  }, 'context'),\n  'context merge': listFn(function () {\n    for (var _len15 = arguments.length, contexts = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      contexts[_key15] = arguments[_key15];\n    }\n    return Object.assign({}, ...contexts);\n  }, 'context'),\n  'context put': fn(function (context, keys, value, key) {\n    if (typeof keys === 'undefined' && typeof key === 'undefined') {\n      return null;\n    }\n    return contextPut(context, keys || [key], value);\n  }, ['context', 'list?', 'any', 'string?'], ['context', 'keys', 'value', 'key'])\n};\n/**\n * @param {Object} context\n * @param {string[]} keys\n * @param {any} value\n */\nfunction contextPut(context, keys, value) {\n  const [key, ...remainingKeys] = keys;\n  if (getType(key) !== 'string') {\n    return null;\n  }\n  if (getType(context) === 'nil') {\n    return null;\n  }\n  if (remainingKeys.length) {\n    value = contextPut(context[key], remainingKeys, value);\n    if (value === null) {\n      return null;\n    }\n  }\n  return Object.assign(Object.assign({}, context), {\n    [key]: value\n  });\n}\nfunction matches(a, b) {\n  return a === b;\n}\nconst FALSE = {};\nfunction createArgTester(arg) {\n  const optional = arg.endsWith('?');\n  const type = optional ? arg.substring(0, arg.length - 1) : arg;\n  return function (obj) {\n    const arr = Array.isArray(obj);\n    if (type === 'list') {\n      if (arr || optional && typeof obj === 'undefined') {\n        return obj;\n      } else {\n        // implicit conversion obj => [ obj ]\n        return obj === null ? FALSE : [obj];\n      }\n    }\n    if (type !== 'any' && arr && obj.length === 1) {\n      // implicit conversion [ obj ] => obj\n      obj = obj[0];\n    }\n    const objType = getType(obj);\n    if (type === 'any' || type === objType) {\n      return optional ? obj : typeof obj !== 'undefined' ? obj : FALSE;\n    }\n    if (objType === 'nil') {\n      return optional ? obj : FALSE;\n    }\n    return typeCast(obj, type) || FALSE;\n  };\n}\nfunction createArgsValidator(argDefinitions) {\n  const tests = argDefinitions.map(createArgTester);\n  return function (args) {\n    while (args.length < argDefinitions.length) {\n      args.push(undefined);\n    }\n    return args.reduce((result, arg, index) => {\n      if (result === false) {\n        return result;\n      }\n      const test = tests[index];\n      const conversion = test ? test(arg) : arg;\n      if (conversion === FALSE) {\n        return false;\n      }\n      result.push(conversion);\n      return result;\n    }, []);\n  };\n}\n/**\n * @param {Function} fnDefinition\n * @param {string} type\n * @param {string[]} [parameterNames]\n *\n * @return {Function}\n */\nfunction listFn(fnDefinition, type) {\n  let parameterNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const tester = createArgTester(type);\n  const wrappedFn = function () {\n    for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n      args[_key16] = arguments[_key16];\n    }\n    if (args.length === 0) {\n      return null;\n    }\n    // unwrap first arg\n    if (Array.isArray(args[0]) && args.length === 1) {\n      args = args[0];\n    }\n    if (!args.every(arg => tester(arg) !== FALSE)) {\n      return null;\n    }\n    return fnDefinition(...args);\n  };\n  wrappedFn.$args = parameterNames || parseParameterNames(fnDefinition);\n  return wrappedFn;\n}\n/**\n * @param {Function} fnDefinition\n * @param {string[]} argDefinitions\n * @param {string[]} [parameterNames]\n *\n * @return {Function}\n */\nfunction fn(fnDefinition, argDefinitions) {\n  let parameterNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const checkArgs = createArgsValidator(argDefinitions);\n  parameterNames = parameterNames || parseParameterNames(fnDefinition);\n  const wrappedFn = function () {\n    for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n      args[_key17] = arguments[_key17];\n    }\n    const convertedArgs = checkArgs(args);\n    if (!convertedArgs) {\n      return null;\n    }\n    return fnDefinition(...convertedArgs);\n  };\n  wrappedFn.$args = parameterNames;\n  return wrappedFn;\n}\n/**\n * @param {Range} a\n * @param {Range} b\n */\nfunction meetsRange(a, b) {\n  return [a.end === b.start, a['end included'] === true, b['start included'] === true].every(v => v);\n}\n/**\n * @param {Range|number} a\n * @param {Range|number} b\n */\nfunction before(a, b) {\n  if (a instanceof Range && b instanceof Range) {\n    return a.end < b.start || (!a['end included'] || !b['start included']) && a.end == b.start;\n  }\n  if (a instanceof Range) {\n    return a.end < b || !a['end included'] && a.end === b;\n  }\n  if (b instanceof Range) {\n    return b.start > a || !b['start included'] && b.start === a;\n  }\n  return a < b;\n}\nfunction sum(list) {\n  return list.reduce((sum, el) => sum === null ? el : sum + el, null);\n}\nfunction flatten(_ref5) {\n  let [x, ...xs] = _ref5;\n  return x !== undefined ? [...(Array.isArray(x) ? flatten(x) : [x]), ...flatten(xs)] : [];\n}\nfunction toKeyString(key) {\n  if (typeof key === 'string' && /\\W/.test(key)) {\n    return toString(key, true);\n  }\n  return key;\n}\nfunction toDeepString(obj) {\n  return toString(obj, true);\n}\nfunction escapeStr(str) {\n  return str.replace(/(\"|\\\\)/g, '\\\\$1');\n}\nfunction toString(obj) {\n  let wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var _a, _b, _c, _d;\n  const type = getType(obj);\n  if (type === 'nil') {\n    return 'null';\n  }\n  if (type === 'string') {\n    return wrap ? \"\\\"\".concat(escapeStr(obj), \"\\\"\") : obj;\n  }\n  if (type === 'boolean' || type === 'number') {\n    return String(obj);\n  }\n  if (type === 'list') {\n    return '[' + obj.map(toDeepString).join(', ') + ']';\n  }\n  if (type === 'context') {\n    return '{' + Object.entries(obj).map(_ref6 => {\n      let [key, value] = _ref6;\n      return toKeyString(key) + ': ' + toDeepString(value);\n    }).join(', ') + '}';\n  }\n  if (type === 'duration') {\n    return obj.shiftTo('years', 'months', 'days', 'hours', 'minutes', 'seconds').normalize().toISO();\n  }\n  if (type === 'date time') {\n    if (obj.zone === SystemZone.instance) {\n      return obj.toISO({\n        suppressMilliseconds: true,\n        includeOffset: false\n      });\n    }\n    if ((_a = obj.zone) === null || _a === void 0 ? void 0 : _a.zoneName) {\n      return obj.toISO({\n        suppressMilliseconds: true,\n        includeOffset: false\n      }) + '@' + ((_b = obj.zone) === null || _b === void 0 ? void 0 : _b.zoneName);\n    }\n    return obj.toISO({\n      suppressMilliseconds: true\n    });\n  }\n  if (type === 'date') {\n    return obj.toISODate();\n  }\n  if (type === 'range') {\n    return '<range>';\n  }\n  if (type === 'time') {\n    if (obj.zone === SystemZone.instance) {\n      return obj.toISOTime({\n        suppressMilliseconds: true,\n        includeOffset: false\n      });\n    }\n    if ((_c = obj.zone) === null || _c === void 0 ? void 0 : _c.zoneName) {\n      return obj.toISOTime({\n        suppressMilliseconds: true,\n        includeOffset: false\n      }) + '@' + ((_d = obj.zone) === null || _d === void 0 ? void 0 : _d.zoneName);\n    }\n    return obj.toISOTime({\n      suppressMilliseconds: true\n    });\n  }\n  if (type === 'function') {\n    return '<function>';\n  }\n  throw notImplemented('string(' + type + ')');\n}\nfunction countSymbols(str) {\n  // cf. https://mathiasbynens.be/notes/javascript-unicode\n  return str.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\n}\nfunction round(n) {\n  const integral = Math.trunc(n);\n  if (n - integral > .5) {\n    return integral + 1;\n  } else {\n    return integral;\n  }\n}\n// adapted from https://stackoverflow.com/a/53577159\nfunction stddev(array) {\n  const n = array.length;\n  const mean = array.reduce((a, b) => a + b) / n;\n  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / (n - 1));\n}\nfunction listReplace(list, matcher, newItem) {\n  if (isNumber(matcher)) {\n    return [...list.slice(0, matcher - 1), newItem, ...list.slice(matcher)];\n  }\n  return list.map((item, _idx) => {\n    if (matcher.invoke([item, newItem])) {\n      return newItem;\n    } else {\n      return item;\n    }\n  });\n}\nfunction median(array) {\n  const n = array.length;\n  const sorted = array.slice().sort();\n  const mid = n / 2 - 1;\n  const index = Math.ceil(mid);\n  // even\n  if (mid === index) {\n    return (sorted[index] + sorted[index + 1]) / 2;\n  }\n  // uneven\n  return sorted[index];\n}\nfunction mode(array) {\n  if (array.length < 2) {\n    return array;\n  }\n  const buckets = {};\n  for (const n of array) {\n    buckets[n] = (buckets[n] || 0) + 1;\n  }\n  const sorted = Object.entries(buckets).sort((a, b) => b[1] - a[1]);\n  return sorted.filter(s => s[1] === sorted[0][1]).map(e => +e[0]);\n}\nfunction ifValid(o) {\n  return o.isValid ? o : null;\n}\nfunction parseExpression(expression) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return parser.configure({\n    top: 'Expression',\n    contextTracker: trackVariables(context)\n  }).parse(expression);\n}\nfunction parseUnaryTests(expression) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return parser.configure({\n    top: 'UnaryTests',\n    contextTracker: trackVariables(context)\n  }).parse(expression);\n}\nclass SyntaxError extends Error {\n  constructor(message, details) {\n    super(message);\n    Object.assign(this, details);\n  }\n}\nclass Interpreter {\n  _buildExecutionTree(tree, input) {\n    const root = {\n      args: [],\n      nodeInput: input\n    };\n    const stack = [root];\n    tree.iterate({\n      enter(nodeRef) {\n        const {\n          isError,\n          isSkipped\n        } = nodeRef.type;\n        const {\n          from,\n          to\n        } = nodeRef;\n        if (isError) {\n          const {\n            from,\n            to,\n            message\n          } = lintError(nodeRef);\n          throw new SyntaxError(message, {\n            input: input.slice(from, to),\n            position: {\n              from,\n              to\n            }\n          });\n        }\n        if (isSkipped) {\n          return false;\n        }\n        const nodeInput = input.slice(from, to);\n        stack.push({\n          nodeInput,\n          args: []\n        });\n      },\n      leave(nodeRef) {\n        if (nodeRef.type.isSkipped) {\n          return;\n        }\n        const {\n          nodeInput,\n          args\n        } = stack.pop();\n        const parent = stack[stack.length - 1];\n        const expr = evalNode(nodeRef, nodeInput, args);\n        parent.args.push(expr);\n      }\n    });\n    return root.args[root.args.length - 1];\n  }\n  evaluate(expression) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const parseTree = parseExpression(expression, context);\n    const root = this._buildExecutionTree(parseTree, expression);\n    return {\n      parseTree,\n      root\n    };\n  }\n  unaryTest(expression) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const parseTree = parseUnaryTests(expression, context);\n    const root = this._buildExecutionTree(parseTree, expression);\n    return {\n      parseTree,\n      root\n    };\n  }\n}\nconst interpreter = new Interpreter();\nfunction unaryTest(expression) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const value = context['?'] || null;\n  const {\n    root\n  } = interpreter.unaryTest(expression, context);\n  // root = fn(ctx) => test(val)\n  const test = root(context);\n  return test(value);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction evaluate(expression) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    root\n  } = interpreter.evaluate(expression, context);\n  // root = Expression :: fn(ctx)\n  return root(context);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction evalNode(node, input, args) {\n  switch (node.name) {\n    case 'ArithOp':\n      return context => {\n        const nullable = function (op) {\n          let types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['number'];\n          return (a, b) => {\n            const left = a(context);\n            const right = b(context);\n            if (isArray(left)) {\n              return null;\n            }\n            if (isArray(right)) {\n              return null;\n            }\n            const leftType = getType(left);\n            const rightType = getType(right);\n            const temporal = ['date', 'time', 'date time', 'duration'];\n            if (temporal.includes(leftType)) {\n              if (!temporal.includes(rightType)) {\n                return null;\n              }\n            } else if (leftType !== rightType || !types.includes(leftType)) {\n              return null;\n            }\n            return op(left, right);\n          };\n        };\n        switch (input) {\n          case '+':\n            return nullable((a, b) => {\n              if (isType(a, 'time') && isDuration(b)) {\n                return a.plus(b).set({\n                  year: 1900,\n                  month: 1,\n                  day: 1\n                });\n              } else if (isDateTime(a) && isDateTime(b)) {\n                return null;\n              } else if (isDateTime(a) && isDuration(b)) {\n                return a.plus(b);\n              } else if (isDuration(a) && isDuration(b)) {\n                return a.plus(b);\n              }\n              return a + b;\n            }, ['string', 'number', 'date', 'time', 'duration', 'date time']);\n          case '-':\n            return nullable((a, b) => {\n              if (isType(a, 'time') && isDuration(b)) {\n                return a.minus(b).set({\n                  year: 1900,\n                  month: 1,\n                  day: 1\n                });\n              } else if (isDateTime(a) && isDateTime(b)) {\n                return a.diff(b);\n              } else if (isDateTime(a) && isDuration(b)) {\n                return a.minus(b);\n              } else if (isDuration(a) && isDuration(b)) {\n                return a.minus(b);\n              }\n              return a - b;\n            }, ['number', 'date', 'time', 'duration', 'date time']);\n          case '*':\n            return nullable((a, b) => a * b);\n          case '/':\n            return nullable((a, b) => !b ? null : a / b);\n          case '**':\n          case '^':\n            return nullable((a, b) => Math.pow(a, b));\n        }\n      };\n    case 'CompareOp':\n      return tag(() => {\n        switch (input) {\n          case '>':\n            return b => createRange(b, null, false, false);\n          case '>=':\n            return b => createRange(b, null, true, false);\n          case '<':\n            return b => createRange(null, b, false, false);\n          case '<=':\n            return b => createRange(null, b, false, true);\n          case '=':\n            return b => a => equals(a, b);\n          case '!=':\n            return b => a => !equals(a, b);\n        }\n      }, Test('boolean'));\n    case 'Wildcard':\n      return _context => true;\n    case 'null':\n      return _context => {\n        return null;\n      };\n    case 'Disjunction':\n      return tag(context => {\n        const left = args[0](context);\n        const right = args[2](context);\n        const matrix = [[true, true, true], [true, false, true], [true, null, true], [false, true, true], [false, false, false], [false, null, null], [null, true, true], [null, false, null], [null, null, null]];\n        const a = typeof left === 'boolean' ? left : null;\n        const b = typeof right === 'boolean' ? right : null;\n        return matrix.find(el => el[0] === a && el[1] === b)[2];\n      }, Test('boolean'));\n    case 'Conjunction':\n      return tag(context => {\n        const left = args[0](context);\n        const right = args[2](context);\n        const matrix = [[true, true, true], [true, false, false], [true, null, null], [false, true, false], [false, false, false], [false, null, false], [null, true, null], [null, false, false], [null, null, null]];\n        const a = typeof left === 'boolean' ? left : null;\n        const b = typeof right === 'boolean' ? right : null;\n        return matrix.find(el => el[0] === a && el[1] === b)[2];\n      }, Test('boolean'));\n    case 'Context':\n      return context => {\n        return args.slice(1, -1).reduce((obj, arg) => {\n          const [key, value] = arg(Object.assign(Object.assign({}, context), obj));\n          return Object.assign(Object.assign({}, obj), {\n            [key]: value\n          });\n        }, {});\n      };\n    case 'FunctionBody':\n      return args[0];\n    case 'FormalParameters':\n      return args;\n    case 'FormalParameter':\n      return args[0];\n    case 'ParameterName':\n      return args.join(' ');\n    case 'FunctionDefinition':\n      return context => {\n        const parameterNames = args[2];\n        const fnBody = args[4];\n        return wrapFunction(function () {\n          for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n            args[_key18] = arguments[_key18];\n          }\n          const fnContext = parameterNames.reduce((context, name, idx) => {\n            // support positional parameters\n            context[name] = args[idx];\n            return context;\n          }, Object.assign({}, context));\n          return fnBody(fnContext);\n        }, parameterNames);\n      };\n    case 'ContextEntry':\n      return context => {\n        const key = typeof args[0] === 'function' ? args[0](context) : args[0];\n        const value = args[1](context);\n        return [key, value];\n      };\n    case 'Key':\n      return args[0];\n    case 'Identifier':\n      return input;\n    case 'SpecialFunctionName':\n      return context => getBuiltin(input);\n    // preserve spaces in name, but compact multiple\n    // spaces into one (token)\n    case 'Name':\n      return input.replace(/\\s{2,}/g, ' ');\n    case 'VariableName':\n      return context => {\n        const name = args.join(' ');\n        const contextValue = getFromContext(name, context);\n        return typeof contextValue !== 'undefined' ? contextValue : getBuiltin(name) || null;\n      };\n    case 'QualifiedName':\n      return context => {\n        return args.reduce((context, arg) => arg(context), context);\n      };\n    case '?':\n      return context => getFromContext('?', context);\n    // expression\n    // expression \"..\" expression\n    case 'IterationContext':\n      return context => {\n        const a = args[0](context);\n        const b = args[1] && args[1](context);\n        return b ? createRange(a, b) : a;\n      };\n    case 'Type':\n      return args[0];\n    case 'InExpressions':\n      return context => {\n        const iterationContexts = args.map(ctx => ctx(context));\n        if (iterationContexts.some(ctx => getType(ctx) !== 'list')) {\n          return null;\n        }\n        return cartesianProduct(iterationContexts).map(ctx => {\n          if (!isArray(ctx)) {\n            ctx = [ctx];\n          }\n          return Object.assign({}, context, ...ctx);\n        });\n      };\n    // Name kw<\"in\"> Expr\n    case 'InExpression':\n      return context => {\n        return extractValue(context, args[0], args[2]);\n      };\n    case 'SpecialType':\n      throw notImplemented('SpecialType');\n    case 'InstanceOfExpression':\n      return tag(context => {\n        const a = args[0](context);\n        const b = args[3](context);\n        return a instanceof b;\n      }, Test('boolean'));\n    case 'every':\n      return tag(context => {\n        return (_contexts, _condition) => {\n          const contexts = _contexts(context);\n          if (getType(contexts) !== 'list') {\n            return contexts;\n          }\n          return contexts.every(ctx => isTruthy(_condition(ctx)));\n        };\n      }, Test('boolean'));\n    case 'some':\n      return tag(context => {\n        return (_contexts, _condition) => {\n          const contexts = _contexts(context);\n          if (getType(contexts) !== 'list') {\n            return contexts;\n          }\n          return contexts.some(ctx => isTruthy(_condition(ctx)));\n        };\n      }, Test('boolean'));\n    case 'NumericLiteral':\n      return tag(_context => input.includes('.') ? parseFloat(input) : parseInt(input), 'number');\n    case 'BooleanLiteral':\n      return tag(_context => input === 'true' ? true : false, 'boolean');\n    case 'StringLiteral':\n      return tag(_context => parseString(input), 'string');\n    case 'PositionalParameters':\n      return context => args.map(arg => arg(context));\n    case 'NamedParameter':\n      return context => {\n        const name = args[0];\n        const value = args[1](context);\n        return [name, value];\n      };\n    case 'NamedParameters':\n      return context => args.reduce((args, arg) => {\n        const [name, value] = arg(context);\n        args[name] = value;\n        return args;\n      }, {});\n    case 'DateTimeConstructor':\n      return context => {\n        return getBuiltin(input);\n      };\n    case 'DateTimeLiteral':\n      return context => {\n        // AtLiteral\n        if (args.length === 1) {\n          return args[0](context);\n        }\n        // FunctionInvocation\n        else {\n          const wrappedFn = wrapFunction(args[0](context));\n          // TODO(nikku): indicate as error\n          // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n          if (!wrappedFn) {\n            return null;\n          }\n          const contextOrArgs = args[2](context);\n          return wrappedFn.invoke(contextOrArgs);\n        }\n      };\n    case 'AtLiteral':\n      return context => {\n        const wrappedFn = wrapFunction(getBuiltin('@'));\n        // TODO(nikku): indicate as error\n        // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n        if (!wrappedFn) {\n          return null;\n        }\n        return wrappedFn.invoke([args[0](context)]);\n      };\n    case 'FunctionInvocation':\n      return context => {\n        const wrappedFn = wrapFunction(args[0](context));\n        // TODO(nikku): indicate error at node\n        // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n        if (!wrappedFn) {\n          return null;\n        }\n        const contextOrArgs = args[2](context);\n        return wrappedFn.invoke(contextOrArgs);\n      };\n    case 'IfExpression':\n      return function () {\n        const ifCondition = args[1];\n        const thenValue = args[3];\n        const elseValue = args[5];\n        const type = coalecenseTypes(thenValue, elseValue);\n        return tag(context => {\n          if (isTruthy(ifCondition(context))) {\n            return thenValue(context);\n          } else {\n            return elseValue ? elseValue(context) : null;\n          }\n        }, type);\n      }();\n    case 'Parameters':\n      return args.length === 3 ? args[1] : _context => [];\n    case 'Comparison':\n      return context => {\n        const operator = args[1];\n        // expression !compare kw<\"in\"> PositiveUnaryTest |\n        // expression !compare kw<\"in\"> !unaryTest \"(\" PositiveUnaryTests \")\"\n        if (operator === 'in') {\n          return compareIn(args[0](context), (args[3] || args[2])(context));\n        }\n        // expression !compare kw<\"between\"> expression kw<\"and\"> expression\n        if (operator === 'between') {\n          const start = args[2](context);\n          const end = args[4](context);\n          if (start === null || end === null) {\n            return null;\n          }\n          return createRange(start, end).includes(args[0](context));\n        }\n        // expression !compare CompareOp<\"=\" | \"!=\"> expression |\n        // expression !compare CompareOp<Gt | Gte | Lt | Lte> expression |\n        const left = args[0](context);\n        const right = args[2](context);\n        const test = operator()(right);\n        return compareValue(test, left);\n      };\n    case 'QuantifiedExpression':\n      return context => {\n        const testFn = args[0](context);\n        const contexts = args[1];\n        const condition = args[3];\n        return testFn(contexts, condition);\n      };\n    // DMN 1.2 - 10.3.2.14\n    // kw<\"for\"> commaSep1<InExpression<IterationContext>> kw<\"return\"> expression\n    case 'ForExpression':\n      return context => {\n        const extractor = args[args.length - 1];\n        const iterationContexts = args[1](context);\n        if (getType(iterationContexts) !== 'list') {\n          return iterationContexts;\n        }\n        const partial = [];\n        for (const ctx of iterationContexts) {\n          partial.push(extractor(Object.assign(Object.assign({}, ctx), {\n            partial\n          })));\n        }\n        return partial;\n      };\n    case 'ArithmeticExpression':\n      return function () {\n        // binary expression (a + b)\n        if (args.length === 3) {\n          const [a, op, b] = args;\n          return tag(context => {\n            return op(context)(a, b);\n          }, coalecenseTypes(a, b));\n        }\n        // unary expression (-b)\n        if (args.length === 2) {\n          const [op, value] = args;\n          return tag(context => {\n            return op(context)(() => 0, value);\n          }, value.type);\n        }\n      }();\n    case 'PositiveUnaryTest':\n      return args[0];\n    case 'ParenthesizedExpression':\n      return args[1];\n    case 'PathExpression':\n      return context => {\n        const pathTarget = args[0](context);\n        const pathProp = args[1];\n        if (isArray(pathTarget)) {\n          return pathTarget.map(pathProp);\n        } else {\n          return pathProp(pathTarget);\n        }\n      };\n    // expression !filter \"[\" expression \"]\"\n    case 'FilterExpression':\n      return context => {\n        const target = args[0](context);\n        const filterFn = args[2];\n        const filterTarget = isArray(target) ? target : [target];\n        // null[..]\n        if (target === null) {\n          return null;\n        }\n        // a[variable=number]\n        if (typeof filterFn.type === 'undefined') {\n          try {\n            const value = filterFn(context);\n            if (isNumber(value)) {\n              filterFn.type = 'number';\n            }\n          } catch (err) {\n            // ignore\n          }\n        }\n        // a[1]\n        if (filterFn.type === 'number') {\n          const idx = filterFn(context);\n          const value = filterTarget[idx < 0 ? filterTarget.length + idx : idx - 1];\n          if (typeof value === 'undefined') {\n            return null;\n          } else {\n            return value;\n          }\n        }\n        // a[true]\n        if (filterFn.type === 'boolean') {\n          if (filterFn(context)) {\n            return filterTarget;\n          } else {\n            return [];\n          }\n        }\n        if (filterFn.type === 'string') {\n          const value = filterFn(context);\n          return filterTarget.filter(el => el === value);\n        }\n        // a[test]\n        return filterTarget.map(el => {\n          const iterationContext = Object.assign(Object.assign(Object.assign({}, context), {\n            item: el\n          }), el);\n          let result = filterFn(iterationContext);\n          // test is fn(val) => boolean SimpleUnaryTest\n          if (typeof result === 'function') {\n            result = result(el);\n          }\n          if (result instanceof Range) {\n            result = result.includes(el);\n          }\n          if (result === true) {\n            return el;\n          }\n          return result;\n        }).filter(isTruthy);\n      };\n    case 'SimplePositiveUnaryTest':\n      return tag(context => {\n        // <Interval>\n        if (args.length === 1) {\n          return args[0](context);\n        }\n        // <CompareOp> <Expr>\n        return args[0](context)(args[1](context));\n      }, 'test');\n    case 'List':\n      return context => {\n        return args.slice(1, -1).map(arg => arg(context));\n      };\n    case 'Interval':\n      return tag(context => {\n        const left = args[1](context);\n        const right = args[2](context);\n        const startIncluded = left !== null && args[0] === '[';\n        const endIncluded = right !== null && args[3] === ']';\n        return createRange(left, right, startIncluded, endIncluded);\n      }, Test('boolean'));\n    case 'PositiveUnaryTests':\n    case 'Expressions':\n      return context => {\n        return args.map(a => a(context));\n      };\n    case 'Expression':\n      return context => {\n        return args[0](context);\n      };\n    case 'UnaryTests':\n      return context => {\n        return function () {\n          let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          const negate = args[0] === 'not';\n          const tests = negate ? args.slice(2, -1) : args;\n          const matches = tests.map(test => test(context)).flat(1).map(test => {\n            if (isArray(test)) {\n              return test.includes(value);\n            }\n            if (test === null) {\n              return null;\n            }\n            if (typeof test === 'boolean') {\n              return test;\n            }\n            return compareValue(test, value);\n          }).reduce(combineResult, undefined);\n          return matches === null ? null : negate ? !matches : matches;\n        };\n      };\n    default:\n      return node.name;\n  }\n}\nfunction getBuiltin(name, _context) {\n  return getFromContext(name, builtins);\n}\nfunction extractValue(context, prop, _target) {\n  const target = _target(context);\n  if (['list', 'range'].includes(getType(target))) {\n    return target.map(t => ({\n      [prop]: t\n    }));\n  }\n  return null;\n}\nfunction compareIn(value, tests) {\n  if (!isArray(tests)) {\n    if (getType(tests) === 'nil') {\n      return null;\n    }\n    tests = [tests];\n  }\n  return tests.some(test => compareValue(test, value));\n}\nfunction compareValue(test, value) {\n  if (typeof test === 'function') {\n    return test(value);\n  }\n  if (test instanceof Range) {\n    return test.includes(value);\n  }\n  return equals(test, value);\n}\nconst chars = Array.from('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\nfunction isTyped(type, values) {\n  return values.some(e => getType(e) === type) && values.every(e => e === null || getType(e) === type);\n}\nconst nullRange = new Range({\n  start: null,\n  end: null,\n  'start included': false,\n  'end included': false,\n  map() {\n    return [];\n  },\n  includes() {\n    return null;\n  }\n});\nfunction createRange(start, end) {\n  let startIncluded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let endIncluded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (isTyped('string', [start, end])) {\n    return createStringRange(start, end, startIncluded, endIncluded);\n  }\n  if (isTyped('number', [start, end])) {\n    return createNumberRange(start, end, startIncluded, endIncluded);\n  }\n  if (isTyped('duration', [start, end])) {\n    return createDurationRange(start, end, startIncluded, endIncluded);\n  }\n  if (isTyped('time', [start, end])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n  if (isTyped('date time', [start, end])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n  if (isTyped('date', [start, end])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n  if (start === null && end === null) {\n    return nullRange;\n  }\n  throw new Error(\"unsupported range: \".concat(start, \"..\").concat(end));\n}\nfunction noopMap() {\n  return () => {\n    throw new Error('unsupported range operation: map');\n  };\n}\nfunction valuesMap(values) {\n  return fn => values.map(fn);\n}\nfunction valuesIncludes(values) {\n  return value => values.includes(value);\n}\nfunction numberMap(start, end, startIncluded, endIncluded) {\n  const direction = start > end ? -1 : 1;\n  return fn => {\n    const result = [];\n    for (let i = start;; i += direction) {\n      if (i === 0 && !startIncluded) {\n        continue;\n      }\n      if (i === end && !endIncluded) {\n        break;\n      }\n      result.push(fn(i));\n      if (i === end) {\n        break;\n      }\n    }\n    return result;\n  };\n}\nfunction includesStart(n, inclusive) {\n  if (inclusive) {\n    return value => n <= value;\n  } else {\n    return value => n < value;\n  }\n}\nfunction includesEnd(n, inclusive) {\n  if (inclusive) {\n    return value => n >= value;\n  } else {\n    return value => n > value;\n  }\n}\nfunction anyIncludes(start, end, startIncluded, endIncluded) {\n  let conversion = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : v => v;\n  let tests = [];\n  if (start === null && end === null) {\n    return () => null;\n  }\n  if (start !== null && end !== null) {\n    if (start > end) {\n      tests = [includesStart(end, endIncluded), includesEnd(start, startIncluded)];\n    } else {\n      tests = [includesStart(start, startIncluded), includesEnd(end, endIncluded)];\n    }\n  } else if (end !== null) {\n    tests = [includesEnd(end, endIncluded)];\n  } else if (start !== null) {\n    tests = [includesStart(start, startIncluded)];\n  }\n  return value => value === null ? null : tests.every(t => t(conversion(value)));\n}\nfunction createStringRange(start, end) {\n  let startIncluded = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let endIncluded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (start !== null && !chars.includes(start)) {\n    throw new Error('illegal range start: ' + start);\n  }\n  if (end !== null && !chars.includes(end)) {\n    throw new Error('illegal range end: ' + end);\n  }\n  let values;\n  if (start !== null && end !== null) {\n    let startIdx = chars.indexOf(start);\n    let endIdx = chars.indexOf(end);\n    const direction = startIdx > endIdx ? -1 : 1;\n    if (startIncluded === false) {\n      startIdx += direction;\n    }\n    if (endIncluded === false) {\n      endIdx -= direction;\n    }\n    values = chars.slice(startIdx, endIdx + 1);\n  }\n  const map = values ? valuesMap(values) : noopMap();\n  const includes = values ? valuesIncludes(values) : anyIncludes(start, end, startIncluded, endIncluded);\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\nfunction createNumberRange(start, end, startIncluded, endIncluded) {\n  const map = start !== null && end !== null ? numberMap(start, end, startIncluded, endIncluded) : noopMap();\n  const includes = anyIncludes(start, end, startIncluded, endIncluded);\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\n/**\n * @param {Duration} start\n * @param {Duration} end\n * @param {boolean} startIncluded\n * @param {boolean} endIncluded\n */\nfunction createDurationRange(start, end, startIncluded, endIncluded) {\n  const toMillis = d => d ? Duration.fromDurationLike(d).toMillis() : null;\n  const map = noopMap();\n  const includes = anyIncludes(toMillis(start), toMillis(end), startIncluded, endIncluded, toMillis);\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\nfunction createDateTimeRange(start, end, startIncluded, endIncluded) {\n  const map = noopMap();\n  const includes = anyIncludes(start, end, startIncluded, endIncluded);\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction cartesianProduct(arrays) {\n  if (arrays.some(arr => getType(arr) === 'nil')) {\n    return null;\n  }\n  const f = (a, b) => [].concat(...a.map(d => b.map(e => [].concat(d, e))));\n  const cartesian = function (a, b) {\n    for (var _len19 = arguments.length, c = new Array(_len19 > 2 ? _len19 - 2 : 0), _key19 = 2; _key19 < _len19; _key19++) {\n      c[_key19 - 2] = arguments[_key19];\n    }\n    return b ? cartesian(f(a, b), ...c) : a || [];\n  };\n  return cartesian(...arrays);\n}\nfunction coalecenseTypes(a, b) {\n  if (!b) {\n    return a.type;\n  }\n  if (a.type === b.type) {\n    return a.type;\n  }\n  return 'any';\n}\nfunction tag(fn, type) {\n  return Object.assign(fn, {\n    type,\n    toString() {\n      return \"TaggedFunction[\".concat(type, \"] \").concat(Function.prototype.toString.call(fn));\n    }\n  });\n}\nfunction combineResult(result, match) {\n  if (!result) {\n    return match;\n  }\n  return result;\n}\nfunction isTruthy(obj) {\n  return obj !== false && obj !== null;\n}\nfunction Test(type) {\n  return \"Test<\".concat(type, \">\");\n}\n/**\n * @param {Function} fn\n * @param {string[]} [parameterNames]\n *\n * @return {FunctionWrapper}\n */\nfunction wrapFunction(fn) {\n  let parameterNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (!fn) {\n    return null;\n  }\n  if (fn instanceof FunctionWrapper) {\n    return fn;\n  }\n  if (fn instanceof Range) {\n    return new FunctionWrapper(value => fn.includes(value), ['value']);\n  }\n  if (typeof fn !== 'function') {\n    return null;\n  }\n  return new FunctionWrapper(fn, parameterNames || parseParameterNames(fn));\n}\nfunction parseString(str) {\n  if (str.startsWith('\"')) {\n    str = str.slice(1);\n  }\n  if (str.endsWith('\"')) {\n    str = str.slice(0, -1);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return str.replace(/(\\\\\")|(\\\\\\\\)|(\\\\u[a-fA-F0-9]{5,6})|((?:\\\\u[a-fA-F0-9]{1,4})+)/ig, function (substring) {\n    for (var _len20 = arguments.length, groups = new Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n      groups[_key20 - 1] = arguments[_key20];\n    }\n    const [quotes, escape, codePoint, charCodes] = groups;\n    if (quotes) {\n      return '\"';\n    }\n    if (escape) {\n      return '\\\\';\n    }\n    const escapePattern = /\\\\u([a-fA-F0-9]+)/ig;\n    if (codePoint) {\n      const codePointMatch = escapePattern.exec(codePoint);\n      return String.fromCodePoint(parseInt(codePointMatch[1], 16));\n    }\n    if (charCodes) {\n      const chars = [];\n      let charCodeMatch;\n      while ((charCodeMatch = escapePattern.exec(substring)) !== null) {\n        chars.push(parseInt(charCodeMatch[1], 16));\n      }\n      return String.fromCharCode(...chars);\n    }\n    throw new Error('illegal match');\n  });\n}\nfunction lintError(nodeRef) {\n  const node = nodeRef.node;\n  const parent = node.parent;\n  if (node.from !== node.to) {\n    return {\n      from: node.from,\n      to: node.to,\n      message: \"Unrecognized token in <\".concat(parent.name, \">\")\n    };\n  }\n  const next = findNext(node);\n  if (next) {\n    return {\n      from: node.from,\n      to: next.to,\n      message: \"Unrecognized token <\".concat(next.name, \"> in <\").concat(parent.name, \">\")\n    };\n  } else {\n    const unfinished = parent.enterUnfinishedNodesBefore(nodeRef.to);\n    return {\n      from: node.from,\n      to: node.to,\n      message: \"Incomplete <\".concat((unfinished || parent).name, \">\")\n    };\n  }\n}\nfunction findNext(nodeRef) {\n  const node = nodeRef.node;\n  let next,\n    parent = node;\n  do {\n    next = parent.nextSibling;\n    if (next) {\n      return next;\n    }\n    parent = parent.parent;\n  } while (parent);\n  return null;\n}\nexport { SyntaxError, date, duration, evaluate, lintError, parseExpression, parseUnaryTests, unaryTest };","map":{"version":3,"names":["isContext","e","Object","getPrototypeOf","prototype","isDateTime","obj","DateTime","isDuration","Duration","isArray","Array","isBoolean","getType","undefined","isNumber","isString","year","month","day","hour","minute","second","millisecond","zone","FixedOffsetZone","utcInstance","Range","FunctionWrapper","isType","el","type","typeCast","set","setZone","keepLocalTime","startOf","constructor","props","assign","equals","a","b","strict","arguments","length","aType","bType","temporalTypes","includes","SystemZone","instance","toUTC","valueOf","every","element","idx","Math","abs","as","trunc","minus","aEntries","entries","bEntries","_ref","key","value","start","end","_ref2","fn","parameterNames","invoke","contextOrArgs","params","lastParam","startsWith","keys","some","concat","reduce","name","slice","call","parseParameterNames","$args","code","toString","match","exec","Error","_","split","map","p","trim","notImplemented","thing","getFromContext","context","normalizedName","normalizeContextKey","entry","find","_ref3","duration","opts","fromMillis","fromISO","date","str","time","datePart","zonePart","Info","normalizeZone","toUpperCase","now","builtins","from","groupingSeparator","decimalSeparator","join","number","isNaN","d","ifValid","dt","dLocal","toLocal","offset","t","to","diff","string","test","bool","_start","arr","countSymbols","toLowerCase","index","indexOf","substring","input","pattern","replacement","flags","replace","RegExp","endsWith","delimiter","list","filter","l","matches","position","newItem","matcher","listReplace","listFn","_len","_key","min","_len2","_key2","max","_len3","_key3","sum","_len4","_key4","s","nonBool","_len5","_key5","o","_len6","_key6","_len7","items","_key7","_len8","args","_key8","result","arg","reverse","push","_len9","lists","_key9","r","flatten","_len10","_key10","n","_len11","_key11","median","_len12","_key12","stddev","_len13","_key13","mode","scale","round","pow","adjust","floor","ceil","dividend","divisor","sqrt","log","exp","value1","value2","before","meetsRange","range1","range2","ordinal","weekdayLong","monthLong","weekNumber","precedes","sort","m","_ref4","_len14","_key14","FALSE","_len15","contexts","_key15","contextPut","remainingKeys","createArgTester","optional","objType","createArgsValidator","argDefinitions","tests","conversion","fnDefinition","tester","wrappedFn","_len16","_key16","checkArgs","_len17","_key17","convertedArgs","v","_ref5","x","xs","toKeyString","toDeepString","escapeStr","wrap","String","_ref6","shiftTo","normalize","toISO","suppressMilliseconds","includeOffset","_a","zoneName","_b","toISODate","toISOTime","_c","_d","integral","array","mean","item","_idx","sorted","mid","buckets","isValid","parseExpression","expression","parser","configure","top","contextTracker","trackVariables","parse","parseUnaryTests","SyntaxError","message","details","Interpreter","_buildExecutionTree","tree","root","nodeInput","stack","iterate","enter","nodeRef","isError","isSkipped","lintError","leave","pop","parent","expr","evalNode","evaluate","parseTree","unaryTest","interpreter","node","nullable","op","types","left","right","leftType","rightType","temporal","plus","tag","createRange","Test","_context","matrix","fnBody","wrapFunction","_len18","_key18","fnContext","getBuiltin","contextValue","iterationContexts","ctx","cartesianProduct","extractValue","_contexts","_condition","isTruthy","parseFloat","parseInt","parseString","ifCondition","thenValue","elseValue","coalecenseTypes","operator","compareIn","compareValue","testFn","condition","extractor","partial","pathTarget","pathProp","target","filterFn","filterTarget","err","iterationContext","startIncluded","endIncluded","negate","flat","combineResult","prop","_target","chars","isTyped","values","nullRange","createStringRange","createNumberRange","createDurationRange","createDateTimeRange","noopMap","valuesMap","valuesIncludes","numberMap","direction","i","includesStart","inclusive","includesEnd","anyIncludes","startIdx","endIdx","toMillis","fromDurationLike","arrays","f","cartesian","_len19","c","_key19","Function","_len20","groups","_key20","quotes","escape","codePoint","charCodes","escapePattern","codePointMatch","fromCodePoint","charCodeMatch","fromCharCode","next","findNext","unfinished","enterUnfinishedNodesBefore","nextSibling"],"sources":["/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/types.ts","/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/utils.ts","/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/temporal.ts","/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/builtins.ts","/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/parser.ts","/Users/Shivaji/Workspace/Play/cta/node_modules/feelin/src/interpreter.ts"],"sourcesContent":["import {\n  DateTime,\n  Duration,\n  FixedOffsetZone,\n  SystemZone\n} from 'luxon';\n\nexport function isContext(e) {\n  return Object.getPrototypeOf(e) === Object.prototype;\n}\n\nexport function isDateTime(obj): obj is DateTime {\n  return DateTime.isDateTime(obj);\n}\n\nexport function isDuration(obj): obj is Duration {\n  return Duration.isDuration(obj);\n}\n\nexport function isArray(e) {\n  return Array.isArray(e);\n}\n\nexport function isBoolean(e) {\n  return typeof e === 'boolean';\n}\n\nexport function getType(e) {\n\n  if (e === null || e === undefined) {\n    return 'nil';\n  }\n\n  if (isBoolean(e)) {\n    return 'boolean';\n  }\n\n  if (isNumber(e)) {\n    return 'number';\n  }\n\n  if (isString(e)) {\n    return 'string';\n  }\n\n  if (isContext(e)) {\n    return 'context';\n  }\n\n  if (isArray(e)) {\n    return 'list';\n  }\n\n  if (isDuration(e)) {\n    return 'duration';\n  }\n\n  if (isDateTime(e)) {\n    if (\n      e.year === 1900 &&\n      e.month === 1 &&\n      e.day === 1\n    ) {\n      return 'time';\n    }\n\n    if (\n      e.hour === 0 &&\n      e.minute === 0 &&\n      e.second === 0 &&\n      e.millisecond === 0 &&\n      e.zone === FixedOffsetZone.utcInstance\n    ) {\n      return 'date';\n    }\n\n    return 'date time';\n  }\n\n  if (e instanceof Range) {\n    return 'range';\n  }\n\n  if (e instanceof FunctionWrapper) {\n    return 'function';\n  }\n\n  return 'literal';\n}\n\nexport function isType(el: string, type: string): boolean {\n  return getType(el) === type;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function typeCast(obj: any, type: string) {\n\n  if (isDateTime(obj)) {\n\n    if (type === 'time') {\n      return obj.set({\n        year: 1900,\n        month: 1,\n        day: 1\n      });\n    }\n\n    if (type === 'date') {\n      return obj.setZone('utc', { keepLocalTime: true }).startOf('day');\n    }\n\n    if (type === 'date time') {\n      return obj;\n    }\n  }\n\n  return null;\n}\n\nexport type RangeProps = {\n  'start included': boolean;\n  'end included': boolean;\n  start: string|number|null;\n  end: string|number|null;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  map: <T> (fn: (val: any) => T) => T[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  includes: (val: any) => boolean;\n};\n\nexport class Range {\n\n  'start included': boolean;\n  'end included': boolean;\n  start: string|number|null;\n  end: string|number|null;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  map: <T> (fn: (val) => T) => T[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  includes: (val) => boolean;\n\n  constructor(props: RangeProps) {\n    Object.assign(this, props);\n  }\n}\n\nexport function isNumber(obj) : obj is number {\n  return typeof obj === 'number';\n}\n\nexport function isString(obj) : obj is string {\n  return typeof obj === 'string';\n}\n\nexport function equals(a, b, strict = false) {\n  if (\n    a === null && b !== null ||\n    a !== null && b === null\n  ) {\n    return false;\n  }\n\n  if (isArray(a) && a.length < 2) {\n    a = a[0];\n  }\n\n  if (isArray(b) && b.length < 2) {\n    b = b[0];\n  }\n\n  const aType = getType(a);\n  const bType = getType(b);\n\n  const temporalTypes = [ 'date time', 'time', 'date' ];\n\n  if (temporalTypes.includes(aType)) {\n\n    if (!temporalTypes.includes(bType)) {\n      return null;\n    }\n\n    if (aType === 'time' && bType !== 'time') {\n      return null;\n    }\n\n    if (bType === 'time' && aType !== 'time') {\n      return null;\n    }\n\n    if (strict || a.zone === SystemZone.instance || b.zone === SystemZone.instance) {\n      return a.equals(b);\n    } else {\n      return a.toUTC().valueOf() === b.toUTC().valueOf();\n    }\n  }\n\n  if (aType !== bType) {\n    return null;\n  }\n\n  if (aType === 'nil') {\n    return true;\n  }\n\n  if (aType === 'list') {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return a.every(\n      (element, idx) => equals(element, b[idx])\n    );\n  }\n\n  if (aType === 'duration') {\n\n    // years and months duration -> months\n    if (Math.abs(a.as('days')) > 180) {\n      return Math.trunc(a.minus(b).as('months')) === 0;\n    }\n\n    // days and time duration -> seconds\n    else {\n      return Math.trunc(a.minus(b).as('seconds')) === 0;\n    }\n\n  }\n\n  if (aType === 'context') {\n\n    const aEntries = Object.entries(a);\n    const bEntries = Object.entries(b);\n\n    if (aEntries.length !== bEntries.length) {\n      return false;\n    }\n\n    return aEntries.every(\n      ([ key, value ]) => key in b && equals(value, b[key])\n    );\n  }\n\n  if (aType === 'range') {\n    return [\n      [ a.start, b.start ],\n      [ a.end, b.end ],\n      [ a['start included'], b['start included'] ],\n      [ a['end included'], b['end included'] ]\n    ].every(([ a, b ]) => a === b);\n  }\n\n  if (a == b) {\n    return true;\n  }\n\n  return aType === bType ? false : null;\n}\n\nexport class FunctionWrapper {\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fn: (...args) => any;\n  parameterNames: string[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(fn: (...args) => any, parameterNames: string[]) {\n\n    this.fn = fn;\n    this.parameterNames = parameterNames;\n  }\n\n  invoke(contextOrArgs) {\n\n    let params;\n\n    if (isArray(contextOrArgs)) {\n      params = contextOrArgs;\n\n      // reject\n      if (params.length > this.parameterNames.length) {\n\n        const lastParam = this.parameterNames[this.parameterNames.length - 1];\n\n        // strictly check for parameter count provided\n        // for non var-args functions\n        if (!lastParam || !lastParam.startsWith('...')) {\n          return null;\n        }\n      }\n    } else {\n\n      // strictly check for required parameter names,\n      // and fail on wrong parameter name\n      if (Object.keys(contextOrArgs).some(\n        key => !this.parameterNames.includes(key) && !this.parameterNames.includes(`...${key}`)\n      )) {\n        return null;\n      }\n\n      params = this.parameterNames.reduce((params, name) => {\n\n        if (name.startsWith('...')) {\n          name = name.slice(3);\n\n          const value = contextOrArgs[name];\n\n          if (!value) {\n            return params;\n          } else {\n\n            // ensure that single arg provided for var args named\n            // parameter is wrapped in a list\n            return [ ...params, ...(isArray(value) ? value : [ value ]) ];\n          }\n        }\n\n        return [ ...params, contextOrArgs[name] ];\n      }, []);\n    }\n\n    return this.fn.call(null, ...params);\n  }\n}","import { normalizeContextKey } from 'lezer-feel';\n\nimport { getType } from './types';\n\n\nexport function parseParameterNames(fn) {\n\n  if (Array.isArray(fn.$args)) {\n    return fn.$args;\n  }\n\n  const code = fn.toString();\n\n  const match = /^(?:[^(]*\\s*)?\\(([^)]+)?\\)/.exec(code);\n\n  if (!match) {\n    throw new Error('failed to parse params: ' + code);\n  }\n\n  const [ _, params ] = match;\n\n  if (!params) {\n    return [];\n  }\n\n  return params.split(',').map(p => p.trim());\n}\n\nexport function notImplemented(thing) {\n  return new Error(`not implemented: ${thing}`);\n}\n\n/**\n * Returns a name from context or undefined if it does not exist.\n *\n * @param {string} name\n * @param {Record<string, any>} context\n *\n * @return {any|undefined}\n */\nexport function getFromContext(name, context) {\n\n  if ([ 'nil', 'boolean', 'number', 'string' ].includes(getType(context))) {\n    return undefined;\n  }\n\n  if (name in context) {\n    return context[name];\n  }\n\n  const normalizedName = normalizeContextKey(name);\n\n  if (normalizedName in context) {\n    return context[normalizedName];\n  }\n\n  const entry = Object.entries(context).find(\n    ([ key ]) => normalizedName === normalizeContextKey(key)\n  );\n\n  if (entry) {\n    return entry[1];\n  }\n\n  return undefined;\n}\n","import {\n  DateTime,\n  Duration,\n  FixedOffsetZone,\n  Info,\n  Zone\n} from 'luxon';\n\nimport { isDateTime, isDuration } from './types';\n\nexport {\n  isDateTime,\n  isDuration\n};\n\nimport { notImplemented } from './utils';\n\n\nexport function ms(temporal) {\n\n  if (isDateTime(temporal)) {\n    return temporal.valueOf();\n  }\n\n  if (isDuration(temporal)) {\n    return temporal.valueOf();\n  }\n\n  return null;\n}\n\nexport function duration(opts: string|number) : Duration {\n\n  if (typeof opts === 'number') {\n    return Duration.fromMillis(opts);\n  }\n\n  return Duration.fromISO(opts);\n}\n\nexport function date(str: string = null, time: string = null, zone: Zone = null) : DateTime {\n\n  if (time) {\n    if (str) {\n      throw new Error('<str> and <time> provided');\n    }\n\n    return date(`1900-01-01T${ time }`, null);\n  }\n\n  if (typeof str === 'string') {\n\n    if (str.startsWith('-')) {\n      throw notImplemented('negative date');\n    }\n\n    if (!str.includes('T')) {\n\n      // raw dates are in UTC time zone\n      return date(str + 'T00:00:00', null, zone || FixedOffsetZone.utcInstance);\n    }\n\n    if (str.includes('@')) {\n\n      if (zone) {\n        throw new Error('<zone> already provided');\n      }\n\n      const [ datePart, zonePart ] = str.split('@');\n\n      return date(datePart, null, Info.normalizeZone(zonePart));\n    }\n\n    return DateTime.fromISO(str.toUpperCase(), {\n      setZone: true,\n      zone\n    });\n  }\n\n  return DateTime.now();\n}","import {\n  isType,\n  equals,\n  Range,\n  isString,\n  isNumber,\n  getType,\n  typeCast\n} from './types';\n\nimport {\n  getFromContext,\n  notImplemented,\n  parseParameterNames\n} from './utils';\n\nimport {\n  duration,\n  date,\n  isDateTime\n} from './temporal';\n\nimport { DateTime, Duration, SystemZone } from 'luxon';\n\n\nconst names = [\n\n  // 10.3.4.1 Conversion functions\n  'date and time',\n  'time',\n  'date',\n  'number',\n  'string',\n  'duration',\n  'years and months duration',\n\n  // 10.3.4.2 Boolean function\n  'not',\n\n  // 10.3.4.3 String functions\n  'substring',\n  'string length',\n  'upper case',\n  'lower case',\n  'substring before',\n  'substring after',\n  'replace',\n  'contains',\n  'matches',\n  'starts with',\n  'ends with',\n  'split',\n  'string join',\n\n  // 10.3.4.4 List functions\n  'list contains',\n  'list replace',\n  'count',\n  'min',\n  'max',\n  'sum',\n  'mean',\n  'all',\n  'any',\n  'sublist',\n  'append',\n  'concatenate',\n  'insert before',\n  'remove',\n  'reverse',\n  'index of',\n  'union',\n  'distinct values',\n  'flatten',\n  'product',\n  'median',\n  'stddev',\n  'mode',\n\n  // 10.3.4.5 Numeric functions\n  'decimal',\n  'floor',\n  'ceiling',\n  'abs',\n  'modulo',\n  'sqrt',\n  'log',\n  'exp',\n  'odd',\n  'even',\n\n  // 10.3.4.6 Date and time functions\n  'is',\n\n  // 10.3.4.7 Range Functions\n  'before',\n  'after',\n  'meets',\n  'met by',\n  'overlaps',\n  'overlaps before',\n  'overlaps after',\n  'finishes',\n  'finished by',\n  'includes',\n  'during',\n  'starts',\n  'started by',\n  'coincides',\n\n  // 10.3.4.8 Temporal built-in functions\n  'day of year',\n  'day of week',\n  'month of year',\n  'week of year',\n\n  // 10.3.4.9 Sort\n  'sort',\n  'list',\n  'precedes',\n\n  // 10.3.4.10 Context function\n  'get value',\n  'get entries',\n  'context',\n  'context merge',\n  'context put'\n];\n\n\n// 10.3.4 Built-in functions\n\nconst builtins = {\n\n  // 10.3.4.1 Conversion functions\n\n  'number': fn(function(from, groupingSeparator, decimalSeparator) {\n\n    // must always provide three arguments\n    if (arguments.length !== 3) {\n      return null;\n    }\n\n    if (groupingSeparator) {\n      from = from.split(groupingSeparator).join('');\n    }\n\n    if (decimalSeparator && decimalSeparator !== '.') {\n      from = from.split('.').join('#').split(decimalSeparator).join('.');\n    }\n\n    const number = +from;\n\n    if (isNaN(number)) {\n      return null;\n    }\n\n    return number;\n  }, [ 'string', 'string?', 'string?' ], [ 'from', 'grouping separator', 'decimal separator' ]),\n\n  'string': fn(function(from) {\n    if (from === null) {\n      return null;\n    }\n\n    return toString(from);\n  }, [ 'any' ]),\n\n  // date(from) => date string\n  // date(from) => date and time\n  // date(year, month, day)\n  'date': fn(function(year, month, day, from) {\n\n    if (!from && !isNumber(year)) {\n      from = year;\n      year = null;\n    }\n\n    let d;\n\n    if (isString(from)) {\n      d = date(from);\n    }\n\n    if (isDateTime(from)) {\n      d = from;\n    }\n\n    if (year) {\n      d = date().setZone('utc').set({\n        year,\n        month,\n        day\n      });\n    }\n\n    return d && ifValid(d.setZone('utc').startOf('day')) || null;\n  }, [ 'any?', 'number?', 'number?', 'any?' ]),\n\n  // date and time(from) => date time string\n  // date and time(date, time)\n  'date and time': fn(function(d, time, from) {\n\n    let dt;\n\n    if (isDateTime(d) && isDateTime(time)) {\n\n      const dLocal = d.toLocal();\n\n      dt = time.set({\n        year: dLocal.year,\n        month: dLocal.month,\n        day: dLocal.day\n      });\n    }\n\n    if (isString(d)) {\n      from = d;\n      d = null;\n    }\n\n    if (isString(from)) {\n      dt = date(from, null, from.includes('@') ? null : SystemZone.instance);\n    }\n\n    return dt && ifValid(dt) || null;\n  }, [ 'any?', 'time?', 'string?' ], [ 'date', 'time', 'from' ]),\n\n  // time(from) => time string\n  // time(from) => time, date and time\n  // time(hour, minute, second, offset?) => ...\n  'time': fn(function(hour, minute, second, offset, from) {\n\n    let t;\n\n    if (offset) {\n      throw notImplemented('time(..., offset)');\n    }\n\n    if (isString(hour) || isDateTime(hour)) {\n      from = hour;\n      hour = null;\n    }\n\n    if (isString(from)) {\n\n      t = date(null, from);\n    }\n\n    if (isDateTime(from)) {\n      t = from.set({\n        year: 1900,\n        month: 1,\n        day: 1\n      });\n    }\n\n    if (isNumber(hour)) {\n\n      // TODO: support offset = days and time duration\n      t = date().set({\n        hour,\n        minute,\n        second\n      }).set({\n        year: 1900,\n        month: 1,\n        day: 1,\n        millisecond: 0\n      });\n    }\n\n    return t && ifValid(t) || null;\n  }, [ 'any?', 'number?', 'number?', 'any?', 'any?' ]),\n\n  'duration': fn(function(from) {\n    return ifValid(duration(from));\n  }, [ 'string' ]),\n\n  'years and months duration': fn(function(from, to) {\n    return ifValid(to.diff(from, [ 'years', 'months' ]));\n  }, [ 'date', 'date' ]),\n\n  '@': fn(function(string) {\n\n    let t;\n\n    if (/^-?P/.test(string)) {\n      t = duration(string);\n    }\n\n    else if (/^[\\d]{1,2}:[\\d]{1,2}:[\\d]{1,2}/.test(string)) {\n      t = date(null, string);\n    }\n\n    else {\n      t = date(string);\n    }\n\n    return t && ifValid(t) || null;\n  }, [ 'string' ]),\n\n  'now': fn(function() {\n    return date();\n  }, []),\n\n  'today': fn(function() {\n    return date().startOf('day');\n  }, []),\n\n  // 10.3.4.2 Boolean function\n  'not': fn(function(bool) {\n    return isType(bool, 'boolean') ? !bool : null;\n  }, [ 'any' ]),\n\n  // 10.3.4.3 String functions\n  'substring': fn(function(string, start, length) {\n\n    const _start = (start < 0 ? string.length + start : start - 1);\n\n    const arr = Array.from(string);\n\n    return (\n      typeof length !== 'undefined'\n        ? arr.slice(_start, _start + length)\n        : arr.slice(_start)\n    ).join('');\n  }, [ 'string', 'number', 'number?' ], [ 'string', 'start position', 'length' ]),\n\n  'string length': fn(function(string) {\n    return countSymbols(string);\n  }, [ 'string' ]),\n\n  'upper case': fn(function(string) {\n    return string.toUpperCase();\n  }, [ 'string' ]),\n\n  'lower case': fn(function(string) {\n    return string.toLowerCase();\n  }, [ 'string' ]),\n\n  'substring before': fn(function(string, match) {\n\n    const index = string.indexOf(match);\n\n    if (index === -1) {\n      return '';\n    }\n\n    return string.substring(0, index);\n  }, [ 'string', 'string' ]),\n\n  'substring after': fn(function(string, match) {\n\n    const index = string.indexOf(match);\n\n    if (index === -1) {\n      return '';\n    }\n\n    return string.substring(index + match.length);\n  }, [ 'string', 'string' ]),\n\n  'replace': fn(function(input, pattern, replacement, flags) {\n    return input.replace(new RegExp(pattern, 'ug' + (flags || '').replace(/[x]/g, '')), replacement.replace(/\\$0/g, '$$&'));\n  }, [ 'string', 'string', 'string', 'string?' ]),\n\n  'contains': fn(function(string, match) {\n    return string.includes(match);\n  }, [ 'string', 'string' ]),\n\n  // eslint-disable-next-line\n  'matches': fn(function(input, pattern, flags) {\n    throw notImplemented('matches');\n  }, [ 'string', 'string', 'string?' ]),\n\n  'starts with': fn(function(string, match) {\n    return string.startsWith(match);\n  }, [ 'string', 'string' ]),\n\n  'ends with': fn(function(string, match) {\n    return string.endsWith(match);\n  }, [ 'string', 'string' ]),\n\n  'split': fn(function(string, delimiter) {\n    return string.split(new RegExp(delimiter, 'u'));\n  }, [ 'string', 'string' ]),\n\n  'string join': fn(function(list, delimiter) {\n    if (list.some(e => !isString(e) && e !== null)) {\n      return null;\n    }\n\n    return list.filter(l => l !== null).join(delimiter || '');\n  }, [ 'list', 'string?' ]),\n\n  // 10.3.4.4 List functions\n\n  'list contains': fn(function(list, element) {\n    return list.some(el => matches(el, element));\n  }, [ 'list', 'any?' ]),\n\n  // list replace(list, position, newItem)\n  // list replace(list, match, newItem)\n  'list replace': fn(function(list, position, newItem, match) {\n\n    const matcher = position || match;\n\n    if (![ 'number', 'function' ].includes(getType(matcher))) {\n      return null;\n    }\n\n    return listReplace(list, position || match, newItem);\n  }, [ 'list', 'any?', 'any', 'function?' ]),\n\n  'count': fn(function(list) {\n    return list.length;\n  }, [ 'list' ]),\n\n  'min': listFn(function(...list) {\n    return list.reduce((min, el) => min === null ? el : Math.min(min, el), null);\n  }, 'number'),\n\n  'max': listFn(function(...list) {\n    return list.reduce((max, el) => max === null ? el : Math.max(max, el), null);\n  }, 'number'),\n\n  'sum': listFn(function(...list) {\n    return sum(list);\n  }, 'number'),\n\n  'mean': listFn(function(...list) {\n    const s = sum(list);\n\n    return s === null ? s : s / list.length;\n  }, 'number'),\n\n  'all': listFn(function(...list) {\n\n    let nonBool = false;\n\n    for (const o of list) {\n\n      if (o === false) {\n        return false;\n      }\n\n      if (typeof o !== 'boolean') {\n        nonBool = true;\n      }\n    }\n\n    return nonBool ? null : true;\n\n  }, 'any?'),\n\n  'any': listFn(function(...list) {\n\n    let nonBool = false;\n\n    for (const o of list) {\n\n      if (o === true) {\n        return true;\n      }\n\n      if (typeof o !== 'boolean') {\n        nonBool = true;\n      }\n    }\n\n    return nonBool ? null : false;\n  }, 'any?'),\n\n  'sublist': fn(function(list, start, length) {\n\n    const _start = (start < 0 ? list.length + start : start - 1);\n\n    return (\n      typeof length !== 'undefined'\n        ? list.slice(_start, _start + length)\n        : list.slice(_start)\n    );\n\n  }, [ 'list', 'number', 'number?' ]),\n\n  'append': fn(function(list, ...items) {\n    return list.concat(items);\n  }, [ 'list', 'any?' ]),\n\n  'concatenate': fn(function(...args) {\n\n    return args.reduce((result, arg) => {\n      return result.concat(arg);\n    }, []);\n\n  }, [ 'any' ]),\n\n  'insert before': fn(function(list, position, newItem) {\n    return list.slice(0, position - 1).concat([ newItem ], list.slice(position - 1));\n  }, [ 'list', 'number', 'any?' ]),\n\n  'remove': fn(function(list, position) {\n    return list.slice(0, position - 1).concat(list.slice(position));\n  }, [ 'list', 'number' ]),\n\n  'reverse': fn(function(list) {\n    return list.slice().reverse();\n  }, [ 'list' ]),\n\n  'index of': fn(function(list, match) {\n\n    return list.reduce(function(result, element, index) {\n\n      if (matches(element, match)) {\n        result.push(index + 1);\n      }\n\n      return result;\n    }, []);\n  }, [ 'list', 'any' ]),\n\n  'union': listFn(function(...lists) {\n\n    return lists.reduce((result, list) => {\n\n      return list.reduce((result, e) => {\n        if (!result.some(r => equals(e, r))) {\n          result.push(e);\n        }\n\n        return result;\n      }, result);\n    }, []);\n\n  }, 'list'),\n\n  'distinct values': fn(function(list) {\n    return list.reduce((result, e) => {\n      if (!result.some(r => equals(e, r))) {\n        result.push(e);\n      }\n\n      return result;\n    }, []);\n  }, [ 'list' ]),\n\n  'flatten': fn(function(list) {\n    return flatten(list);\n  }, [ 'list' ]),\n\n  'product': listFn(function(...list) {\n\n    if (list.length === 0) {\n      return null;\n    }\n\n    return list.reduce((result, n) => {\n      return result * n;\n    }, 1);\n  }, 'number'),\n\n  'median': listFn(function(...list) {\n\n    if (list.length === 0) {\n      return null;\n    }\n\n    return median(list);\n  }, 'number'),\n\n  'stddev': listFn(function(...list) {\n\n    if (list.length < 2) {\n      return null;\n    }\n\n    return stddev(list);\n  }, 'number'),\n\n  'mode': listFn(function(...list) {\n    return mode(list);\n  }, 'number'),\n\n\n  // 10.3.4.5 Numeric functions\n  'decimal': fn(function(n, scale) {\n\n    if (!scale) {\n      return round(n);\n    }\n\n    const offset = 10 ** scale;\n\n    return round(n * offset) / (offset);\n  }, [ 'number', 'number' ]),\n\n  'floor': fn(function(n, scale = 0) {\n\n    if (scale === null) {\n      return null;\n    }\n\n    const adjust = Math.pow(10, scale);\n\n    return Math.floor(n * adjust) / adjust;\n  }, [ 'number', 'number?' ]),\n\n  'ceiling': fn(function(n, scale = 0) {\n\n    if (scale === null) {\n      return null;\n    }\n\n    const adjust = Math.pow(10, scale);\n\n    return Math.ceil(n * adjust) / adjust;\n  }, [ 'number', 'number?' ]),\n\n  'abs': fn(function(n) {\n\n    if (typeof n !== 'number') {\n      return null;\n    }\n\n    return Math.abs(n);\n  }, [ 'number' ]),\n\n  // eslint-disable-next-line\n  'round up': fn(function(n, scale) {\n    throw notImplemented('round up');\n  }, [ 'number', 'number' ]),\n\n  // eslint-disable-next-line\n  'round down': fn(function(n, scale) {\n    throw notImplemented('round down');\n  }, [ 'number', 'number' ]),\n\n  // eslint-disable-next-line\n  'round half up': fn(function(n, scale) {\n    throw notImplemented('round half up');\n  }, [ 'number', 'number' ]),\n\n  // eslint-disable-next-line\n  'round half down': fn(function(n, scale) {\n    throw notImplemented('round half down');\n  }, [ 'number', 'number' ]),\n\n  'modulo': fn(function(dividend, divisor) {\n\n    if (!divisor) {\n      return null;\n    }\n\n    const adjust = 1000000000;\n\n    // cf. https://dustinpfister.github.io/2017/09/02/js-whats-wrong-with-modulo/\n    //\n    // need to round here as using this custom modulo\n    // variant is prone to rounding errors\n    return Math.round((dividend % divisor + divisor) % divisor * adjust) / adjust;\n  }, [ 'number', 'number' ]),\n\n  'sqrt': fn(function(number) {\n\n    if (number < 0) {\n      return null;\n    }\n\n    return Math.sqrt(number);\n  }, [ 'number' ]),\n\n  'log': fn(function(number) {\n    if (number <= 0) {\n      return null;\n    }\n\n    return Math.log(number);\n  }, [ 'number' ]),\n\n  'exp': fn(function(number) {\n    return Math.exp(number);\n  }, [ 'number' ]),\n\n  'odd': fn(function(number) {\n    return Math.abs(number) % 2 === 1;\n  }, [ 'number' ]),\n\n  'even': fn(function(number) {\n    return Math.abs(number) % 2 === 0;\n  }, [ 'number' ]),\n\n\n  // 10.3.4.6 Date and time functions\n\n  'is': fn(function(value1, value2) {\n\n    if (typeof value1 === 'undefined' || typeof value2 === 'undefined') {\n      return false;\n    }\n\n    return equals(value1, value2, true);\n  }, [ 'any?', 'any?' ]),\n\n  // 10.3.4.7 Range Functions\n\n  'before': fn(function(a, b) {\n    return before(a, b);\n  }, [ 'any', 'any' ]),\n\n  'after': fn(function(a, b) {\n    return before(b, a);\n  }, [ 'any', 'any' ]),\n\n  'meets': fn(function(a, b) {\n    return meetsRange(a, b);\n  }, [ 'range', 'range' ]),\n\n  'met by': fn(function(a, b) {\n    return meetsRange(b, a);\n  }, [ 'range', 'range' ]),\n\n  'overlaps': fn(function(range1, range2) {\n    return !before(range1, range2) && !before(range2, range1);\n  }, [ 'range', 'range' ]),\n\n  'overlaps before': fn(function() {\n    throw notImplemented('overlaps before');\n  }, [ 'any?' ]),\n\n  'overlaps after': fn(function() {\n    throw notImplemented('overlaps after');\n  }, [ 'any?' ]),\n\n  'finishes': fn(function() {\n    throw notImplemented('finishes');\n  }, [ 'any?' ]),\n\n  'finished by': fn(function() {\n    throw notImplemented('finished by');\n  }, [ 'any?' ]),\n\n  'includes': fn(function() {\n    throw notImplemented('includes');\n  }, [ 'any?' ]),\n\n  'during': fn(function() {\n    throw notImplemented('during');\n  }, [ 'any?' ]),\n\n  'starts': fn(function() {\n    throw notImplemented('starts');\n  }, [ 'any?' ]),\n\n  'started by': fn(function() {\n    throw notImplemented('started by');\n  }, [ 'any?' ]),\n\n  'coincides': fn(function() {\n    throw notImplemented('coincides');\n  }, [ 'any?' ]),\n\n\n  // 10.3.4.8 Temporal built-in functions\n\n  'day of year': fn(function(date) {\n    return date.ordinal;\n  }, [ 'date time' ]),\n\n  'day of week': fn(function(date) {\n    return date.weekdayLong;\n  }, [ 'date time' ]),\n\n  'month of year': fn(function(date) {\n    return date.monthLong;\n  }, [ 'date time' ]),\n\n  'week of year': fn(function(date) {\n    return date.weekNumber;\n  }, [ 'date time' ]),\n\n\n  // 10.3.4.9 Sort\n\n  'sort': fn(function(list, precedes) {\n    return Array.from(list).sort((a, b) => precedes.invoke([ a, b ]) ? -1 : 1);\n  }, [ 'list', 'function' ]),\n\n\n  // 10.3.4.10 Context function\n\n  'get value': fn(function(m, key) {\n    return getFromContext(key, m) || null;\n  }, [ 'context', 'string' ]),\n\n  'get entries': fn(function(m) {\n\n    if (arguments.length !== 1) {\n      return null;\n    }\n\n    if (Array.isArray(m)) {\n      return null;\n    }\n\n    return Object.entries(m).map(([ key, value ]) => ({ key, value }));\n  }, [ 'context' ]),\n\n  'context': listFn(function(...entries) {\n    const context = entries.reduce((context, entry) => {\n\n      if (context === FALSE || ![ 'key', 'value' ].every(e => e in entry)) {\n        return FALSE;\n      }\n\n      const key = entry.key;\n\n      if (key === null) {\n        return FALSE;\n      }\n\n      if (key in context) {\n        return FALSE;\n      }\n\n      return {\n        ...context,\n        [entry.key]: entry.value\n      };\n    }, {});\n\n    if (context === FALSE) {\n      return null;\n    }\n\n    return context;\n  }, 'context'),\n\n  'context merge': listFn(function(...contexts) {\n    return Object.assign({}, ...contexts);\n  }, 'context'),\n\n  'context put': fn(function(context, keys, value, key) {\n\n    if (typeof keys === 'undefined' && typeof key === 'undefined') {\n      return null;\n    }\n\n    return contextPut(context, keys || [ key ], value);\n  }, [ 'context', 'list?', 'any', 'string?' ], [ 'context', 'keys', 'value', 'key' ])\n\n};\n\nexport {\n  names,\n  builtins\n};\n\n/**\n * @param {Object} context\n * @param {string[]} keys\n * @param {any} value\n */\nfunction contextPut(context, keys, value) {\n  const [ key, ...remainingKeys ] = keys;\n\n  if (getType(key) !== 'string') {\n    return null;\n  }\n\n  if (getType(context) === 'nil') {\n    return null;\n  }\n\n  if (remainingKeys.length) {\n    value = contextPut(context[key], remainingKeys, value);\n\n    if (value === null) {\n      return null;\n    }\n  }\n\n  return {\n    ...context,\n    [key]: value\n  };\n}\n\nfunction matches(a, b) {\n  return a === b;\n}\n\nconst FALSE = {};\n\nfunction createArgTester(arg) {\n  const optional = arg.endsWith('?');\n\n  const type = optional ? arg.substring(0, arg.length - 1) : arg;\n\n  return function(obj) {\n\n    const arr = Array.isArray(obj);\n\n    if (type === 'list') {\n      if (arr || optional && typeof obj === 'undefined') {\n        return obj;\n      } else {\n\n        // implicit conversion obj => [ obj ]\n        return obj === null ? FALSE : [ obj ];\n      }\n    }\n\n    if (type !== 'any' && arr && obj.length === 1) {\n\n      // implicit conversion [ obj ] => obj\n      obj = obj[0];\n    }\n\n    const objType = getType(obj);\n\n    if (type === 'any' || type === objType) {\n      return optional ? obj : typeof obj !== 'undefined' ? obj : FALSE;\n    }\n\n    if (objType === 'nil') {\n      return (optional ? obj : FALSE);\n    }\n\n    return typeCast(obj, type) || FALSE;\n  };\n}\n\nfunction createArgsValidator(argDefinitions) {\n\n  const tests = argDefinitions.map(createArgTester);\n\n  return function(args) {\n\n    while (args.length < argDefinitions.length) {\n      args.push(undefined);\n    }\n\n    return args.reduce((result, arg, index) => {\n\n      if (result === false) {\n        return result;\n      }\n\n      const test = tests[index];\n\n      const conversion = test ? test(arg) : arg;\n\n      if (conversion === FALSE) {\n        return false;\n      }\n\n      result.push(conversion);\n\n      return result;\n    }, []);\n\n  };\n}\n\n/**\n * @param {Function} fnDefinition\n * @param {string} type\n * @param {string[]} [parameterNames]\n *\n * @return {Function}\n */\nfunction listFn(fnDefinition, type, parameterNames = null) {\n\n  const tester = createArgTester(type);\n\n  const wrappedFn = function(...args) {\n\n    if (args.length === 0) {\n      return null;\n    }\n\n    // unwrap first arg\n    if (Array.isArray(args[0]) && args.length === 1) {\n      args = args[0];\n    }\n\n    if (!args.every(arg => tester(arg) !== FALSE)) {\n      return null;\n    }\n\n    return fnDefinition(...args);\n  };\n\n  wrappedFn.$args = parameterNames || parseParameterNames(fnDefinition);\n\n  return wrappedFn;\n}\n\n/**\n * @param {Function} fnDefinition\n * @param {string[]} argDefinitions\n * @param {string[]} [parameterNames]\n *\n * @return {Function}\n */\nfunction fn(fnDefinition, argDefinitions, parameterNames = null) {\n\n  const checkArgs = createArgsValidator(argDefinitions);\n\n  parameterNames = parameterNames || parseParameterNames(fnDefinition);\n\n  const wrappedFn = function(...args) {\n\n    const convertedArgs = checkArgs(args);\n\n    if (!convertedArgs) {\n      return null;\n    }\n\n    return fnDefinition(...convertedArgs);\n  };\n\n  wrappedFn.$args = parameterNames;\n\n  return wrappedFn;\n}\n\n/**\n * @param {Range} a\n * @param {Range} b\n */\nfunction meetsRange(a, b) {\n  return [\n    (a.end === b.start),\n    (a['end included'] === true),\n    (b['start included'] === true)\n  ].every(v => v);\n}\n\n/**\n * @param {Range|number} a\n * @param {Range|number} b\n */\nfunction before(a, b) {\n  if (a instanceof Range && b instanceof Range) {\n    return (\n      a.end < b.start || (\n        !a['end included'] || !b['start included']\n      ) && a.end == b.start\n    );\n  }\n\n  if (a instanceof Range) {\n    return (\n      a.end < b || (\n        !a['end included'] && a.end === b\n      )\n    );\n  }\n\n  if (b instanceof Range) {\n    return (\n      b.start > a || (\n        !b['start included'] && b.start === a\n      )\n    );\n  }\n\n  return a < b;\n}\n\nfunction sum(list) {\n  return list.reduce((sum, el) => sum === null ? el : sum + el, null);\n}\n\nfunction flatten<T>([ x,...xs ]: (T|T[])[]):T[] {\n  return (\n    x !== undefined\n      ? [ ...Array.isArray(x) ? flatten(x) : [ x ],...flatten(xs) ]\n      : []\n  );\n}\n\nfunction toKeyString(key) {\n  if (typeof key === 'string' && /\\W/.test(key)) {\n    return toString(key, true);\n  }\n\n  return key;\n}\n\nfunction toDeepString(obj) {\n  return toString(obj, true);\n}\n\nfunction escapeStr(str) {\n  return str.replace(/(\"|\\\\)/g, '\\\\$1');\n}\n\nfunction toString(obj, wrap = false) {\n\n  const type = getType(obj);\n\n  if (type === 'nil') {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return wrap ? `\"${ escapeStr(obj) }\"` : obj;\n  }\n\n  if (type === 'boolean' || type === 'number') {\n    return String(obj);\n  }\n\n  if (type === 'list') {\n    return '[' + obj.map(toDeepString).join(', ') + ']';\n  }\n\n  if (type === 'context') {\n    return '{' + Object.entries(obj).map(([ key, value ]) => {\n      return toKeyString(key) + ': ' + toDeepString(value);\n    }).join(', ') + '}';\n  }\n\n  if (type === 'duration') {\n    return obj.shiftTo('years', 'months', 'days', 'hours', 'minutes', 'seconds').normalize().toISO();\n  }\n\n  if (type === 'date time') {\n    if (obj.zone === SystemZone.instance) {\n      return obj.toISO({ suppressMilliseconds: true, includeOffset: false });\n    }\n\n    if (obj.zone?.zoneName) {\n      return obj.toISO({ suppressMilliseconds: true, includeOffset: false }) + '@' + obj.zone?.zoneName;\n    }\n\n    return obj.toISO({ suppressMilliseconds: true });\n  }\n\n  if (type === 'date') {\n    return obj.toISODate();\n  }\n\n  if (type === 'range') {\n    return '<range>';\n  }\n\n  if (type === 'time') {\n    if (obj.zone === SystemZone.instance) {\n      return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false });\n    }\n\n    if (obj.zone?.zoneName) {\n      return obj.toISOTime({ suppressMilliseconds: true, includeOffset: false }) + '@' + obj.zone?.zoneName;\n    }\n\n    return obj.toISOTime({ suppressMilliseconds: true });\n  }\n\n  if (type === 'function') {\n    return '<function>';\n  }\n\n  throw notImplemented('string(' + type + ')');\n}\n\nfunction countSymbols(str) {\n\n  // cf. https://mathiasbynens.be/notes/javascript-unicode\n  return str.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\n}\n\nfunction round(n) {\n\n  const integral = Math.trunc(n);\n\n  if (n - integral > .5) {\n    return integral + 1;\n  } else {\n    return integral;\n  }\n}\n\n// adapted from https://stackoverflow.com/a/53577159\n\nfunction stddev(array) {\n  const n = array.length;\n  const mean = array.reduce((a, b) => a + b) / n;\n\n  return Math.sqrt(\n    array.map(\n      x => Math.pow(x - mean, 2)\n    ).reduce(\n      (a, b) => a + b\n    ) / (n - 1)\n  );\n}\n\nfunction listReplace(list, matcher, newItem) {\n\n  if (isNumber(matcher)) {\n    return [ ...list.slice(0, matcher - 1), newItem, ...list.slice(matcher) ];\n  }\n\n  return list.map((item, _idx) => {\n\n    if (matcher.invoke([ item, newItem ])) {\n      return newItem;\n    } else {\n      return item;\n    }\n  });\n}\n\nfunction median(array) {\n  const n = array.length;\n  const sorted = array.slice().sort();\n\n  const mid = n / 2 - 1;\n  const index = Math.ceil(mid);\n\n  // even\n  if (mid === index) {\n    return (sorted[index] + sorted[index + 1]) / 2;\n  }\n\n  // uneven\n  return sorted[index];\n}\n\nfunction mode(array: number[]) {\n\n  if (array.length < 2) {\n    return array;\n  }\n\n  const buckets: Record<number, number> = {};\n\n  for (const n of array) {\n    buckets[n] = (buckets[n] || 0) + 1;\n  }\n\n  const sorted = Object.entries(buckets).sort((a, b) => b[1] - a[1]);\n\n  return sorted.filter(s => s[1] === sorted[0][1]).map(e => +e[0]);\n}\n\nfunction ifValid<T extends DateTime | Duration>(o: T) : T | null {\n  return o.isValid ? o : null;\n}","import {\n  parser,\n  trackVariables\n} from 'lezer-feel';\n\nimport { Tree } from '@lezer/common';\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ParseContext = Record<string, any>;\n\nexport function parseExpression(expression: string, context: ParseContext = {}): Tree {\n  return parser.configure({\n    top: 'Expression',\n    contextTracker: trackVariables(context)\n  }).parse(expression);\n}\n\nexport function parseUnaryTests(expression: string, context: ParseContext = {}): Tree {\n  return parser.configure({\n    top: 'UnaryTests',\n    contextTracker: trackVariables(context)\n  }).parse(expression);\n}","import { Tree, SyntaxNodeRef, SyntaxNode } from '@lezer/common';\n\nimport { builtins } from './builtins';\n\nimport {\n  Range,\n  FunctionWrapper,\n  equals,\n  isArray,\n  getType,\n  isDuration,\n  isDateTime,\n  isType,\n  isNumber\n} from './types';\n\nimport {\n  notImplemented,\n  parseParameterNames,\n  getFromContext\n} from './utils';\n\nimport {\n  parseExpression,\n  parseUnaryTests\n} from './parser';\n\nimport { Duration } from 'luxon';\n\n\ntype SyntaxErrorDetails = {\n  input: string,\n  position: {\n    from: number,\n    to: number\n  }\n};\n\nexport class SyntaxError extends Error {\n\n  input: string;\n\n  position: {\n    from: number,\n    to: number\n  };\n\n  constructor(\n      message: string,\n      details: SyntaxErrorDetails\n  ) {\n    super(message);\n\n    Object.assign(this, details);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InterpreterContext = Record<string, any>;\n\nclass Interpreter {\n\n  _buildExecutionTree(tree: Tree, input: string) {\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    type StackEntry = { args: any[], nodeInput: string };\n\n    const root = { args: [], nodeInput: input };\n\n    const stack: StackEntry[] = [ root ];\n\n    tree.iterate({\n      enter(nodeRef) {\n\n        const {\n          isError,\n          isSkipped\n        } = nodeRef.type;\n\n        const {\n          from,\n          to\n        } = nodeRef;\n\n        if (isError) {\n\n          const {\n            from,\n            to,\n            message\n          } = lintError(nodeRef);\n\n          throw new SyntaxError(\n            message,\n            {\n              input: input.slice(from, to),\n              position: {\n                from,\n                to\n              }\n            }\n          );\n        }\n\n        if (isSkipped) {\n          return false;\n        }\n\n        const nodeInput = input.slice(from, to);\n\n        stack.push({\n          nodeInput,\n          args: []\n        });\n      },\n\n      leave(nodeRef) {\n\n        if (nodeRef.type.isSkipped) {\n          return;\n        }\n\n        const {\n          nodeInput,\n          args\n        } = stack.pop();\n\n        const parent = stack[stack.length - 1];\n\n        const expr = evalNode(nodeRef, nodeInput, args);\n\n        parent.args.push(expr);\n      }\n    });\n\n    return root.args[root.args.length - 1];\n  }\n\n  evaluate(expression: string, context: InterpreterContext = {}) {\n\n    const parseTree = parseExpression(expression, context);\n\n    const root = this._buildExecutionTree(parseTree, expression);\n\n    return {\n      parseTree,\n      root\n    };\n  }\n\n  unaryTest(expression: string, context: InterpreterContext = {}) {\n\n    const parseTree = parseUnaryTests(expression, context);\n\n    const root = this._buildExecutionTree(parseTree, expression);\n\n    return {\n      parseTree,\n      root\n    };\n  }\n\n}\n\nconst interpreter = new Interpreter();\n\nexport function unaryTest(expression: string, context: InterpreterContext = {}) : boolean {\n  const value = context['?'] || null;\n\n  const {\n    root\n  } = interpreter.unaryTest(expression, context);\n\n  // root = fn(ctx) => test(val)\n  const test = root(context);\n\n  return test(value);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function evaluate(expression: string, context: InterpreterContext = {}): any {\n\n  const {\n    root\n  } = interpreter.evaluate(expression, context);\n\n  // root = Expression :: fn(ctx)\n\n  return root(context);\n}\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction evalNode(node: SyntaxNodeRef, input: string, args: any[]) {\n\n  switch (node.name) {\n  case 'ArithOp': return (context) => {\n\n    const nullable = (op, types = [ 'number' ]) => (a, b) => {\n\n      const left = a(context);\n      const right = b(context);\n\n      if (isArray(left)) {\n        return null;\n      }\n\n      if (isArray(right)) {\n        return null;\n      }\n\n      const leftType = getType(left);\n      const rightType = getType(right);\n\n      const temporal = [ 'date', 'time', 'date time', 'duration' ];\n\n      if (temporal.includes(leftType)) {\n        if (!temporal.includes(rightType)) {\n          return null;\n        }\n      } else if (leftType !== rightType || !types.includes(leftType)) {\n        return null;\n      }\n\n      return op(left, right);\n    };\n\n    switch (input) {\n    case '+': return nullable((a, b) => {\n      if (isType(a, 'time') && isDuration(b)) {\n        return a.plus(b).set({\n          year: 1900,\n          month: 1,\n          day: 1\n        });\n      } else if (isDateTime(a) && isDateTime(b)) {\n        return null;\n      } else if (isDateTime(a) && isDuration(b)) {\n        return a.plus(b);\n      } else if (isDuration(a) && isDuration(b)) {\n        return a.plus(b);\n      }\n\n      return a + b;\n    }, [ 'string', 'number', 'date', 'time', 'duration', 'date time' ]);\n    case '-': return nullable((a, b) => {\n      if (isType(a, 'time') && isDuration(b)) {\n        return a.minus(b).set({\n          year: 1900,\n          month: 1,\n          day: 1\n        });\n      } else if (isDateTime(a) && isDateTime(b)) {\n        return a.diff(b);\n      } else if (isDateTime(a) && isDuration(b)) {\n        return a.minus(b);\n      } else if (isDuration(a) && isDuration(b)) {\n        return a.minus(b);\n      }\n\n      return a - b;\n    }, [ 'number', 'date', 'time', 'duration', 'date time' ]);\n    case '*': return nullable((a, b) => a * b);\n    case '/': return nullable((a, b) => !b ? null : a / b);\n    case '**':\n    case '^': return nullable((a, b) => a ** b);\n    }\n  };\n\n  case 'CompareOp': return tag(() => {\n\n    switch (input) {\n    case '>': return (b) => createRange(b, null, false, false);\n    case '>=': return (b) => createRange(b, null, true, false);\n    case '<': return (b) => createRange(null, b, false, false);\n    case '<=': return (b) => createRange(null, b, false, true);\n    case '=': return (b) => (a) => equals(a, b);\n    case '!=': return (b) => (a) => !equals(a, b);\n    }\n\n  }, Test('boolean'));\n\n  case 'Wildcard': return (_context) => true;\n\n  case 'null': return (_context) => {\n    return null;\n  };\n\n  case 'Disjunction': return tag((context) => {\n\n    const left = args[0](context);\n    const right = args[2](context);\n\n    const matrix = [\n      [ true, true, true ],\n      [ true, false, true ],\n      [ true, null, true ],\n      [ false, true, true ],\n      [ false, false, false ],\n      [ false, null, null ],\n      [ null, true, true ],\n      [ null, false, null ],\n      [ null, null, null ],\n    ];\n\n    const a = typeof left === 'boolean' ? left : null;\n    const b = typeof right === 'boolean' ? right : null;\n\n    return matrix.find(el => el[0] === a && el[1] === b)[2];\n  }, Test('boolean'));\n\n  case 'Conjunction': return tag((context) => {\n    const left = args[0](context);\n    const right = args[2](context);\n\n    const matrix = [\n      [ true, true, true ],\n      [ true, false, false ],\n      [ true, null, null ],\n      [ false, true, false ],\n      [ false, false, false ],\n      [ false, null, false ],\n      [ null, true, null ],\n      [ null, false, false ],\n      [ null, null, null ],\n    ];\n\n    const a = typeof left === 'boolean' ? left : null;\n    const b = typeof right === 'boolean' ? right : null;\n\n    return matrix.find(el => el[0] === a && el[1] === b)[2];\n  }, Test('boolean'));\n\n  case 'Context': return (context) => {\n\n    return args.slice(1, -1).reduce((obj, arg) => {\n      const [ key, value ] = arg({\n        ...context,\n        ...obj\n      });\n\n      return {\n        ...obj,\n        [key]: value\n      };\n    }, {});\n  };\n\n  case 'FunctionBody': return args[0];\n\n  case 'FormalParameters': return args;\n\n  case 'FormalParameter': return args[0];\n\n  case 'ParameterName': return args.join(' ');\n\n  case 'FunctionDefinition': return (context) => {\n    const parameterNames = args[2];\n\n    const fnBody = args[4];\n\n    return wrapFunction((...args) => {\n\n      const fnContext = parameterNames.reduce((context, name, idx) => {\n\n        // support positional parameters\n        context[name] = args[idx];\n\n        return context;\n      }, { ...context });\n\n      return fnBody(fnContext);\n    }, parameterNames);\n  };\n\n  case 'ContextEntry': return (context) => {\n\n    const key = typeof args[0] === 'function' ? args[0](context) : args[0];\n\n    const value = args[1](context);\n\n    return [ key, value ];\n  };\n\n  case 'Key': return args[0];\n\n  case 'Identifier': return input;\n\n  case 'SpecialFunctionName': return (context) => getBuiltin(input, context);\n\n  // preserve spaces in name, but compact multiple\n  // spaces into one (token)\n  case 'Name': return input.replace(/\\s{2,}/g, ' ');\n\n  case 'VariableName': return (context) => {\n    const name = args.join(' ');\n\n    const contextValue = getFromContext(name, context);\n\n    return (\n      typeof contextValue !== 'undefined'\n        ? contextValue\n        : getBuiltin(name, context) || null\n    );\n  };\n\n  case 'QualifiedName': return (context) => {\n    return args.reduce((context, arg) => arg(context), context);\n  };\n\n  case '?': return (context) => getFromContext('?', context);\n\n  // expression\n  // expression \"..\" expression\n  case 'IterationContext': return (context) => {\n\n    const a = args[0](context);\n\n    const b = args[1] && args[1](context);\n\n    return b ? createRange(a, b) : a;\n  };\n\n  case 'Type': return args[0];\n\n  case 'InExpressions': return (context) => {\n\n    const iterationContexts = args.map(ctx => ctx(context));\n\n    if (iterationContexts.some(ctx => getType(ctx) !== 'list')) {\n      return null;\n    }\n\n    return cartesianProduct(iterationContexts).map(ctx => {\n      if (!isArray(ctx)) {\n        ctx = [ ctx ];\n      }\n\n      return Object.assign({}, context, ...ctx);\n    });\n  };\n\n  // Name kw<\"in\"> Expr\n  case 'InExpression': return (context) => {\n    return extractValue(context, args[0], args[2]);\n  };\n\n  case 'SpecialType': throw notImplemented('SpecialType');\n\n  case 'InstanceOfExpression': return tag((context) => {\n\n    const a = args[0](context);\n    const b = args[3](context);\n\n    return a instanceof b;\n  }, Test('boolean'));\n\n  case 'every': return tag((context) => {\n    return (_contexts, _condition) => {\n      const contexts = _contexts(context);\n\n      if (getType(contexts) !== 'list') {\n        return contexts;\n      }\n\n      return contexts.every(ctx => isTruthy(_condition(ctx)));\n    };\n\n  }, Test('boolean'));\n\n  case 'some': return tag((context) => {\n    return (_contexts, _condition) => {\n      const contexts = _contexts(context);\n\n      if (getType(contexts) !== 'list') {\n        return contexts;\n      }\n\n      return contexts.some(ctx => isTruthy(_condition(ctx)));\n    };\n  }, Test('boolean'));\n\n  case 'NumericLiteral': return tag((_context) => input.includes('.') ? parseFloat(input) : parseInt(input), 'number');\n\n  case 'BooleanLiteral': return tag((_context) => input === 'true' ? true : false, 'boolean');\n\n  case 'StringLiteral': return tag((_context) => parseString(input), 'string');\n\n  case 'PositionalParameters': return (context) => args.map(arg => arg(context));\n\n  case 'NamedParameter': return (context) => {\n\n    const name = args[0];\n    const value = args[1](context);\n\n    return [ name, value ];\n  };\n\n  case 'NamedParameters': return (context) => args.reduce((args, arg) => {\n    const [ name, value ] = arg(context);\n\n    args[name] = value;\n\n    return args;\n  }, {});\n\n  case 'DateTimeConstructor': return (context) => {\n    return getBuiltin(input, context);\n  };\n\n  case 'DateTimeLiteral': return (context) => {\n\n    // AtLiteral\n    if (args.length === 1) {\n      return args[0](context);\n    }\n\n    // FunctionInvocation\n    else {\n      const wrappedFn = wrapFunction(args[0](context));\n\n      // TODO(nikku): indicate as error\n      // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n\n      if (!wrappedFn) {\n        return null;\n      }\n\n      const contextOrArgs = args[2](context);\n\n      return wrappedFn.invoke(contextOrArgs);\n    }\n\n  };\n\n  case 'AtLiteral': return (context) => {\n\n    const wrappedFn = wrapFunction(getBuiltin('@', context));\n\n    // TODO(nikku): indicate as error\n    // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n\n    if (!wrappedFn) {\n      return null;\n    }\n\n    return wrappedFn.invoke([ args[0](context) ]);\n  };\n\n  case 'FunctionInvocation': return (context) => {\n\n    const wrappedFn = wrapFunction(args[0](context));\n\n    // TODO(nikku): indicate error at node\n    // throw new Error(`Failed to evaluate ${input}: Target is not a function`);\n\n    if (!wrappedFn) {\n      return null;\n    }\n\n    const contextOrArgs = args[2](context);\n\n    return wrappedFn.invoke(contextOrArgs);\n  };\n\n  case 'IfExpression': return (function() {\n\n    const ifCondition = args[1];\n\n    const thenValue = args[3];\n    const elseValue = args[5];\n\n    const type = coalecenseTypes(thenValue, elseValue);\n\n    return tag((context) => {\n\n      if (isTruthy(ifCondition(context))) {\n        return thenValue(context);\n      } else {\n        return elseValue ? elseValue(context) : null;\n      }\n    }, type);\n\n  })();\n\n  case 'Parameters': return args.length === 3 ? args[1] : (_context) => [];\n\n  case 'Comparison': return (context) => {\n\n    const operator = args[1];\n\n    // expression !compare kw<\"in\"> PositiveUnaryTest |\n    // expression !compare kw<\"in\"> !unaryTest \"(\" PositiveUnaryTests \")\"\n    if (operator === 'in') {\n      return compareIn(args[0](context), (args[3] || args[2])(context));\n    }\n\n    // expression !compare kw<\"between\"> expression kw<\"and\"> expression\n    if (operator === 'between') {\n\n      const start = args[2](context);\n      const end = args[4](context);\n\n      if (start === null || end === null) {\n        return null;\n      }\n\n      return createRange(start, end).includes(args[0](context));\n    }\n\n    // expression !compare CompareOp<\"=\" | \"!=\"> expression |\n    // expression !compare CompareOp<Gt | Gte | Lt | Lte> expression |\n    const left = args[0](context);\n    const right = args[2](context);\n\n    const test = operator()(right);\n\n    return compareValue(test, left);\n  };\n\n  case 'QuantifiedExpression': return (context) => {\n\n    const testFn = args[0](context);\n\n    const contexts = args[1];\n\n    const condition = args[3];\n\n    return testFn(contexts, condition);\n  };\n\n  // DMN 1.2 - 10.3.2.14\n  // kw<\"for\"> commaSep1<InExpression<IterationContext>> kw<\"return\"> expression\n  case 'ForExpression': return (context) => {\n    const extractor = args[args.length - 1];\n\n    const iterationContexts = args[1](context);\n\n    if (getType(iterationContexts) !== 'list') {\n      return iterationContexts;\n    }\n\n    const partial = [];\n\n    for (const ctx of iterationContexts) {\n\n      partial.push(extractor({\n        ...ctx,\n        partial\n      }));\n    }\n\n    return partial;\n  };\n\n  case 'ArithmeticExpression': return (function() {\n\n    // binary expression (a + b)\n    if (args.length === 3) {\n      const [ a, op, b ] = args;\n\n      return tag((context) => {\n        return op(context)(a, b);\n      }, coalecenseTypes(a, b));\n    }\n\n    // unary expression (-b)\n    if (args.length === 2) {\n      const [ op, value ] = args;\n\n      return tag((context) => {\n\n        return op(context)(() => 0, value);\n      }, value.type);\n    }\n  })();\n\n  case 'PositiveUnaryTest': return args[0];\n\n  case 'ParenthesizedExpression': return args[1];\n\n  case 'PathExpression': return (context) => {\n\n    const pathTarget = args[0](context);\n    const pathProp = args[1];\n\n    if (isArray(pathTarget)) {\n      return pathTarget.map(pathProp);\n    } else {\n      return pathProp(pathTarget);\n    }\n  };\n\n  // expression !filter \"[\" expression \"]\"\n  case 'FilterExpression': return (context) => {\n\n    const target = args[0](context);\n\n    const filterFn = args[2];\n\n    const filterTarget = isArray(target) ? target : [ target ];\n\n    // null[..]\n    if (target === null) {\n      return null;\n    }\n\n    // a[variable=number]\n    if (typeof filterFn.type === 'undefined') {\n      try {\n        const value = filterFn(context);\n\n        if (isNumber(value)) {\n          filterFn.type = 'number';\n        }\n      } catch (err) {\n\n        // ignore\n      }\n    }\n\n    // a[1]\n    if (filterFn.type === 'number') {\n      const idx = filterFn(context);\n\n      const value = filterTarget[idx < 0 ? filterTarget.length + idx : idx - 1];\n\n      if (typeof value === 'undefined') {\n        return null;\n      } else {\n        return value;\n      }\n    }\n\n    // a[true]\n    if (filterFn.type === 'boolean') {\n      if (filterFn(context)) {\n        return filterTarget;\n      } else {\n        return [];\n      }\n    }\n\n    if (filterFn.type === 'string') {\n\n      const value = filterFn(context);\n\n      return filterTarget.filter(el => el === value);\n    }\n\n    // a[test]\n    return filterTarget.map(el => {\n\n      const iterationContext = {\n        ...context,\n        item: el,\n        ...el\n      };\n\n      let result = filterFn(iterationContext);\n\n      // test is fn(val) => boolean SimpleUnaryTest\n      if (typeof result === 'function') {\n        result = result(el);\n      }\n\n      if (result instanceof Range) {\n        result = result.includes(el);\n      }\n\n      if (result === true) {\n        return el;\n      }\n\n      return result;\n    }).filter(isTruthy);\n  };\n\n  case 'SimplePositiveUnaryTest': return tag((context) => {\n\n    // <Interval>\n    if (args.length === 1) {\n      return args[0](context);\n    }\n\n    // <CompareOp> <Expr>\n    return args[0](context)(args[1](context));\n  }, 'test');\n\n  case 'List': return (context) => {\n    return args.slice(1, -1).map(arg => arg(context));\n  };\n\n  case 'Interval': return tag((context) => {\n\n    const left = args[1](context);\n    const right = args[2](context);\n\n    const startIncluded = left !== null && args[0] === '[';\n    const endIncluded = right !== null && args[3] === ']';\n\n    return createRange(left, right, startIncluded, endIncluded);\n  }, Test('boolean'));\n\n  case 'PositiveUnaryTests':\n  case 'Expressions': return (context) => {\n    return args.map(a => a(context));\n  };\n\n  case 'Expression': return (context) => {\n    return args[0](context);\n  };\n\n  case 'UnaryTests': return (context) => {\n\n    return (value = null) => {\n\n      const negate = args[0] === 'not';\n\n      const tests = negate ? args.slice(2, -1) : args;\n\n      const matches = tests.map(test => test(context)).flat(1).map(test => {\n\n        if (isArray(test)) {\n          return test.includes(value);\n        }\n\n        if (test === null) {\n          return null;\n        }\n\n        if (typeof test === 'boolean') {\n          return test;\n        }\n\n        return compareValue(test, value);\n      }).reduce(combineResult, undefined);\n\n      return matches === null ? null : (negate ? !matches : matches);\n    };\n  };\n\n  default: return node.name;\n  }\n}\n\nfunction getBuiltin(name, _context) {\n  return getFromContext(name, builtins);\n}\n\nfunction extractValue(context, prop, _target) {\n\n  const target = _target(context);\n\n  if ([ 'list', 'range' ].includes(getType(target))) {\n    return target.map(t => (\n      { [prop]: t }\n    ));\n  }\n\n  return null;\n}\n\nfunction compareIn(value, tests) {\n\n  if (!isArray(tests)) {\n\n    if (getType(tests) === 'nil') {\n      return null;\n    }\n\n    tests = [ tests ];\n  }\n\n  return tests.some(\n    test => compareValue(test, value)\n  );\n}\n\nfunction compareValue(test, value) {\n\n  if (typeof test === 'function') {\n    return test(value);\n  }\n\n  if (test instanceof Range) {\n    return test.includes(value);\n  }\n\n  return equals(test, value);\n}\n\n\nconst chars = Array.from(\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n);\n\nfunction isTyped(type, values) {\n  return (\n    values.some(e => getType(e) === type) &&\n    values.every(e => e === null || getType(e) === type)\n  );\n}\n\nconst nullRange = new Range({\n  start: null,\n  end: null,\n  'start included': false,\n  'end included': false,\n  map() {\n    return [];\n  },\n  includes() {\n    return null;\n  }\n});\n\nfunction createRange(start, end, startIncluded = true, endIncluded = true) : Range {\n\n  if (isTyped('string', [ start, end ])) {\n    return createStringRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (isTyped('number', [ start, end ])) {\n    return createNumberRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (isTyped('duration', [ start, end ])) {\n    return createDurationRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (isTyped('time', [ start, end ])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (isTyped('date time', [ start, end ])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (isTyped('date', [ start, end ])) {\n    return createDateTimeRange(start, end, startIncluded, endIncluded);\n  }\n\n  if (start === null && end === null) {\n    return nullRange;\n  }\n\n  throw new Error(`unsupported range: ${start}..${end}`);\n}\n\nfunction noopMap() {\n  return () => {\n    throw new Error('unsupported range operation: map');\n  };\n}\n\nfunction valuesMap(values) {\n  return (fn) => values.map(fn);\n}\n\nfunction valuesIncludes(values) {\n  return (value) => values.includes(value);\n}\n\nfunction numberMap(start, end, startIncluded, endIncluded) {\n\n  const direction = start > end ? -1 : 1;\n\n  return (fn) => {\n\n    const result = [];\n\n    for (let i = start;; i += direction) {\n\n      if (i === 0 && !startIncluded) {\n        continue;\n      }\n\n      if (i === end && !endIncluded) {\n        break;\n      }\n\n      result.push(fn(i));\n\n      if (i === end) {\n        break;\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction includesStart(n, inclusive) {\n\n  if (inclusive) {\n    return (value) => n <= value;\n  } else {\n    return (value) => n < value;\n  }\n}\n\nfunction includesEnd(n, inclusive) {\n\n  if (inclusive) {\n    return (value) => n >= value;\n  } else {\n    return (value) => n > value;\n  }\n}\n\nfunction anyIncludes(start, end, startIncluded, endIncluded, conversion = (v) => v) {\n\n  let tests = [];\n\n  if (start === null && end === null) {\n    return () => null;\n  }\n\n  if (start !== null && end !== null) {\n    if (start > end) {\n      tests = [\n        includesStart(end, endIncluded),\n        includesEnd(start, startIncluded)\n      ];\n    } else {\n      tests = [\n        includesStart(start, startIncluded),\n        includesEnd(end, endIncluded)\n      ];\n    }\n  } else if (end !== null) {\n    tests = [\n      includesEnd(end, endIncluded)\n    ];\n  } else if (start !== null) {\n    tests = [\n      includesStart(start, startIncluded)\n    ];\n  }\n\n  return (value) => value === null ? null : tests.every(t => t(conversion(value)));\n}\n\nfunction createStringRange(start, end, startIncluded = true, endIncluded = true) {\n\n  if (start !== null && !chars.includes(start)) {\n    throw new Error('illegal range start: ' + start);\n  }\n\n  if (end !== null && !chars.includes(end)) {\n    throw new Error('illegal range end: ' + end);\n  }\n\n  let values;\n\n  if (start !== null && end !== null) {\n\n    let startIdx = chars.indexOf(start);\n    let endIdx = chars.indexOf(end);\n\n    const direction = startIdx > endIdx ? -1 : 1;\n\n    if (startIncluded === false) {\n      startIdx += direction;\n    }\n\n    if (endIncluded === false) {\n      endIdx -= direction;\n    }\n\n    values = chars.slice(startIdx, endIdx + 1);\n  }\n\n  const map = values ? valuesMap(values) : noopMap();\n  const includes = values ? valuesIncludes(values) : anyIncludes(start, end, startIncluded, endIncluded);\n\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\n\nfunction createNumberRange(start, end, startIncluded, endIncluded) {\n  const map = start !== null && end !== null ? numberMap(start, end, startIncluded, endIncluded) : noopMap();\n  const includes = anyIncludes(start, end, startIncluded, endIncluded);\n\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\n\n/**\n * @param {Duration} start\n * @param {Duration} end\n * @param {boolean} startIncluded\n * @param {boolean} endIncluded\n */\nfunction createDurationRange(start, end, startIncluded, endIncluded) {\n\n  const toMillis = (d) => d ? Duration.fromDurationLike(d).toMillis() : null;\n\n  const map = noopMap();\n  const includes = anyIncludes(toMillis(start), toMillis(end), startIncluded, endIncluded, toMillis);\n\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n\n}\n\n\nfunction createDateTimeRange(start, end, startIncluded, endIncluded) {\n  const map = noopMap();\n  const includes = anyIncludes(start, end, startIncluded, endIncluded);\n\n  return new Range({\n    start,\n    end,\n    'start included': startIncluded,\n    'end included': endIncluded,\n    map,\n    includes\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction cartesianProduct(arrays: any[]) {\n\n  if (arrays.some(arr => getType(arr) === 'nil')) {\n    return null;\n  }\n\n  const f = (a, b) => [].concat(...a.map(d => b.map(e => [].concat(d, e))));\n  const cartesian = (a?, b?, ...c) => (b ? cartesian(f(a, b), ...c) : a || []);\n\n  return cartesian(...arrays);\n}\n\n\nfunction coalecenseTypes(a, b) {\n\n  if (!b) {\n    return a.type;\n  }\n\n  if (a.type === b.type) {\n    return a.type;\n  }\n\n  return 'any';\n}\n\ntype ContextFn<T> = (context: InterpreterContext) => T;\ntype TaggedFn = {\n  type: string\n};\n\nfunction tag<Z, T extends ContextFn<Z>>(fn: T, type: string) : T & TaggedFn {\n\n  return Object.assign(fn, {\n    type,\n    toString() {\n      return `TaggedFunction[${type}] ${Function.prototype.toString.call(fn)}`;\n    }\n  });\n}\n\nfunction combineResult(result, match) {\n\n  if (!result) {\n    return match;\n  }\n\n  return result;\n}\n\nfunction isTruthy(obj) {\n  return obj !== false && obj !== null;\n}\n\nfunction Test(type: string): string {\n  return `Test<${type}>`;\n}\n\n/**\n * @param {Function} fn\n * @param {string[]} [parameterNames]\n *\n * @return {FunctionWrapper}\n */\nfunction wrapFunction(fn, parameterNames = null) {\n\n  if (!fn) {\n    return null;\n  }\n\n  if (fn instanceof FunctionWrapper) {\n    return fn;\n  }\n\n  if (fn instanceof Range) {\n    return new FunctionWrapper((value) => fn.includes(value), [ 'value' ]);\n  }\n\n  if (typeof fn !== 'function') {\n    return null;\n  }\n\n  return new FunctionWrapper(fn, parameterNames || parseParameterNames(fn));\n}\n\nfunction parseString(str: string) {\n\n  if (str.startsWith('\"')) {\n    str = str.slice(1);\n  }\n\n  if (str.endsWith('\"')) {\n    str = str.slice(0, -1);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return str.replace(/(\\\\\")|(\\\\\\\\)|(\\\\u[a-fA-F0-9]{5,6})|((?:\\\\u[a-fA-F0-9]{1,4})+)/ig, function(substring: string, ...groups: any[]) {\n\n    const [\n      quotes,\n      escape,\n      codePoint,\n      charCodes\n    ] = groups;\n\n    if (quotes) {\n      return '\"';\n    }\n\n    if (escape) {\n      return '\\\\';\n    }\n\n    const escapePattern = /\\\\u([a-fA-F0-9]+)/ig;\n\n    if (codePoint) {\n      const codePointMatch = escapePattern.exec(codePoint);\n\n      return String.fromCodePoint(parseInt(codePointMatch[1], 16));\n    }\n\n    if (charCodes) {\n      const chars = [];\n\n      let charCodeMatch;\n\n      while ((charCodeMatch = escapePattern.exec(substring)) !== null) {\n        chars.push(parseInt(charCodeMatch[1], 16));\n      }\n\n      return String.fromCharCode(...chars);\n    }\n\n    throw new Error('illegal match');\n  });\n}\n\n\ntype LintError = {\n  from: number,\n  to: number,\n  message: string\n};\n\nexport function lintError(nodeRef: SyntaxNodeRef): LintError {\n\n  const node = nodeRef.node;\n  const parent = node.parent;\n\n  if (node.from !== node.to) {\n    return {\n      from: node.from,\n      to: node.to,\n      message: `Unrecognized token in <${parent.name}>`\n    };\n  }\n\n  const next = findNext(node);\n\n  if (next) {\n    return {\n      from: node.from,\n      to: next.to,\n      message: `Unrecognized token <${next.name}> in <${parent.name}>`\n    };\n  } else {\n    const unfinished = parent.enterUnfinishedNodesBefore(nodeRef.to);\n\n    return {\n      from: node.from,\n      to: node.to,\n      message: `Incomplete <${ (unfinished || parent).name }>`\n    };\n  }\n}\n\nfunction findNext(nodeRef: SyntaxNodeRef) : SyntaxNode | null {\n\n  const node = nodeRef.node;\n\n  let next, parent = node;\n\n  do {\n    next = parent.nextSibling;\n\n    if (next) {\n      return next;\n    }\n\n    parent = parent.parent;\n  } while (parent);\n\n  return null;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}