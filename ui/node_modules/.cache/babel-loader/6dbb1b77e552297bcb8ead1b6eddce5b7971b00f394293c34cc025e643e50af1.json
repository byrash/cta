{"ast":null,"code":"import { ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { evaluate as evaluate$1 } from 'feelin';\nimport { closeBrackets } from '@codemirror/autocomplete';\nimport { defaultKeymap } from '@codemirror/commands';\nimport { foldNodeProp, LRLanguage, foldInside, LanguageSupport, syntaxTree, bracketMatching, indentOnInput } from '@codemirror/language';\nimport { linter, setDiagnosticsEffect } from '@codemirror/lint';\nimport { EditorState } from '@codemirror/state';\nimport { EditorView, tooltips, keymap, lineNumbers } from '@codemirror/view';\nimport { parser as parser$2 } from '@lezer/markdown';\nimport { parser as parser$1 } from 'lezer-feel';\nimport { parseMixed } from '@lezer/common';\nimport { cmFeelLinter } from '@bpmn-io/feel-lint';\nimport { darkTheme, lightTheme } from '@bpmn-io/cm-theme';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Feel = 1,\n  FeelBlock = 2,\n  SimpleTextBlock = 3;\n\n/* global console */\n\nconst CHAR_TABLE = {\n  '{': 123,\n  '}': 125\n};\nconst isClosingFeelScope = function (input) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isReadingCloseCurrent = input.peek(offset) === CHAR_TABLE['}'];\n  const isReadingCloseAhead = input.peek(offset + 1) === CHAR_TABLE['}'];\n  const isReadingClose = isReadingCloseCurrent && isReadingCloseAhead;\n  return isReadingClose || input.peek(offset) === -1;\n};\nconst feelBlock = new ExternalTokenizer((input, stack) => {\n  let lookAhead = 0;\n\n  // check if we haven't reached the end of a templating tag\n  while (!isClosingFeelScope(input, lookAhead)) {\n    lookAhead++;\n  }\n  if (lookAhead > 0) {\n    input.advance(lookAhead);\n    input.acceptToken(FeelBlock);\n  }\n});\nconst isClosingTextScope = function (input) {\n  let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const isReadingOpenCurrent = input.peek(offset) === CHAR_TABLE['{'];\n  const isReadingOpenAhead = input.peek(offset + 1) === CHAR_TABLE['{'];\n  const isReadOpen = isReadingOpenCurrent && isReadingOpenAhead;\n  return isReadOpen || input.peek(offset) === -1;\n};\nconst simpleTextBlock = new ExternalTokenizer((input, stack) => {\n  let lookAhead = 0;\n\n  // check if we haven't reached the start of a templating tag\n  while (!isClosingTextScope(input, lookAhead)) {\n    lookAhead++;\n  }\n  if (lookAhead > 0) {\n    input.advance(lookAhead);\n    input.acceptToken(SimpleTextBlock);\n  }\n});\n\n// Anytime this tokenizer is run, simply tag the rest of the input as FEEL\nconst feel = new ExternalTokenizer((input, stack) => {\n  let lookAhead = 0;\n  while (input.peek(lookAhead) !== -1) {\n    lookAhead++;\n  }\n  if (lookAhead > 0) {\n    input.advance(lookAhead);\n    input.acceptToken(Feel);\n  }\n});\nconst feelersHighlighting = styleTags({\n  ConditionalSpanner: tags.special(tags.bracket),\n  ConditionalSpannerClose: tags.special(tags.bracket),\n  ConditionalSpannerCloseNl: tags.special(tags.bracket),\n  LoopSpanner: tags.special(tags.bracket),\n  LoopSpannerClose: tags.special(tags.bracket),\n  LoopSpannerCloseNl: tags.special(tags.bracket),\n  EmptyInsert: tags.special(tags.bracket),\n  Insert: tags.special(tags.bracket)\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$bOQOaOOOfOXO'#CbOOO`'#Cm'#CmOqOWO'#CcOvOWO'#CfOOO`'#Cp'#CpOOO`'#Ci'#CiO{OaO'#ClO!jOSOOQOOOOOO!oOPO,58{O!tOXO,58|OOO`,58|,58|O!|OQO,58}O#ROQO,59QOOO`-E6g-E6gOOO`1G.g1G.gO#WOPO1G.gOOO`1G.h1G.hO#]OaO1G.iO#qOaO1G.lOOO`7+$R7+$RO$VOPO7+$TO$_OPO7+$WOOO`<<Go<<GoOOO`<<Gr<<Gr\",\n  stateData: \"$g~ORUO_WObPOeROgSO^`P~OQYO_ZOc[O~OQ]O~OQ^O~ORUObPOeROgSO^`XW`XX`XZ`X[`X~OPXO~Oc`O~OQaOcbO~OfcO~OfdO~OceO~ORUObPOeROgSOW`PX`P~ORUObPOeROgSOZ`P[`P~OWhOXhO~OZiO[iO~O\",\n  goto: \"!ZePPPPPfflPPlPPrPPz!TPP!TXQOVcdXTOVcdUVOcdR_VQXOQfcRgdXUOVcd\",\n  nodeNames: \"âš  Feel FeelBlock SimpleTextBlock Feelers Insert EmptyInsert ConditionalSpanner ConditionalSpannerClose ConditionalSpannerCloseNl LoopSpanner LoopSpannerClose LoopSpannerCloseNl\",\n  maxTerm: 23,\n  propSources: [feelersHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 1,\n  tokenData: \"%X~RR!_!`[#o#pa#q#r$r~aO_~~dP#o#pg~lQb~str!P!Q!{~uQ#]#^{#`#a!^~!OP#Y#Z!R~!UPpq!X~!^Oe~~!aP#c#d!d~!gP#c#d!j~!mP#d#e!p~!sPpq!v~!{Og~~#OQ#]#^#U#`#a#u~#XP#Y#Z#[~#_P#q#r#b~#eP#q#r#h~#mPW~YZ#p~#uOX~~#xP#c#d#{~$OP#c#d$R~$UP#d#e$X~$[P#q#r$_~$bP#q#r$e~$jPZ~YZ$m~$rO[~R$uP#q#r$xR%PPcPfQYZ%SQ%XOfQ\",\n  tokenizers: [0, 1, feel, feelBlock, simpleTextBlock],\n  topRules: {\n    \"Feelers\": [0, 4]\n  },\n  tokenPrec: 0\n});\nfunction buildSimpleTree(parseTree, templateString) {\n  const stack = [{\n    children: []\n  }];\n  const isLeafNode = node => ['SimpleTextBlock', 'Feel', 'FeelBlock'].includes(node.type.name);\n  parseTree.iterate({\n    enter: (node, pos, type) => {\n      const nodeRepresentation = {\n        name: node.type.name,\n        children: []\n      };\n      if (isLeafNode(node)) {\n        nodeRepresentation.content = templateString.slice(node.from, node.to);\n      }\n      stack.push(nodeRepresentation);\n    },\n    leave: (node, pos, type) => {\n      const result = stack.pop();\n      const parent = stack[stack.length - 1];\n      result.parent = parent;\n      parent.children.push(result);\n    }\n  });\n  return stack[0].children[0];\n}\n\n/**\r\n * @typedef {object} EvaluationOptions\r\n * @property {boolean} [debug=false] - whether to enable debug mode, which displays errors inline instead of throwing them\r\n * @property {function} [buildDebugString=(e) => `{{ ${e.message.toLowerCase()} }}`] - function that takes an error and returns the string to display in debug mode\r\n * @property {boolean} [strict=false] - whether to expect strict data types out of our FEEL expression, e.g. boolean for conditionals\r\n * @property {function} [sanitizer] - function to sanitize individual FEEL evaluation results\r\n */\n\n/**\r\n * @param {string} templateString - the template string to evaluate\r\n * @param {object} [context={}] - the context object to evaluate the template string against\r\n * @param {EvaluationOptions} [options={}] - options to configure the evaluation\r\n * @return {string} the evaluated template string\r\n */\nconst evaluate = function (templateString) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    debug = false,\n    strict = false,\n    buildDebugString = e => \"{{ \".concat(e.message.toLowerCase(), \" }}\"),\n    sanitizer\n  } = options;\n  const parseTree = parser.parse(templateString);\n  const simpleTreeRoot = buildSimpleTree(parseTree, templateString);\n  const evaluateNode = buildNodeEvaluator({\n    debug,\n    strict,\n    buildDebugString,\n    sanitizer\n  });\n  return evaluateNode(simpleTreeRoot, enhanceContext(context, null));\n};\n\n/**\r\n * @param {EvaluationOptions} options - options to configure the evaluation\r\n * @return {function} a function that takes a node and context and evaluates it\r\n */\nconst buildNodeEvaluator = options => {\n  const {\n    debug,\n    strict,\n    buildDebugString,\n    sanitizer\n  } = options;\n  const errorHandler = error => {\n    if (debug) {\n      return buildDebugString(error);\n    }\n    throw error;\n  };\n  const evaluateNodeValue = function (node) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    switch (node.name) {\n      case 'SimpleTextBlock':\n        return node.content;\n      case 'Insert':\n        {\n          const feel = node.children[0].content;\n          try {\n            const result = evaluate$1(\"string(\".concat(feel, \")\"), context);\n            return sanitizer ? sanitizer(result) : result;\n          } catch {\n            return errorHandler(new Error(\"FEEL expression \".concat(feel, \" couldn't be evaluated\")));\n          }\n        }\n      case 'EmptyInsert':\n        return '';\n      case 'Feel':\n      case 'FeelBlock':\n        {\n          const feel = node.content;\n          try {\n            const result = evaluate$1(\"string(\".concat(feel, \")\"), context);\n            return sanitizer ? sanitizer(result) : result;\n          } catch (e) {\n            return errorHandler(new Error(\"FEEL expression \".concat(feel, \" couldn't be evaluated\")));\n          }\n        }\n      case 'Feelers':\n        return node.children.map(child => evaluateNode(child, context)).join('');\n      case 'ConditionalSpanner':\n        {\n          const feel = node.children[0].content;\n          let shouldRender;\n          try {\n            shouldRender = evaluate$1(feel, context);\n          } catch {\n            return errorHandler(new Error(\"FEEL expression \".concat(feel, \" couldn't be evaluated\")));\n          }\n          if (strict && typeof shouldRender !== 'boolean') {\n            return errorHandler(new Error(\"FEEL expression \".concat(feel, \" expected to evaluate to a boolean\")));\n          }\n          if (shouldRender) {\n            const children = node.children.slice(1, node.children.length - 1);\n            const innerRender = children.map(child => evaluateNode(child, context)).join('');\n            const closeNode = node.children[node.children.length - 1];\n            const shouldAddNewline = closeNode.name.endsWith('Nl') && !innerRender.endsWith('\\n');\n            return innerRender + (shouldAddNewline ? '\\n' : '');\n          }\n          return '';\n        }\n      case 'LoopSpanner':\n        {\n          const feel = node.children[0].content;\n          let loopArray;\n          try {\n            loopArray = evaluate$1(feel, context);\n          } catch {\n            return errorHandler(new Error(\"FEEL expression \".concat(feel, \" couldn't be evaluated\")));\n          }\n          if (!Array.isArray(loopArray)) {\n            if (strict) {\n              return errorHandler(new Error(\"FEEL expression \".concat(feel, \" expected to evaluate to an array\")));\n            }\n\n            // if not strict, we treat undefined/null as an empty array\n            else if (loopArray === undefined || loopArray === null) {\n              loopArray = [];\n            }\n\n            // if not strict, we treat a single item as an array with one item\n            else {\n              loopArray = [loopArray];\n            }\n          }\n          const childrenToLoop = node.children.slice(1, node.children.length - 1);\n          const evaluateChildren = (arrayElement, parentContext) => {\n            const childContext = enhanceContext(arrayElement, parentContext);\n            return childrenToLoop.map(child => evaluateNode(child, childContext)).join('');\n          };\n          const innerRender = loopArray.map(arrayElement => evaluateChildren(arrayElement, context)).join('');\n          const closeNode = node.children[node.children.length - 1];\n          const shouldAddNewline = closeNode.name.endsWith('Nl') && !innerRender.endsWith('\\n');\n          return innerRender + (shouldAddNewline ? '\\n' : '');\n        }\n    }\n  };\n  const evaluateNode = function (node) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    try {\n      return evaluateNodeValue(node, context);\n    } catch (error) {\n      return errorHandler(error);\n    }\n  };\n  return evaluateNode;\n};\nconst enhanceContext = (context, parentContext) => {\n  if (typeof context === 'object') {\n    return {\n      this: context,\n      parent: parentContext,\n      ...context,\n      _this_: context,\n      _parent_: parentContext\n    };\n  }\n  return {\n    this: context,\n    parent: parentContext,\n    _this_: context,\n    _parent_: parentContext\n  };\n};\nconst foldMetadata = {\n  ConditionalSpanner: foldInside,\n  LoopSpanner: foldInside\n};\nfunction createMixedLanguage() {\n  let hostLanguage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  const _mixedParser = parser.configure({\n    wrap: parseMixed(node => {\n      if (node.name == 'Feel' || node.name == 'FeelBlock') {\n        return {\n          parser: parser$1\n        };\n      }\n      if (hostLanguage && node.name == 'SimpleTextBlock') {\n        return {\n          parser: hostLanguage\n        };\n      }\n      return null;\n    }),\n    props: [foldNodeProp.add(foldMetadata)]\n  });\n  return LRLanguage.define({\n    parser: _mixedParser\n  });\n}\nconst createFeelersLanguageSupport = hostLanguageParser => new LanguageSupport(createMixedLanguage(hostLanguageParser), []);\n\n/**\r\n * Create warnings for empty inserts in the given tree.\r\n *\r\n * @param {Tree} syntaxTree\r\n * @returns {LintMessage[]} array of syntax errors\r\n */\nfunction lintEmptyInserts(syntaxTree) {\n  const lintMessages = [];\n  syntaxTree.iterate({\n    enter: node => {\n      if (node.type.name === 'EmptyInsert') {\n        lintMessages.push({\n          from: node.from,\n          to: node.to,\n          severity: 'warning',\n          message: 'this insert is empty and will be ignored',\n          type: 'emptyInsert'\n        });\n      }\n    }\n  });\n  return lintMessages;\n}\n\n/**\r\n * Generates lint messages for the given syntax tree.\r\n *\r\n * @param {Tree} syntaxTree\r\n * @returns {LintMessage[]} array of all lint messages\r\n */\nfunction lintAll(syntaxTree) {\n  const lintMessages = [...lintEmptyInserts(syntaxTree)];\n  return lintMessages;\n}\n\n/**\r\n * CodeMirror extension that provides linting for FEEL expressions.\r\n *\r\n * @param {EditorView} editorView\r\n * @returns {Source} CodeMirror linting source\r\n */\nfunction cmFeelersLinter() {\n  const lintFeel = cmFeelLinter();\n  return editorView => {\n    const feelMessages = lintFeel(editorView);\n\n    // don't lint if the Editor is empty\n    if (editorView.state.doc.length === 0) {\n      return [];\n    }\n    const tree = syntaxTree(editorView.state);\n    const feelersMessages = lintAll(tree);\n    return [...feelMessages, ...feelersMessages.map(message => ({\n      ...message,\n      source: 'feelers linter'\n    }))];\n  };\n}\nvar lint = linter(cmFeelersLinter());\n\n/**\r\n * Creates a Feelers editor in the supplied container.\r\n *\r\n * @param {Object} config Configuration options for the Feelers editor.\r\n * @param {DOMNode} [config.container] The DOM node that will contain the editor.\r\n * @param {DOMNode|String} [config.tooltipContainer] The DOM node or CSS selector string for the tooltip container.\r\n * @param {String} [config.hostLanguage] The host language for the editor (e.g., 'markdown').\r\n * @param {Object} [config.hostLanguageParser] A custom parser for the host language.\r\n * @param {Function} [config.onChange] Callback function that is called when the editor's content changes.\r\n * @param {Function} [config.onKeyDown] Callback function that is called when a key is pressed within the editor.\r\n * @param {Function} [config.onLint] Callback function that is called when linting messages are available.\r\n * @param {Object} [config.contentAttributes] Additional attributes to set on the editor's content element.\r\n * @param {Boolean} [config.readOnly] Set to true to make the editor read-only.\r\n * @param {String} [config.value] Initial value of the editor.\r\n * @param {Boolean} [config.enableGutters] Set to true to enable gutter decorations (e.g., line numbers).\r\n * @param {Boolean} [config.darkMode] Set to true to use the dark theme for the editor.\r\n *\r\n * @returns {Object} editor An instance of the FeelersEditor class.\r\n */\nfunction FeelersEditor(_ref) {\n  let {\n    container,\n    tooltipContainer,\n    hostLanguage,\n    hostLanguageParser,\n    onChange = () => {},\n    onKeyDown = () => {},\n    onLint = () => {},\n    contentAttributes = {},\n    readOnly = false,\n    value = '',\n    enableGutters = false,\n    singleLine = false,\n    darkMode = false\n  } = _ref;\n  const changeHandler = EditorView.updateListener.of(update => {\n    if (update.docChanged) {\n      onChange(update.state.doc.toString());\n    }\n  });\n  const lintHandler = EditorView.updateListener.of(update => {\n    const diagnosticEffects = update.transactions.flatMap(t => t.effects).filter(effect => effect.is(setDiagnosticsEffect));\n    if (!diagnosticEffects.length) {\n      return;\n    }\n    const messages = diagnosticEffects.flatMap(effect => effect.value);\n    onLint(messages);\n  });\n  const contentAttributesExtension = EditorView.contentAttributes.of(contentAttributes);\n  const keyHandler = EditorView.domEventHandlers({\n    keydown: onKeyDown\n  });\n  if (typeof tooltipContainer === 'string') {\n    // eslint-disable-next-line no-undef\n    tooltipContainer = document.querySelector(tooltipContainer);\n  }\n  const tooltipLayout = tooltipContainer ? tooltips({\n    tooltipSpace: function () {\n      return tooltipContainer.getBoundingClientRect();\n    }\n  }) : [];\n  const _getHostLanguageParser = hostLanguage => {\n    switch (hostLanguage) {\n      case 'markdown':\n        return parser$2;\n      default:\n        return null;\n    }\n  };\n  const feelersLanguageSupport = createFeelersLanguageSupport(hostLanguageParser || hostLanguage && _getHostLanguageParser(hostLanguage));\n  const extensions = [bracketMatching(), changeHandler, contentAttributesExtension, closeBrackets(), indentOnInput(), keyHandler, keymap.of([...defaultKeymap]), feelersLanguageSupport, lint, lintHandler, tooltipLayout, darkMode ? darkTheme : lightTheme, ...(enableGutters ? [\n  // todo: adjust folding boundaries first foldGutter(),\n  lineNumbers()] : []), ...(singleLine ? [EditorState.transactionFilter.of(tr => tr.newDoc.lines > 1 ? [] : tr)] : [])];\n  if (readOnly) {\n    extensions.push(EditorView.editable.of(false));\n  }\n  if (singleLine && value) {\n    value = value.toString().split('\\n')[0];\n  }\n  this._cmEditor = new EditorView({\n    state: EditorState.create({\n      doc: value,\n      extensions: extensions\n    }),\n    parent: container\n  });\n  return this;\n}\n\n/**\r\n * Replaces the content of the Editor\r\n *\r\n * @param {String} value\r\n */\nFeelersEditor.prototype.setValue = function (value) {\n  this._cmEditor.dispatch({\n    changes: {\n      from: 0,\n      to: this._cmEditor.state.doc.length,\n      insert: value\n    }\n  });\n};\n\n/**\r\n * Sets the focus in the editor.\r\n */\nFeelersEditor.prototype.focus = function (position) {\n  const cmEditor = this._cmEditor;\n\n  // the Codemirror `focus` method always calls `focus` with `preventScroll`,\n  // so we have to focus + scroll manually\n  cmEditor.contentDOM.focus();\n  cmEditor.focus();\n  if (typeof position === 'number') {\n    const end = cmEditor.state.doc.length;\n    cmEditor.dispatch({\n      selection: {\n        anchor: position <= end ? position : end\n      }\n    });\n  }\n};\n\n/**\r\n * Returns the current selection ranges. If no text is selected, a single\r\n * range with the start and end index at the cursor position will be returned.\r\n *\r\n * @returns {Object} selection\r\n * @returns {Array} selection.ranges\r\n */\nFeelersEditor.prototype.getSelection = function () {\n  return this._cmEditor.state.selection;\n};\nexport { FeelersEditor, buildSimpleTree, evaluate, parser };","map":{"version":3,"names":["ExternalTokenizer","LRParser","styleTags","tags","evaluate","evaluate$1","closeBrackets","defaultKeymap","foldNodeProp","LRLanguage","foldInside","LanguageSupport","syntaxTree","bracketMatching","indentOnInput","linter","setDiagnosticsEffect","EditorState","EditorView","tooltips","keymap","lineNumbers","parser","parser$2","parser$1","parseMixed","cmFeelLinter","darkTheme","lightTheme","Feel","FeelBlock","SimpleTextBlock","CHAR_TABLE","isClosingFeelScope","input","offset","arguments","length","undefined","isReadingCloseCurrent","peek","isReadingCloseAhead","isReadingClose","feelBlock","stack","lookAhead","advance","acceptToken","isClosingTextScope","isReadingOpenCurrent","isReadingOpenAhead","isReadOpen","simpleTextBlock","feel","feelersHighlighting","ConditionalSpanner","special","bracket","ConditionalSpannerClose","ConditionalSpannerCloseNl","LoopSpanner","LoopSpannerClose","LoopSpannerCloseNl","EmptyInsert","Insert","deserialize","version","states","stateData","goto","nodeNames","maxTerm","propSources","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","tokenPrec","buildSimpleTree","parseTree","templateString","children","isLeafNode","node","includes","type","name","iterate","enter","pos","nodeRepresentation","content","slice","from","to","push","leave","result","pop","parent","context","options","debug","strict","buildDebugString","e","concat","message","toLowerCase","sanitizer","parse","simpleTreeRoot","evaluateNode","buildNodeEvaluator","enhanceContext","errorHandler","error","evaluateNodeValue","Error","map","child","join","shouldRender","innerRender","closeNode","shouldAddNewline","endsWith","loopArray","Array","isArray","childrenToLoop","evaluateChildren","arrayElement","parentContext","childContext","this","_this_","_parent_","foldMetadata","createMixedLanguage","hostLanguage","_mixedParser","configure","wrap","props","add","define","createFeelersLanguageSupport","hostLanguageParser","lintEmptyInserts","lintMessages","severity","lintAll","cmFeelersLinter","lintFeel","editorView","feelMessages","state","doc","tree","feelersMessages","source","lint","FeelersEditor","_ref","container","tooltipContainer","onChange","onKeyDown","onLint","contentAttributes","readOnly","value","enableGutters","singleLine","darkMode","changeHandler","updateListener","of","update","docChanged","toString","lintHandler","diagnosticEffects","transactions","flatMap","t","effects","filter","effect","is","messages","contentAttributesExtension","keyHandler","domEventHandlers","keydown","document","querySelector","tooltipLayout","tooltipSpace","getBoundingClientRect","_getHostLanguageParser","feelersLanguageSupport","extensions","transactionFilter","tr","newDoc","lines","editable","split","_cmEditor","create","prototype","setValue","dispatch","changes","insert","focus","position","cmEditor","contentDOM","end","selection","anchor","getSelection"],"sources":["/Users/Shivaji/Workspace/Play/cta/ui/node_modules/feelers/dist/index.mjs"],"sourcesContent":["import { ExternalTokenizer, LRParser } from '@lezer/lr';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { evaluate as evaluate$1 } from 'feelin';\nimport { closeBrackets } from '@codemirror/autocomplete';\nimport { defaultKeymap } from '@codemirror/commands';\nimport { foldNodeProp, LRLanguage, foldInside, LanguageSupport, syntaxTree, bracketMatching, indentOnInput } from '@codemirror/language';\nimport { linter, setDiagnosticsEffect } from '@codemirror/lint';\nimport { EditorState } from '@codemirror/state';\nimport { EditorView, tooltips, keymap, lineNumbers } from '@codemirror/view';\nimport { parser as parser$2 } from '@lezer/markdown';\nimport { parser as parser$1 } from 'lezer-feel';\nimport { parseMixed } from '@lezer/common';\nimport { cmFeelLinter } from '@bpmn-io/feel-lint';\nimport { darkTheme, lightTheme } from '@bpmn-io/cm-theme';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Feel = 1,\n  FeelBlock = 2,\n  SimpleTextBlock = 3;\n\n/* global console */\r\n\r\n\r\nconst CHAR_TABLE = {\r\n  '{': 123,\r\n  '}': 125\r\n};\r\n\r\nconst isClosingFeelScope = (input, offset = 0) => {\r\n\r\n  const isReadingCloseCurrent = input.peek(offset) === CHAR_TABLE['}'];\r\n  const isReadingCloseAhead = input.peek(offset + 1) === CHAR_TABLE['}'];\r\n\r\n  const isReadingClose = isReadingCloseCurrent && isReadingCloseAhead;\r\n\r\n  return isReadingClose || input.peek(offset) === -1;\r\n\r\n};\r\n\r\nconst feelBlock = new ExternalTokenizer((input, stack) => {\r\n\r\n  let lookAhead = 0;\r\n\r\n  // check if we haven't reached the end of a templating tag\r\n  while (!isClosingFeelScope(input, lookAhead)) { lookAhead++; }\r\n\r\n  if (lookAhead > 0) {\r\n    input.advance(lookAhead);\r\n    input.acceptToken(FeelBlock);\r\n  }\r\n\r\n});\r\n\r\nconst isClosingTextScope = (input, offset = 0) => {\r\n  const isReadingOpenCurrent = input.peek(offset) === CHAR_TABLE['{'];\r\n  const isReadingOpenAhead = input.peek(offset + 1) === CHAR_TABLE['{'];\r\n\r\n  const isReadOpen = isReadingOpenCurrent && isReadingOpenAhead;\r\n\r\n  return isReadOpen || input.peek(offset) === -1;\r\n};\r\n\r\n\r\nconst simpleTextBlock = new ExternalTokenizer((input, stack) => {\r\n\r\n  let lookAhead = 0;\r\n\r\n  // check if we haven't reached the start of a templating tag\r\n  while (!isClosingTextScope(input, lookAhead)) { lookAhead++; }\r\n\r\n  if (lookAhead > 0) {\r\n    input.advance(lookAhead);\r\n    input.acceptToken(SimpleTextBlock);\r\n  }\r\n\r\n});\r\n\r\n// Anytime this tokenizer is run, simply tag the rest of the input as FEEL\r\nconst feel = new ExternalTokenizer((input, stack) => {\r\n\r\n  let lookAhead = 0;\r\n\r\n  while (input.peek(lookAhead) !== -1) { lookAhead++; }\r\n\r\n  if (lookAhead > 0) {\r\n    input.advance(lookAhead);\r\n    input.acceptToken(Feel);\r\n  }\r\n\r\n});\n\nconst feelersHighlighting = styleTags({\r\n  ConditionalSpanner: tags.special(tags.bracket),\r\n  ConditionalSpannerClose: tags.special(tags.bracket),\r\n  ConditionalSpannerCloseNl: tags.special(tags.bracket),\r\n  LoopSpanner: tags.special(tags.bracket),\r\n  LoopSpannerClose: tags.special(tags.bracket),\r\n  LoopSpannerCloseNl: tags.special(tags.bracket),\r\n  EmptyInsert: tags.special(tags.bracket),\r\n  Insert: tags.special(tags.bracket),\r\n});\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 14,\n  states: \"$bOQOaOOOfOXO'#CbOOO`'#Cm'#CmOqOWO'#CcOvOWO'#CfOOO`'#Cp'#CpOOO`'#Ci'#CiO{OaO'#ClO!jOSOOQOOOOOO!oOPO,58{O!tOXO,58|OOO`,58|,58|O!|OQO,58}O#ROQO,59QOOO`-E6g-E6gOOO`1G.g1G.gO#WOPO1G.gOOO`1G.h1G.hO#]OaO1G.iO#qOaO1G.lOOO`7+$R7+$RO$VOPO7+$TO$_OPO7+$WOOO`<<Go<<GoOOO`<<Gr<<Gr\",\n  stateData: \"$g~ORUO_WObPOeROgSO^`P~OQYO_ZOc[O~OQ]O~OQ^O~ORUObPOeROgSO^`XW`XX`XZ`X[`X~OPXO~Oc`O~OQaOcbO~OfcO~OfdO~OceO~ORUObPOeROgSOW`PX`P~ORUObPOeROgSOZ`P[`P~OWhOXhO~OZiO[iO~O\",\n  goto: \"!ZePPPPPfflPPlPPrPPz!TPP!TXQOVcdXTOVcdUVOcdR_VQXOQfcRgdXUOVcd\",\n  nodeNames: \"âš  Feel FeelBlock SimpleTextBlock Feelers Insert EmptyInsert ConditionalSpanner ConditionalSpannerClose ConditionalSpannerCloseNl LoopSpanner LoopSpannerClose LoopSpannerCloseNl\",\n  maxTerm: 23,\n  propSources: [feelersHighlighting],\n  skippedNodes: [0],\n  repeatNodeCount: 1,\n  tokenData: \"%X~RR!_!`[#o#pa#q#r$r~aO_~~dP#o#pg~lQb~str!P!Q!{~uQ#]#^{#`#a!^~!OP#Y#Z!R~!UPpq!X~!^Oe~~!aP#c#d!d~!gP#c#d!j~!mP#d#e!p~!sPpq!v~!{Og~~#OQ#]#^#U#`#a#u~#XP#Y#Z#[~#_P#q#r#b~#eP#q#r#h~#mPW~YZ#p~#uOX~~#xP#c#d#{~$OP#c#d$R~$UP#d#e$X~$[P#q#r$_~$bP#q#r$e~$jPZ~YZ$m~$rO[~R$uP#q#r$xR%PPcPfQYZ%SQ%XOfQ\",\n  tokenizers: [0, 1, feel, feelBlock, simpleTextBlock],\n  topRules: {\"Feelers\":[0,4]},\n  tokenPrec: 0\n});\n\nfunction buildSimpleTree(parseTree, templateString) {\r\n\r\n  const stack = [ { children: [] } ];\r\n  const isLeafNode = (node) => [ 'SimpleTextBlock', 'Feel', 'FeelBlock' ].includes(node.type.name);\r\n\r\n  parseTree.iterate({\r\n    enter: (node, pos, type) => {\r\n\r\n      const nodeRepresentation = {\r\n        name: node.type.name,\r\n        children: []\r\n      };\r\n\r\n      if (isLeafNode(node)) {\r\n        nodeRepresentation.content = templateString.slice(node.from, node.to);\r\n      }\r\n\r\n      stack.push(nodeRepresentation);\r\n    },\r\n    leave: (node, pos, type) => {\r\n      const result = stack.pop();\r\n      const parent = stack[stack.length - 1];\r\n      result.parent = parent;\r\n      parent.children.push(result);\r\n    }\r\n  });\r\n\r\n  return stack[0].children[0];\r\n}\n\n/**\r\n * @typedef {object} EvaluationOptions\r\n * @property {boolean} [debug=false] - whether to enable debug mode, which displays errors inline instead of throwing them\r\n * @property {function} [buildDebugString=(e) => `{{ ${e.message.toLowerCase()} }}`] - function that takes an error and returns the string to display in debug mode\r\n * @property {boolean} [strict=false] - whether to expect strict data types out of our FEEL expression, e.g. boolean for conditionals\r\n * @property {function} [sanitizer] - function to sanitize individual FEEL evaluation results\r\n */\r\n\r\n/**\r\n * @param {string} templateString - the template string to evaluate\r\n * @param {object} [context={}] - the context object to evaluate the template string against\r\n * @param {EvaluationOptions} [options={}] - options to configure the evaluation\r\n * @return {string} the evaluated template string\r\n */\r\nconst evaluate = (templateString, context = {}, options = {}) => {\r\n\r\n  const {\r\n    debug = false,\r\n    strict = false,\r\n    buildDebugString = (e) => `{{ ${e.message.toLowerCase()} }}`,\r\n    sanitizer\r\n  } = options;\r\n\r\n  const parseTree = parser.parse(templateString);\r\n\r\n  const simpleTreeRoot = buildSimpleTree(parseTree, templateString);\r\n\r\n  const evaluateNode = buildNodeEvaluator({ debug, strict, buildDebugString, sanitizer });\r\n\r\n  return evaluateNode(simpleTreeRoot, enhanceContext(context, null));\r\n\r\n};\r\n\r\n/**\r\n * @param {EvaluationOptions} options - options to configure the evaluation\r\n * @return {function} a function that takes a node and context and evaluates it\r\n */\r\nconst buildNodeEvaluator = (options) => {\r\n\r\n  const {\r\n    debug,\r\n    strict,\r\n    buildDebugString,\r\n    sanitizer\r\n  } = options;\r\n\r\n  const errorHandler = (error) => {\r\n\r\n    if (debug) {\r\n      return buildDebugString(error);\r\n    }\r\n\r\n    throw error;\r\n  };\r\n\r\n  const evaluateNodeValue = (node, context = {}) => {\r\n\r\n    switch (node.name) {\r\n\r\n    case 'SimpleTextBlock':\r\n      return node.content;\r\n\r\n    case 'Insert': {\r\n      const feel = node.children[0].content;\r\n\r\n      try {\r\n        const result = evaluate$1(`string(${feel})`, context);\r\n        return sanitizer ? sanitizer(result) : result;\r\n      }\r\n      catch {\r\n        return errorHandler(new Error(`FEEL expression ${feel} couldn't be evaluated`));\r\n      }\r\n    }\r\n\r\n    case 'EmptyInsert':\r\n      return '';\r\n\r\n    case 'Feel':\r\n    case 'FeelBlock': {\r\n      const feel = node.content;\r\n\r\n      try {\r\n        const result = evaluate$1(`string(${feel})`, context);\r\n        return sanitizer ? sanitizer(result) : result;\r\n      }\r\n      catch (e) {\r\n        return errorHandler(new Error(`FEEL expression ${feel} couldn't be evaluated`));\r\n      }\r\n    }\r\n\r\n    case 'Feelers':\r\n      return node.children.map(child => evaluateNode(child, context)).join('');\r\n\r\n    case 'ConditionalSpanner': {\r\n      const feel = node.children[0].content;\r\n      let shouldRender;\r\n\r\n      try {\r\n        shouldRender = evaluate$1(feel, context);\r\n      }\r\n      catch {\r\n        return errorHandler(new Error(`FEEL expression ${feel} couldn't be evaluated`));\r\n      }\r\n\r\n      if (strict && typeof(shouldRender) !== 'boolean') {\r\n        return errorHandler(new Error(`FEEL expression ${feel} expected to evaluate to a boolean`));\r\n      }\r\n\r\n      if (shouldRender) {\r\n        const children = node.children.slice(1, node.children.length - 1);\r\n        const innerRender = children.map(child => evaluateNode(child, context)).join('');\r\n\r\n        const closeNode = node.children[node.children.length - 1];\r\n        const shouldAddNewline = closeNode.name.endsWith('Nl') && !innerRender.endsWith('\\n');\r\n\r\n        return innerRender + (shouldAddNewline ? '\\n' : '');\r\n      }\r\n\r\n      return '';\r\n    }\r\n\r\n    case 'LoopSpanner': {\r\n      const feel = node.children[0].content;\r\n      let loopArray;\r\n\r\n      try {\r\n        loopArray = evaluate$1(feel, context);\r\n      }\r\n      catch {\r\n        return errorHandler(new Error(`FEEL expression ${feel} couldn't be evaluated`));\r\n      }\r\n\r\n      if (!Array.isArray(loopArray)) {\r\n\r\n        if (strict) {\r\n          return errorHandler(new Error(`FEEL expression ${feel} expected to evaluate to an array`));\r\n        }\r\n\r\n        // if not strict, we treat undefined/null as an empty array\r\n        else if (loopArray === undefined || loopArray === null) {\r\n          loopArray = [];\r\n        }\r\n\r\n        // if not strict, we treat a single item as an array with one item\r\n        else {\r\n          loopArray = [ loopArray ];\r\n        }\r\n\r\n      }\r\n\r\n      const childrenToLoop = node.children.slice(1, node.children.length - 1);\r\n\r\n      const evaluateChildren = (arrayElement, parentContext) => {\r\n        const childContext = enhanceContext(arrayElement, parentContext);\r\n        return childrenToLoop.map(child => evaluateNode(child, childContext)).join('');\r\n      };\r\n\r\n      const innerRender = loopArray.map(arrayElement => evaluateChildren(arrayElement, context)).join('');\r\n      const closeNode = node.children[node.children.length - 1];\r\n      const shouldAddNewline = closeNode.name.endsWith('Nl') && !innerRender.endsWith('\\n');\r\n\r\n      return innerRender + (shouldAddNewline ? '\\n' : '');\r\n    }}\r\n\r\n  };\r\n\r\n  const evaluateNode = (node, context = {}) => {\r\n    try {\r\n      return evaluateNodeValue(node, context);\r\n    } catch (error) {\r\n      return errorHandler(error);\r\n    }\r\n  };\r\n\r\n  return evaluateNode;\r\n\r\n};\r\n\r\nconst enhanceContext = (context, parentContext) => {\r\n\r\n  if (typeof(context) === 'object') {\r\n    return { this: context, parent: parentContext, ...context, _this_: context, _parent_: parentContext };\r\n  }\r\n\r\n  return { this: context, parent: parentContext, _this_: context, _parent_: parentContext };\r\n\r\n};\n\nconst foldMetadata = {\r\n  ConditionalSpanner: foldInside,\r\n  LoopSpanner: foldInside\r\n};\r\n\r\nfunction createMixedLanguage(hostLanguage = null) {\r\n  const _mixedParser = parser.configure({\r\n\r\n    wrap: parseMixed(node => {\r\n\r\n      if (node.name == 'Feel' || node.name == 'FeelBlock') {\r\n        return { parser: parser$1 };\r\n      }\r\n\r\n      if (hostLanguage && node.name == 'SimpleTextBlock') {\r\n        return { parser: hostLanguage };\r\n      }\r\n\r\n      return null;\r\n    }),\r\n\r\n    props: [\r\n      foldNodeProp.add(foldMetadata)\r\n    ]\r\n  });\r\n\r\n  return LRLanguage.define({ parser: _mixedParser });\r\n}\n\nconst createFeelersLanguageSupport = (hostLanguageParser) => new LanguageSupport(createMixedLanguage(hostLanguageParser), []);\n\n/**\r\n * Create warnings for empty inserts in the given tree.\r\n *\r\n * @param {Tree} syntaxTree\r\n * @returns {LintMessage[]} array of syntax errors\r\n */\r\nfunction lintEmptyInserts(syntaxTree) {\r\n\r\n  const lintMessages = [];\r\n\r\n  syntaxTree.iterate({\r\n    enter: node => {\r\n      if (node.type.name === 'EmptyInsert') {\r\n        lintMessages.push(\r\n          {\r\n            from: node.from,\r\n            to: node.to,\r\n            severity: 'warning',\r\n            message: 'this insert is empty and will be ignored',\r\n            type: 'emptyInsert'\r\n          }\r\n        );\r\n      }\r\n    }\r\n  });\r\n\r\n  return lintMessages;\r\n}\n\n/**\r\n * Generates lint messages for the given syntax tree.\r\n *\r\n * @param {Tree} syntaxTree\r\n * @returns {LintMessage[]} array of all lint messages\r\n */\r\nfunction lintAll(syntaxTree) {\r\n\r\n  const lintMessages = [\r\n\r\n    ...lintEmptyInserts(syntaxTree)\r\n  ];\r\n\r\n  return lintMessages;\r\n}\r\n\r\n\r\n/**\r\n * CodeMirror extension that provides linting for FEEL expressions.\r\n *\r\n * @param {EditorView} editorView\r\n * @returns {Source} CodeMirror linting source\r\n */\r\nfunction cmFeelersLinter() {\r\n  const lintFeel = cmFeelLinter();\r\n  return editorView => {\r\n\r\n    const feelMessages = lintFeel(editorView);\r\n\r\n    // don't lint if the Editor is empty\r\n    if (editorView.state.doc.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    const tree = syntaxTree(editorView.state);\r\n\r\n    const feelersMessages = lintAll(tree);\r\n\r\n    return [\r\n      ...feelMessages,\r\n      ...feelersMessages.map(message => ({\r\n        ...message,\r\n        source: 'feelers linter'\r\n      }))\r\n    ];\r\n  };\r\n}\n\nvar lint = linter(cmFeelersLinter());\n\n/**\r\n * Creates a Feelers editor in the supplied container.\r\n *\r\n * @param {Object} config Configuration options for the Feelers editor.\r\n * @param {DOMNode} [config.container] The DOM node that will contain the editor.\r\n * @param {DOMNode|String} [config.tooltipContainer] The DOM node or CSS selector string for the tooltip container.\r\n * @param {String} [config.hostLanguage] The host language for the editor (e.g., 'markdown').\r\n * @param {Object} [config.hostLanguageParser] A custom parser for the host language.\r\n * @param {Function} [config.onChange] Callback function that is called when the editor's content changes.\r\n * @param {Function} [config.onKeyDown] Callback function that is called when a key is pressed within the editor.\r\n * @param {Function} [config.onLint] Callback function that is called when linting messages are available.\r\n * @param {Object} [config.contentAttributes] Additional attributes to set on the editor's content element.\r\n * @param {Boolean} [config.readOnly] Set to true to make the editor read-only.\r\n * @param {String} [config.value] Initial value of the editor.\r\n * @param {Boolean} [config.enableGutters] Set to true to enable gutter decorations (e.g., line numbers).\r\n * @param {Boolean} [config.darkMode] Set to true to use the dark theme for the editor.\r\n *\r\n * @returns {Object} editor An instance of the FeelersEditor class.\r\n */\r\nfunction FeelersEditor({\r\n  container,\r\n  tooltipContainer,\r\n  hostLanguage,\r\n  hostLanguageParser,\r\n  onChange = () => { },\r\n  onKeyDown = () => { },\r\n  onLint = () => { },\r\n  contentAttributes = { },\r\n  readOnly = false,\r\n  value = '',\r\n  enableGutters = false,\r\n  singleLine = false,\r\n  darkMode = false\r\n}) {\r\n\r\n  const changeHandler = EditorView.updateListener.of((update) => {\r\n    if (update.docChanged) {\r\n      onChange(update.state.doc.toString());\r\n    }\r\n  });\r\n\r\n  const lintHandler = EditorView.updateListener.of((update) => {\r\n    const diagnosticEffects = update.transactions\r\n      .flatMap(t => t.effects)\r\n      .filter(effect => effect.is(setDiagnosticsEffect));\r\n\r\n    if (!diagnosticEffects.length) {\r\n      return;\r\n    }\r\n\r\n    const messages = diagnosticEffects.flatMap(effect => effect.value);\r\n\r\n    onLint(messages);\r\n  });\r\n\r\n  const contentAttributesExtension = EditorView.contentAttributes.of(contentAttributes);\r\n\r\n  const keyHandler = EditorView.domEventHandlers(\r\n    {\r\n      keydown: onKeyDown\r\n    }\r\n  );\r\n\r\n  if (typeof tooltipContainer === 'string') {\r\n    // eslint-disable-next-line no-undef\r\n    tooltipContainer = document.querySelector(tooltipContainer);\r\n  }\r\n\r\n  const tooltipLayout = tooltipContainer ? tooltips({\r\n    tooltipSpace: function() {\r\n      return tooltipContainer.getBoundingClientRect();\r\n    }\r\n  }) : [];\r\n\r\n  const _getHostLanguageParser = (hostLanguage) => {\r\n    switch (hostLanguage) {\r\n    case 'markdown':\r\n      return parser$2;\r\n    default:\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const feelersLanguageSupport = createFeelersLanguageSupport(hostLanguageParser || hostLanguage && _getHostLanguageParser(hostLanguage));\r\n\r\n  const extensions = [\r\n    bracketMatching(),\r\n    changeHandler,\r\n    contentAttributesExtension,\r\n    closeBrackets(),\r\n    indentOnInput(),\r\n    keyHandler,\r\n    keymap.of([\r\n      ...defaultKeymap,\r\n    ]),\r\n    feelersLanguageSupport,\r\n    lint,\r\n    lintHandler,\r\n    tooltipLayout,\r\n    darkMode ? darkTheme : lightTheme,\r\n    ...(enableGutters ? [\r\n\r\n      // todo: adjust folding boundaries first foldGutter(),\r\n      lineNumbers()\r\n    ] : []),\r\n    ...(singleLine ? [\r\n      EditorState.transactionFilter.of(tr => tr.newDoc.lines > 1 ? [] : tr)\r\n    ] : [])\r\n  ];\r\n\r\n  if (readOnly) {\r\n    extensions.push(EditorView.editable.of(false));\r\n  }\r\n\r\n  if (singleLine && value) {\r\n    value = value.toString().split('\\n')[0];\r\n  }\r\n\r\n  this._cmEditor = new EditorView({\r\n    state: EditorState.create({\r\n      doc: value,\r\n      extensions: extensions\r\n    }),\r\n    parent: container\r\n  });\r\n\r\n  return this;\r\n}\r\n\r\n/**\r\n * Replaces the content of the Editor\r\n *\r\n * @param {String} value\r\n */\r\nFeelersEditor.prototype.setValue = function(value) {\r\n  this._cmEditor.dispatch({\r\n    changes: {\r\n      from: 0,\r\n      to: this._cmEditor.state.doc.length,\r\n      insert: value,\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Sets the focus in the editor.\r\n */\r\nFeelersEditor.prototype.focus = function(position) {\r\n  const cmEditor = this._cmEditor;\r\n\r\n  // the Codemirror `focus` method always calls `focus` with `preventScroll`,\r\n  // so we have to focus + scroll manually\r\n  cmEditor.contentDOM.focus();\r\n  cmEditor.focus();\r\n\r\n  if (typeof position === 'number') {\r\n    const end = cmEditor.state.doc.length;\r\n    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the current selection ranges. If no text is selected, a single\r\n * range with the start and end index at the cursor position will be returned.\r\n *\r\n * @returns {Object} selection\r\n * @returns {Array} selection.ranges\r\n */\r\nFeelersEditor.prototype.getSelection = function() {\r\n  return this._cmEditor.state.selection;\r\n};\n\nexport { FeelersEditor, buildSimpleTree, evaluate, parser };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}