{"ast":null,"code":"import { parser } from 'lezer-feel';\nimport { syntaxTree } from '@codemirror/language';\n\n/**\n * Create an array of syntax errors in the given tree.\n *\n * @param {Tree} syntaxTree\n * @returns {LintMessage[]} array of syntax errors\n */\nfunction lintSyntax(syntaxTree) {\n  const lintMessages = [];\n  syntaxTree.iterate({\n    enter: ref => {\n      const node = ref.node;\n      if (!node.type.isError) {\n        return;\n      }\n      const parent = node.parent;\n      const next = getNextNode(node);\n      const message = {\n        from: node.from,\n        to: node.to,\n        severity: 'error',\n        type: 'Syntax Error'\n      };\n      if (node.from !== node.to) {\n        message.message = `Unrecognized token in <${parent.name}>`;\n      } else if (next) {\n        message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;\n        message.to = next.to;\n      } else {\n        const before = parent.enterUnfinishedNodesBefore(node.to);\n        message.message = `Incomplete <${(before || parent).name}>`;\n      }\n      lintMessages.push(message);\n    }\n  });\n  return lintMessages;\n}\nfunction getNextNode(node) {\n  if (!node) {\n    return null;\n  }\n  return node.nextSibling || getNextNode(node.parent);\n}\n\n/**\n * Generates lint messages for the given syntax tree.\n *\n * @param {Tree} syntaxTree\n * @returns {LintMessage[]} array of all lint messages\n */\nfunction lintAll(syntaxTree) {\n  const lintMessages = [...lintSyntax(syntaxTree)];\n  return lintMessages;\n}\n\n/**\n * Create an array of syntax errors for the given expression.\n *\n * @param {String} expression\n * @returns {LintMessage[]} array of syntax errors\n */\nfunction lintExpression(expression) {\n  const syntaxTree = parser.parse(expression);\n  const lintMessages = lintAll(syntaxTree);\n  return lintMessages;\n}\n\n/**\n * CodeMirror extension that provides linting for FEEL expressions.\n *\n * @param {EditorView} editorView\n * @returns {Source} CodeMirror linting source\n */\nconst cmFeelLinter = () => editorView => {\n  // don't lint if the Editor is empty\n  if (editorView.state.doc.length === 0) {\n    return [];\n  }\n  const tree = syntaxTree(editorView.state);\n  const messages = lintAll(tree);\n  return messages.map(message => ({\n    ...message,\n    source: message.type\n  }));\n};\nexport { cmFeelLinter, lintExpression };","map":{"version":3,"names":["parser","syntaxTree","lintSyntax","lintMessages","iterate","enter","ref","node","type","isError","parent","next","getNextNode","message","from","to","severity","name","before","enterUnfinishedNodesBefore","push","nextSibling","lintAll","lintExpression","expression","parse","cmFeelLinter","editorView","state","doc","length","tree","messages","map","source"],"sources":["/Users/Shivaji/Workspace/Play/cta/node_modules/@bpmn-io/feel-lint/dist/index.esm.js"],"sourcesContent":["import { parser } from 'lezer-feel';\nimport { syntaxTree } from '@codemirror/language';\n\n/**\n * Create an array of syntax errors in the given tree.\n *\n * @param {Tree} syntaxTree\n * @returns {LintMessage[]} array of syntax errors\n */\nfunction lintSyntax(syntaxTree) {\n\n  const lintMessages = [];\n\n  syntaxTree.iterate({\n    enter: ref => {\n      const node = ref.node;\n\n      if (!node.type.isError) {\n        return;\n      }\n\n      const parent = node.parent;\n      const next = getNextNode(node);\n\n      const message = {\n        from: node.from,\n        to: node.to,\n        severity: 'error',\n        type: 'Syntax Error'\n      };\n\n      if (node.from !== node.to) {\n        message.message = `Unrecognized token in <${parent.name}>`;\n      } else if (next) {\n        message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;\n        message.to = next.to;\n      } else {\n        const before = parent.enterUnfinishedNodesBefore(node.to);\n        message.message = `Incomplete <${ (before || parent).name }>`;\n      }\n\n      lintMessages.push(message);\n    }\n  });\n\n  return lintMessages;\n}\n\nfunction getNextNode(node) {\n  if (!node) {\n    return null;\n  }\n\n  return node.nextSibling || getNextNode(node.parent);\n}\n\n/**\n * Generates lint messages for the given syntax tree.\n *\n * @param {Tree} syntaxTree\n * @returns {LintMessage[]} array of all lint messages\n */\nfunction lintAll(syntaxTree) {\n\n  const lintMessages = [\n    ...lintSyntax(syntaxTree)\n  ];\n\n  return lintMessages;\n}\n\n/**\n * Create an array of syntax errors for the given expression.\n *\n * @param {String} expression\n * @returns {LintMessage[]} array of syntax errors\n */\nfunction lintExpression(expression) {\n\n  const syntaxTree = parser.parse(expression);\n\n  const lintMessages = lintAll(syntaxTree);\n\n  return lintMessages;\n}\n\n/**\n * CodeMirror extension that provides linting for FEEL expressions.\n *\n * @param {EditorView} editorView\n * @returns {Source} CodeMirror linting source\n */\nconst cmFeelLinter = () => editorView => {\n\n  // don't lint if the Editor is empty\n  if (editorView.state.doc.length === 0) {\n    return [];\n  }\n\n  const tree = syntaxTree(editorView.state);\n\n  const messages = lintAll(tree);\n\n  return messages.map(message => ({\n    ...message,\n    source: message.type\n  }));\n};\n\nexport { cmFeelLinter, lintExpression };\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,YAAY;AACnC,SAASC,UAAU,QAAQ,sBAAsB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAACD,UAAU,EAAE;EAE9B,MAAME,YAAY,GAAG,EAAE;EAEvBF,UAAU,CAACG,OAAO,CAAC;IACjBC,KAAK,EAAEC,GAAG,IAAI;MACZ,MAAMC,IAAI,GAAGD,GAAG,CAACC,IAAI;MAErB,IAAI,CAACA,IAAI,CAACC,IAAI,CAACC,OAAO,EAAE;QACtB;MACF;MAEA,MAAMC,MAAM,GAAGH,IAAI,CAACG,MAAM;MAC1B,MAAMC,IAAI,GAAGC,WAAW,CAACL,IAAI,CAAC;MAE9B,MAAMM,OAAO,GAAG;QACdC,IAAI,EAAEP,IAAI,CAACO,IAAI;QACfC,EAAE,EAAER,IAAI,CAACQ,EAAE;QACXC,QAAQ,EAAE,OAAO;QACjBR,IAAI,EAAE;MACR,CAAC;MAED,IAAID,IAAI,CAACO,IAAI,KAAKP,IAAI,CAACQ,EAAE,EAAE;QACzBF,OAAO,CAACA,OAAO,GAAI,0BAAyBH,MAAM,CAACO,IAAK,GAAE;MAC5D,CAAC,MAAM,IAAIN,IAAI,EAAE;QACfE,OAAO,CAACA,OAAO,GAAI,uBAAsBF,IAAI,CAACM,IAAK,SAAQP,MAAM,CAACO,IAAK,GAAE;QACzEJ,OAAO,CAACE,EAAE,GAAGJ,IAAI,CAACI,EAAE;MACtB,CAAC,MAAM;QACL,MAAMG,MAAM,GAAGR,MAAM,CAACS,0BAA0B,CAACZ,IAAI,CAACQ,EAAE,CAAC;QACzDF,OAAO,CAACA,OAAO,GAAI,eAAe,CAACK,MAAM,IAAIR,MAAM,EAAEO,IAAM,GAAE;MAC/D;MAEAd,YAAY,CAACiB,IAAI,CAACP,OAAO,CAAC;IAC5B;EACF,CAAC,CAAC;EAEF,OAAOV,YAAY;AACrB;AAEA,SAASS,WAAWA,CAACL,IAAI,EAAE;EACzB,IAAI,CAACA,IAAI,EAAE;IACT,OAAO,IAAI;EACb;EAEA,OAAOA,IAAI,CAACc,WAAW,IAAIT,WAAW,CAACL,IAAI,CAACG,MAAM,CAAC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,OAAOA,CAACrB,UAAU,EAAE;EAE3B,MAAME,YAAY,GAAG,CACnB,GAAGD,UAAU,CAACD,UAAU,CAAC,CAC1B;EAED,OAAOE,YAAY;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,cAAcA,CAACC,UAAU,EAAE;EAElC,MAAMvB,UAAU,GAAGD,MAAM,CAACyB,KAAK,CAACD,UAAU,CAAC;EAE3C,MAAMrB,YAAY,GAAGmB,OAAO,CAACrB,UAAU,CAAC;EAExC,OAAOE,YAAY;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMuB,YAAY,GAAGA,CAAA,KAAMC,UAAU,IAAI;EAEvC;EACA,IAAIA,UAAU,CAACC,KAAK,CAACC,GAAG,CAACC,MAAM,KAAK,CAAC,EAAE;IACrC,OAAO,EAAE;EACX;EAEA,MAAMC,IAAI,GAAG9B,UAAU,CAAC0B,UAAU,CAACC,KAAK,CAAC;EAEzC,MAAMI,QAAQ,GAAGV,OAAO,CAACS,IAAI,CAAC;EAE9B,OAAOC,QAAQ,CAACC,GAAG,CAACpB,OAAO,KAAK;IAC9B,GAAGA,OAAO;IACVqB,MAAM,EAAErB,OAAO,CAACL;EAClB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAASkB,YAAY,EAAEH,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}